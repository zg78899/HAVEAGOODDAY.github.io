<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>하이브리드 웹, 네이티브 웹, 웹 앱의 차이점</title>
    <url>/2020/05/07/%20webapp/</url>
    <content><![CDATA[<h3 id="localStorage와-session-storage의-가장-큰-차이점"><a href="#localStorage와-session-storage의-가장-큰-차이점" class="headerlink" title="localStorage와 session storage의 가장 큰 차이점"></a>localStorage와 session storage의 가장 큰 차이점</h3><ul>
<li><p>local storage  만료기간이 없기때문에  브라우저가 종료되어도 남아있는다.</p>
</li>
<li><p>session storage 브라우저가 종료되면은 사라진다.</p>
</li>
</ul>
<hr>

<h2 id="1-하이브리드-앱"><a href="#1-하이브리드-앱" class="headerlink" title="1. 하이브리드 앱"></a>1. 하이브리드 앱</h2><p>하이브리드 앱은 네이티브 개발과 웹 기술을 융합한 방식입니다. 기본 기능은 HTML 등의 웹 문서로 구현하고, 패키징은 아이폰, 안드로이드 등 모바일 운영 체제(OS) 별로 구현하는 것이다.<br>따라서 네이티브 앱과 같이 앱 스토어에서 다운로드하여 사용할 수 있고, 기기에 저장된 고유 파일이나 카메라와 같은 하드웨어적인 부분에 접근성을 가질 수도 있습니다. 또한, 근본적으로는 웹 기술을 이용한 것이기에 빠르고, 편리하게 앱을 유지보수할 수 있습니다.</p>
<p><strong>하이브리드 앱의 단점</strong>은 네이티브 앱보다 UI를 구성하는 디자인 부분이 취약하며, 성능이 떨어진다는 것입니다. 또한, 웹 브라우저를 실행하여 콘텐츠를 제공하기에 인터넷 속도에 따라 구동 속도가 느려질 수도 있습니다.</p>
<h3 id="1-1-하이브리드-APP의-장점"><a href="#1-1-하이브리드-APP의-장점" class="headerlink" title="1.1. 하이브리드 APP의 장점"></a>1.1. 하이브리드 APP의 장점</h3><p>■ 네이티브 API 와 브라우저 API 를 이용한 다양한 개발이 가능 합니다.<br>■ 웹개발 기술을 사용해 앱을 개발할 수 있습니다.<br>■ 한번의 개발로 다수의 플랫폼에 대응할 수 있습니다.</p>
<h3 id="1-2-하이브리드-APP의-단점"><a href="#1-2-하이브리드-APP의-단점" class="headerlink" title="1.2.하이브리드 APP의 단점"></a>1.2.하이브리드 APP의 단점</h3><p>■ 웹뷰에서 앱을 실행하는 경우이기 때문에 앱의 성능이 곧 브라우저의 성능 입니다.<br>■ UI 프레임워크 도구를 사용하지 않는다면 개발자가 UI를 제작해야 합니다</p>
<hr>

<h3 id="모바일-웹-web-이란"><a href="#모바일-웹-web-이란" class="headerlink" title="모바일 웹 (web) 이란?"></a>모바일 웹 (web) 이란?</h3><p>모바일 웹은 모바일에서 PC용 사이트의 글자폰트와 이미지 , 터치 아이콘 , 플래시 등 데스크탑 브라우저에서 실행되는 기능을 모바일에 맞추어 표현한 사이트를 의미합니다. 쉽개말해 , PC용 홈페이지를 모바일 스크린의 크기에 맞춰 줄여 놓은 것이라고 생각하시면 됩니다.</p>
<hr>

<h2 id="2-웹-앱"><a href="#2-웹-앱" class="headerlink" title="2. 웹 앱"></a>2. 웹 앱</h2><p>웹앱은 모바일웹 과 네이티브앱을 결합한 형태로 모바일웹의 특징을 가지면서 네이티브앱의 장점을 갖고 있습니다. 모바일웹 보다는 조금 더<br>모바일에 최적화 된 앱을 의미 합니다. 웹앱도 모바일웹 처럼 일반적인 웹기술로 개발되고 모바일 브라우저에서 실행되지만 풀 브라우저 방식이 아닌 단일 페이지 방식으로 화면을 진화해 속도가 빠르다는 장점이 있습니다.</p>
<p>모바일 웹 앱이란 PC나 스마트폰 등 단말기의 기종에 관계없이 모든 단말기에서 같은 콘텐츠를 볼 수 있도록 해주는 앱입니다.<br>운영체제(OS)와 직접 통신하는 네이티브 앱과 다르게 웹 앱은 브라우저 내에서 실행됩니다. 따라서 앱을 따로 다운로드하거나 업그레이드하지 않고, 항상 최신 버전을 유지할 수 있지요. 또한, OS별로 별도의 플랫폼이 필요하지 않고, HTML5와 같은 표준 웹 언어로 만들어지기 때문에 제작 비용도 저렴하고, 개발 기간도 비교적 짧은 편입니다.<br>웹 앱 방식은 상대적으로 개발 공수가 적게 들고, 업데이트가 쉽지만 기능상 제한이 많이 따릅니다. 웹 앱은 처음부터 디바이스에 적합한 형태로 만들어지는 것이 아니기 때문입니다. 따라서 네이티브 앱과 비교해 봤을 때, 느리기도 하고, 앱을 통해 기기 고유의 정보를 사용할 수도 없습니다.</p>
<h3 id="2-1-모바일-웹앱의-장점"><a href="#2-1-모바일-웹앱의-장점" class="headerlink" title="2.1. 모바일 웹앱의 장점"></a>2.1. 모바일 웹앱의 장점</h3><p>■ 웹사이트를 보는 것이기 때문에 따로 설치할 필요가 없습니다.<br>■ 모든 기기와 브라우저에서 접근할 수 있습니다.<br>■ 별도 설치 및 승인과정이 필요치 않아 유지보수가 용이 합니다.</p>
<h3 id="2-2-모바일-웹앱의-단점"><a href="#2-2-모바일-웹앱의-단점" class="headerlink" title="2.2. 모바일 웹앱의 단점"></a>2.2. 모바일 웹앱의 단점</h3><p>■ 플랫폼 API (카메라 등) 을 사용할 수 없고 오로지 , 브라우저 API만을 사용할 수 있습니다.<br>■ 친화적인 터치 앱을 개발하기가 약간 번거로운 점이 있습니다. (까다로움)<br>■ 네이티브 , 하이브리드 앱보다 실행이 까다롭습니다. (브라우저를 열고 검색해 들어가야 합니다.)</p>
<hr>

<h2 id="3-네이티브-앱"><a href="#3-네이티브-앱" class="headerlink" title="3. 네이티브 앱"></a>3. 네이티브 앱</h2><p>네이티브 앱은 우리가 흔히 말하는 ‘ 어플리케이션 ‘ 을 의미 합니다. 모바일 기기에 최적화 된 언어로 개발 된 앱으로 안드로이드 SDK를 이용해 Java (자바) 언어로 만드는 앱과 iOS 기반 SDK를 이용해 Swift (스위프트) 로 만드는 대부분의 앱이 여기에 속한다고 할 수 있습니다.</p>
<p>네이티브 앱이란 모바일 기기에 직접 다운로드하여 사용하는 앱입니다. </p>
<p>네이티브 앱이란 모바일 기기에 직접 다운로드하여 사용하는 앱입니다. 네이티브 앱은 사용자가 공용 앱스토어에서 직접 설치할 수도 있고, 모바일 공급업체에서 제공할 수도 있습니다.<br>네이티브 어플을 만들기 위해서는 개발자가 사람이 읽을 수 있는 형식으로 소스코드를 작성하고, 다양한 운영체제(OS: Operation System) 별로 선언 파일이나 이미지, 오디오 등의 리소스를 만들어야 합니다. 그다음, 모바일 운영체제(OS)에서 제공하는 툴을 활용하여 소스코드를 컴파일하고, 여러 실행 파일을 만들어야 하지요.<br>이처럼 네이티브 앱은 각기의 모바일 운영체제(OS)에서 제공하는 툴과 언어 등에 따라 기능들을 최대한 살리기 때문에, 높은 사양의 그래픽과 성능을 자랑하면서도 구동 속도가 빠른 편입니다. 뿐만 아니라 디바이스 전체에 액세스 권한을 가질 수 있어, 기기에 저장된 주소록, 캘린더 등의 고유 정보를 사용할 수도 있지요.<br>하지만 다른 방식들보다 높은 수준의 기술력이 필요하며, 각기의 모바일 운영체제(OS)별로 앱을 개발해야하기 때문에 개발 기간이나 비용이 많이 들 수 있습니다.</p>
<h3 id="3-1-네이티브-앱의-장점"><a href="#3-1-네이티브-앱의-장점" class="headerlink" title="3.1. 네이티브 앱의  장점"></a>3.1. 네이티브 앱의  장점</h3><p>성능이 웹앱 , 하이브리드 앱에 비하여 가장 높습니다.<br>■ 네이티브 API를 호출하여 사용함으로 플랫폼과 밀착되어 있습니다.<br>■ 해당 언어에 익숙한 사용자라면 좀 더 쉽게 접근할 수 있습니다.</p>
<h3 id="3-2-네이티브-앱의-단점"><a href="#3-2-네이티브-앱의-단점" class="headerlink" title="3.2. 네이티브 앱의 단점"></a>3.2. 네이티브 앱의 단점</h3><p>플랫폼에 한정적 입니다.<br>■ 해당 플랫폼에서 요구하는 언어에 제약적 입니다. 따라서 해당 언어와 플랫폼의 API를 다루는데 익숙해야 합니다.</p>
]]></content>
      <tags>
        <tag>하이브리드 웹, 네이티브 웹, 웹 앱의 차이점에대해 알아보자</tag>
      </tags>
  </entry>
  <entry>
    <title>10월 2일 수업내용정리</title>
    <url>/2019/10/03/10%EC%9B%942%EC%9D%BC%EC%88%98%EC%97%85%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/</url>
    <content><![CDATA[<p><strong>자바스크립트의 특징</strong> - 웹브라우저에서 동작하는 유일한 언어/고속으로 동작하는(웹 브라우저로 돌리는 게임) 어플리케이션에선 불리함</p>
<p>기계어 프로그래밍 언어(어셈블리언어)-만국공용어-&gt;어셈블리어 cpu종류마다 실행파일이 다름.그에따라 실질적인 언어 사용</p>
<p>웹 어셈블리어(보통 게임에서 사용) c#,c++뭐로코딩하든 중간으로 떨려서 브라우저를 돌리자.</p>
<p><strong>대부분의 언어 객체지향</strong>-&gt; 클래스로함(<strong>클래스 기반 객체지향언어</strong>)<br><strong>자바스크립트</strong>는-<strong>프로토 타입기반의 객체지향</strong></p>
<p>c(절차지향)/java(객체지향)/<strong>javascript(멀티 패러다임,객체 절차(명령),함수형 언어)</strong></p>
<p><strong>자바스크립트의 함수는 값이다</strong>.(값이란 서로 주고받을 수 있는 특성을 의미한다.why:함수형 프로그래밍을 가능하게 하기 위해)</p>
<p><strong>자바스크립트엔진</strong>-자바스크립트를 실행할 수있는 환경</p>
<p><strong>인터프리터</strong>-컴파일러가 결합해서 처리속도느린것을 해결-but토끼굴 </p>
<p><strong>명령어</strong>-절차지향형,함수,프로토타입기반 객체지향 (프로토 타입기반 객체기반을 중심으로 공부를 한다.)-멀티 프로그래밍/객체기반 언어-클래스기반(c#,java).</p>
<hr>
<p> <strong>web api(web aplication progamming interface)</strong>가 들어있는 환경에서는 웹브라우저에서만 적용한다. node.js에서 실행x</p>
<p>html은 크게 2개의 태그를 가진다.(<head><meta name="generator" content="Hexo 3.9.0">,</head><body>)<br>head-meta date=설정 정보(애플리케이션을 위한 데이터) 기본적으로 시멘틱을 생각했을때 sciprt태그가 head에 들어가야한다고 생각하지만, html은 인터프리터 언어이기때문에 스크립트 태그는 body끝나기 전에 사용한다.이는 DOM을 생성하는 것과 관련이있다. script태그가 앞에나오게 되면 html은 순차적으로 위에서 아래도 일고 해석하는 인터프리터 언어인데 scipt태그에서 DOM과 관련된 내용을 건드리게 되고 아직html의 DOM은 생성되어있는 상태가 아니기 때문에 에러를 발생시킨다.</body></p>
<script>안의 document.querySelecotr와 같은 요소 관련 내용은 html,css와 관련된 web api이다-> 그래서 웹 브라우저에서 실행하고 ,node.js에서는 실행하지 못한다.

 **ECMAScript는 (node/브라우저)모두 포함하는 코어이다.**

### 웹 브라우저는 어떻게 동작하는가?

client(웹브라우저)---server(회사의 서버)
request(client->server)------------response(server->client)

**loading(로딩)**-브라우저가 서버로 부터 다운로드하여 파일을 가져온다. 웹서버는 루트(대문)로 접근하면 index.html(html파일 안에는 javascript와 css등이 링크로 연결이 되어있다.)을 받을 수있다. 

www.naver.com/(index.html주소창에 생략이가능하다).-도메인 주소(서버가 식별 할 수 있는 주소)

------

모든 웹애플리케이션은 **HTTP**(htper text transfer protocol)프로토콜을 규약으로 동작한다.(request/response).서버의 파일은 0,1로 구성되어있는 데이터이다.이를 웹브라우저로  보낼때 서버에있는 정보를 패킷으로 잘게 쪼갠 정보를 보내고 이를 받아서 하나의 파일로 뭉치는 과정을 겪는다.



![3-3](https://poiemaweb.com/assets/fs-images/3-3.png)

load HTML을 한 상태가 (resquest와 response를 해서 index.html을 파일을 받은 상태)---Read(메모리상에 데이터를 올린다.)----Parse(html데이터를 읽어들여서 컴퓨터가 실행할 수있는 형식으로 만든다.)----->(결과물)Dom tree(부자관계 부모와 자식의 구조를 가진다.)

기본 html은 중첩된 구조를 가지고 있다.크게 html의 자식으로 head와 body태그가 있다.(이는 부모와 자식이라는  구조화 할 수있다.)그리고 container라는 div태그를 만들어서 그 안에 자식을 넣고 그 자식의 형제들을 넣는다. 그렇게 하는 것이 부모의 속성을 자식에게 상속시켜서 한번에 무엇인가를 처리하기 좋다. html의 중첩 같이 html의 자료구조를 배열하는것이 DOM tree를 구성하는 것이다. 

**이렇게 트리구조를 만드는 이유는?**-그래야 부모로 올라가고 자식으로 내려가고 왔다 갔다하면서 자료에 접근하기가 용이하다. 조작을 하려면 접근해야하는 메모리상 트리구조에서 조작을 한다. parsing은 rendering engine(html과 css)에서한다. http 1.1. connection은 한번에 자료를 하나씩 가져옴을 의미한다

html의 link에 css가 있으면 다시 서버에 요청을 보내서 그것을 가져와야한다. 그렇게 되면 html에서 parsing되며 만들고있던 Dom만들기를 일시 중단을 한다. css도 Dom tree를 형성하는데 이를 cssom tree라고 한다. 그후 DOM를 생성하는 작업을 계속 수행한다.(pasing 작업) 작업이 진행되면서 내려가다가 자바스크립트 링크를 만나면 다시 parsing를 중단하고  자바스크립트 엔진에서 이를 parsing한다 그러고 javascript DOM(syantax tree)을 만든다. 이런과정을 거치면서 만들어진html Dom 와 CSS DOM를 합쳐서 render tree라고 부른다.

render tree가 만들어지면은 이제 웹 브라우저에 그릴 준비가 끝났다.이후 그림을 그릴때 그림을 그리는것은 부담이 큰작업이기 때문에 변화가 없는 데이터에 대해서는 그리지 말아야한다.

**http특징은 단방향통신이다.**(ex무전기 양쪽에서 동시에 이야기를 할 수 없다.)/양방향통신(휴대전화)
**http특징 단방향 통신이지만 쌍으로 이루어져있다**.(request를 보내면 반드시 response가 있다. 요청을 받아서 그림을 그린다.)
Dom tree와 CSSOM TREE가 합쳐지고 render tree가 생성되는데 javascript의 sytax tree는 render tree의 내용을 지우거나 내용을 갈아낀운다던가 혹은 글자의 속성을 바꾼다 던지의 수행을 한다.



파일로 된 javascript 소스코드
token(더이산 나눌수 없는 원소-으미를 가지고 있는 최소단위인 형태소의 의미를 가진다.)
구문분석=문법들을 추가한다(어셈블리어로 만든다.)
자바스키립트 엔진의 소스코드 실행과정
script태그가 돔 구성보다 먼저 등장해서  cssom tree,dom tree의 돔 트리를 건드리면  DOM이 구성되지 상태이기 때문에 오류를 발생한다. body tag밑으로 와야한다.</script>]]></content>
      <tags>
        <tag>10월 2일 수업내용 정리</tag>
      </tags>
  </entry>
  <entry>
    <title>10월 7일 러버덕(키워드,식별자,변수와 선언,메모리,메모리 주소,할당,호이스팅)</title>
    <url>/2019/10/07/10%EC%9B%947%EC%9D%BC%EB%9F%AC%EB%B2%84%EB%8D%95/</url>
    <content><![CDATA[<h3 id="1-키워드"><a href="#1-키워드" class="headerlink" title="1.키워드:"></a><strong>1.키워드</strong>:</h3><p>명령어(뒤에 값을 준다.)<br><strong>자바스크립트에게 내리는 명령.</strong><br>변수선언하려면 반드시  키워드 사용(var/let,const)</p>
<h3 id="2-식별자-변수이름"><a href="#2-식별자-변수이름" class="headerlink" title="2.식별자(변수이름):"></a><strong>2.식별자(변수이름):</strong></h3><p>고유한이름/일종의 카드키와 같다.<br><strong>식별자(변수이름)-메모리에 있는 값을 구별해서 끄집에 낼 수 있는 값</strong><br>./어떤 값을 구별하여 식별해 낼 수 있는고유한 이름.</p>
<p>또한 <strong>식별자는 메모리 주소를 알고있다.</strong></p>
<p>변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 저장된다.<br>네이밍 규칙-예약어x/특수문자 _ $가능 숫자 처음 에 안나옴.</p>
<h3 id="3-변수와-선언"><a href="#3-변수와-선언" class="headerlink" title="3.변수와 선언:"></a><strong>3.변수와 선언:</strong></h3><p><strong>변수-</strong>데이터를 다룬다. 하나의 값을 저장할 수있는 메모리 공간에 붙은 이름 혹은 메모리 자체를 의미한다.</p>
<p>변수를 사용하려면 반드시 선언을 해줘야한다.</p>
<p><strong>변수의 선언-</strong><br>변수를 생성한다. 변수란 컴퓨터의 메모리 와 관련있다.<br>자바스크립크엔진에 변수이름 등록,값 저장을 위한 메모리 공간을 확보하기위함.</p>
<h3 id="4-메모리와-주소"><a href="#4-메모리와-주소" class="headerlink" title="4.메모리와 주소:"></a><strong>4.메모리와 주소:</strong></h3><p>메모리:데이터를 저장할 수 있는 데이터 셀들의 집합체.<br>메모리주소: 메모리 공간의 위치를 나타내며 0부터 시작하여 메모리의 크기만큼 정수로 표현된다. </p>
<p>값을 입력하면 메모리 임의의 공간에 저장이 된다.하지만 메모리의 주소는 알여주지 않는데 저장된 데이터를 재사용하기 위해서는 변수를 제공해야하고 변수는 저장되는 곳의 메모리 주소를 기억한다.</p>
<p>매니지드:(자바스크립트):<br>언매니지드(c언어):</p>
<h3 id="5-할당"><a href="#5-할당" class="headerlink" title="5.할당:"></a><strong>5.할당</strong>:</h3><p> 변수에 값을 저장한다. 할당한다(저장한다.대입한다.assign한다)<br>논리적으로 기본적으로 변수를 선언하고 할당해야한다. 변수만을 선언하고 할당하지 않으면 값이 정의 되지 않았기 때문에 undefined가 출력이 된다.</p>
<p>변수선언은 소소코드가 순차적으로 실행되기 이전,즉 런타임 이전에 먼저실행되지만,값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.</p>
<h3 id="6-호이스팅"><a href="#6-호이스팅" class="headerlink" title="6.호이스팅-"></a><strong>6.호이스팅-</strong></h3><p>왜 호이스팅이 발생하는가?-&gt;**선언문은 실행될때 가장먼저 골라져서 실행되기대문에 발생한다.위 끌어올려서 실행된 실행문은 또 실행되지 않는다.</p>
]]></content>
      <tags>
        <tag>1키워드,2.식별자.3.변수와 선언 4.메모리와 메모리주소5.할당6.호이스팅</tag>
      </tags>
  </entry>
  <entry>
    <title>IR 기법</title>
    <url>/2019/09/17/IR%EA%B8%B0%EB%B2%95/</url>
    <content><![CDATA[<p>홈페이지를 만들때 이미지를 사용할 경우 img태그를 사용해 alt로 이미를 부여 합니다.</p>
<p>IR(image replacement)은 웹표준 및 접근성을 위한 기법입니다. 이미지를 배경으로 처리하고 이미지의 의미를 텍스트화 하여 CSS로  숨겨, 이미지 대체 텍스트를 제공하기 위한 기법 입니다. IR기법은 앞에서 얘기한 대로 접근성이 매우 유용하기 때문에 검색시에 검색엔진으로 부터 높은 가중치를 받을 수 있습니다.</p>
<p>IR을 사용하는 방법으로는 크게 </p>
<ol>
<li><p>padding을 사용하는 방법(가로 250px,세로 195px인 이미지)</p>
<h2 class="brand1">CSS ZenGarden</h2>

<p> .brand1{ background:pink url()no-repeat;height: 0;width: 250px;padding-left: 195px;overflow: hidden;}</p>
</li>
<li><p>text-indent 를 사용하는 방법</p>
<h2 class="brand2">CSS ZenGarden</h2>

<p>.brand2{background: pink url(/images/title.png)no-repeat;height: 195px;width: 290px;text-indent: 290px;</p>
<p>​    <em>/\</em> text-indent: -9999px; */*white-space: nowrap;overflow: hidden;}</p>
<p>*text-indent의 값을 -9999px을 주어 텍스트를 아예 화면 밖으로 밀어 버리는 경우도 있지만, 이 경우에는 성능상 좋지 않으므로 white-space:nowrap와 overflow:hidden을 사용한다.</p>
</li>
<li><p>postion을 활용하는 방법</p>
<h1 class="brand3">CSS ZenGarden</h1>

<p>.brand3{background: lime ;height: 195px;width: 290px;text-align: center;line-height: 195px; font-size: 16px;font-weight: 400;position: relative;} .brand3::after{ content: “”;position: absolute;top: 0;left: 0;background: url(/images/title.png)no-repeat;width: 100%;height: 100%;}</p>
</li>
</ol>
<p>이외에도 숨기고자하는 텍스트를 span태그로 감싸 준 후 화면에서 안보이게 처리해주는 방법도 있고, 방법은 다양하다.</p>
<p>그리고 Daum은 이런 여러기법중에서  Phark Method와WA IR 기법을 주로 사용하여 대체텍스트를 제공해주고 있다.</p>
<p>Phark Method (권장): 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 text-indent를 이용하여 화면 바깥으로(-9999px만큼 내어 쓰기) 빼내어 보이지 않게 하는 방법.</p>
<p>장점:스크린 리더기가 읽어주고,추가적인 태그사용을 하지 않는다.</p>
<p>WA IR 기법(권장):이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span 태그로 감싼 후 z-index:-1을 이용하여 화면에 안보이게 처리하는 방법.</p>
<p>장점:스크린 리더기 가 읽어줌,CSS on / Image off 시 텍스트 보임.</p>
]]></content>
      <tags>
        <tag>IR기법 활용에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>CSR(클라이언트 사이드 렌더링)과 SSR(서버 사이드 렌더링) 차이점</title>
    <url>/2020/05/03/CSR%20SSR%20SPA%20/</url>
    <content><![CDATA[<p><strong>1.CSR(클라이언트 사이드 렌더링)</strong><img src="https://s3.amazonaws.com/media-p.slid.es/uploads/640576/images/3943424/CSR.png" alt="CSR"></p>
<p>-1.Server Sending Response to Browser<br>-2.Browser Downloads JS<br>-3.Browser executes React<br>-4.Page Now Viewable and Interatable</p>
<p>서버에서 비어있는 html와  js파일들을 받아오고 , 데이터는 서비스에 필요한 리소스를 다운로드한후 브라우저에서 렌더링한다.그렇기 때문에 초기 View을 보기가지 SSR보다 시간이 더 걸린다. 하지만 사용자에게 보여진 view의 기능은 동시에 동작한다.</p>
<p><strong>2.SSR(서버사이드 렌더링)</strong><img src="https://s3.amazonaws.com/media-p.slid.es/uploads/640576/images/3943426/SSR.png" alt="SSR"></p>
<p>-1.Server Sending Ready tobe redered HTML Response to Browser<br>-2.Browser Renders the page,Now Viewable,andBrowser Downloads JS<br>-3.Browser execute React<br>-4.Page Now interatable</p>
<p>서버에서 렌더링해 가져오기 때문에 ,첫 로딩 매우 짧다.<br>그러나 클라이언트가 js파일을 모두 다운로드하고 적용하기전가지는 각각의 기능은 동작하지않는다는 단점이 있다</p>
<p><strong>3.SPA(Single page application)</strong></p>
<p>서버로 부터 처음에만 페이지를 받아오고 이후에는 동적으로 페이지를 구성해서 새로운 페이지를 받아오지않는 웹 애플리케이션을 의미한다.<br> 페이지가 한번 로딩된 이후 데이터를 수정하거나 조회할때. 페이지가 새로고침이 되지않고 다른 페이지로 넘어가지 않습니다.</p>
<p><strong>4.MPA(Multi Page Application)</strong></p>
<p>서버로 부터 완전한 페이지를 받아오고 이후에 데이터를 수정하거나 조회할때 다른 완전한 페이지로 이동합니다.단 URL이 바뀔수있습니다.</p>
]]></content>
      <tags>
        <tag>CSR(클라이언트 사이드 렌더링)과 SSR(서버 사이드 렌더링) 차이점</tag>
      </tags>
  </entry>
  <entry>
    <title>Set을 사용한 교집합, 합집합, 차집합, 상위</title>
    <url>/2020/05/23/aboutSet-md/</url>
    <content><![CDATA[<h1 id="1-Set의-사용한-교집합-합집합-차집합-상위"><a href="#1-Set의-사용한-교집합-합집합-차집합-상위" class="headerlink" title="1.Set의 사용한 교집합 , 합집합 , 차집합 , 상위"></a>1.Set의 사용한 교집합 , 합집합 , 차집합 , 상위</h1><p>Set은 중복값을 제외한 유일한 값을 저장한다. 그렇기에 교집합, 합집합 , 차집합, 상위 등을 나타내는데 사용하기 에 용이하다.</p>
<h2 id="1-1-교집합"><a href="#1-1-교집합" class="headerlink" title="1.1. 교집합"></a>1.1. 교집합</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//첫번째 방법</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.intersaction = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>)</span>&#123;</span><br><span class="line">   <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.has(value))</span><br><span class="line">      result.add(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>,<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(setA.intersaction(setB)) <span class="comment">// [2,4];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//두번째 방법</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.intersaction = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...this].filter(<span class="function"><span class="params">v</span>=&gt;</span> <span class="keyword">set</span>.has(v));</span><br><span class="line">&#125;</span><br><span class="line">const setA = new Set([1,2,3,4]);</span><br><span class="line">const seB = new Set([2,4]);</span><br><span class="line"></span><br><span class="line">console.log(setA.intersaction(setB)) // [2,4];</span><br></pre></td></tr></table></figure>

<h2 id="1-2-합집합"><a href="#1-2-합집합" class="headerlink" title="1.2. 합집합"></a>1.2. 합집합</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//첫번째 방법</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype.union = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>)&#123;</span><br><span class="line">    result.add(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(setA.union(setB)) <span class="comment">//[1,2,3,4];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 두번째 방법</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype.union = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>([...this,...set])</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(setA.union(setB)) <span class="comment">//[1,2,3,4];</span></span><br></pre></td></tr></table></figure>

<h2 id="1-3-차집합"><a href="#1-3-차집합" class="headerlink" title="1.3 차집합"></a>1.3 차집합</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//첫번째 방법</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.differnce = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>)&#123;</span><br><span class="line">    result.delete(value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(setA.difference(setB)) <span class="comment">//[1,3];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//두번째 방법</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.prototype.difference = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...this].filter(<span class="function"><span class="params">v</span>=&gt;</span> !<span class="keyword">set</span>.has(v));</span><br><span class="line">&#125;</span><br><span class="line">const setA = new Set([1,2,3,4]);</span><br><span class="line">const setB = new Set([2,4]);</span><br><span class="line"></span><br><span class="line">consoel.log(setA.differnce(setB)) //[1,3];</span><br></pre></td></tr></table></figure>

<h2 id="1-4-상위"><a href="#1-4-상위" class="headerlink" title="1.4. 상위"></a>1.4. 상위</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//첫번째 방법</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.isSuperset = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>)</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> value <span class="keyword">of</span> subset)&#123;</span><br><span class="line">  <span class="keyword">if</span>(!<span class="keyword">this</span>.has(value))<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>,<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(setA.isSuperset(setB)) <span class="comment">// true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//두번째 방법</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.isSuperset = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> superArr = [...this];</span><br><span class="line">  <span class="keyword">return</span> [...superArr].every(<span class="function"><span class="params">v</span> =&gt;</span> superArr.includes(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA =<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>,<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(setA.isSuperset(setB)) <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Set을 사용한 교집합 ,합집합, 차집합, 상위</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript와 Javascript의 차이</title>
    <url>/2020/05/15/ecmascript-and-javascript-md/</url>
    <content><![CDATA[<h1 id="ECMAScript-와-JavaScript"><a href="#ECMAScript-와-JavaScript" class="headerlink" title="ECMAScript  와 JavaScript"></a>ECMAScript  와 JavaScript</h1><p><img src="https://user-images.githubusercontent.com/54792457/83939299-db499180-a816-11ea-8cd9-d469f3090c1e.jpg" alt="vrr5uvt5vp"></p>
<p><strong><u>ECMAScript는 자바스크립트의 표준사양인 ECMA-262를 말하며</u></strong> 프로그래밍 언어의 타입 , 값,객체와 프로퍼티,함수,표준 빌트인 객체 등 핵심 문법을 규정한다. 각 브라우저 제조사는 ECAMScript를 준수하여 브라우저에 내장되어있는 자바스크립트 엔진을 구현한다.<br><strong><u>자바스크립트는 일반적으로 프로그래밍 언어</u></strong>로서 기본 뼈대를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 WEB API,즉 DOM ,BOM, Canvas ,XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker등을 아우르는 개념이다.<br> 즉 Javascript &gt; Ecmascript (자바스크립가 더 큰 개념이다.)<br>클라이언트 사이드 WEB API는 ECMAScript와는 별도로 World Wide Web Consortium(W3C)에서도 별도로 명세로 관리하고 있다.</p>
<p>요약하자면 ECMAScript는 ecma 인터내셔녈에 의해 정의된 ECMA -262 기술규격에 의해 정의된 범용 자바스크립트 언어를 뜻합니다. ‘ECMAScript 사양’입니다.<br>ECMA -262 는 표준의 이름이고, ECMAScript는 ECMA -262에서 정의된 하나의 사양을 의미합니다. ECMAScript는 스크립트언어가 준수해야하는 규칙,세부사항 및 지침을 제공합니다.</p>
<p>JavaScript는 ECMAScript가 사양을 준수하는 범용 스크립트팅 언어 입니다. 자바스크립트느 ECMAScript아우르는 개념입니다..</p>
<p>또한 JavaScripts는 1996년에 반들어 졌고 , 그 다음 해에 JavaScriptd를 표준화하기 위해서 1997년 ECMAScript가 만들어졌습니다. JavaScript는 ECMAScript 사양을 준수하는 언어이며 , JavaScript가  ECMAScript을 기반하는 동시에 ECMAScript도 JavaScript를 기반으로 한다. </p>
]]></content>
      <tags>
        <tag>ECMAScript와 Javascript의 차이</tag>
      </tags>
  </entry>
  <entry>
    <title>제너레이터와 async-await</title>
    <url>/2020/05/05/generator-aync-await-md/</url>
    <content><![CDATA[<h1 id="1-제네레이터"><a href="#1-제네레이터" class="headerlink" title="1.제네레이터"></a>1.제네레이터</h1><p>es6에서 도입된 제너레이터 함수는  이터러블을 생성하는 함수이다. 제너레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편하게 이터러블을 구현 할 수 있다. 또한 제너레이터 함수는 비동기 처리에 유용하게 사용된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//이터레이션 ㅍ,로토콜을 구현하여 무한 이터러블을 생성하는 함수</span></span><br><span class="line"><span class="keyword">const</span> createInfinittbyIteration = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i =<span class="number">0</span>;<span class="comment">//자유 변수</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;,</span><br><span class="line">    next()&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>:++i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> n <span class="keyword">of</span> createInfinitbyIteration())&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">5</span>)<span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n)<span class="comment">//1 2 3 4 5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//무한 이터러블을 생성하는 제너레이터 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createInfinittbyIteration</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;<span class="keyword">yield</span> ++i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> n <span class="keyword">of</span> createInfinittbyIteration())&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n) <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>제너레이터 함수는 일반 함수와는 다른 독특한 동작을 한다. 제너레이터 함수는 일반 함수와 같이 함수의 코드 블로그을 한번에 실행하지 않고 함수 코드 블록의 실행을 일시 중단했다가 필요한 시점에 재시작 할 수 있는 특수한 함수이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'첫번째 호출'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;								<span class="comment">//첫번째 호출시에 이 지점까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'두 번째 호출'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;								<span class="comment">//두번째 호출 시에 이 지점까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'세번째 호출'</span>)<span class="comment">// 세번째 호출 시에 이 지점까지 실행한다</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());<span class="comment">//첫번째 호출 &#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());<span class="comment">//두번째 호출 &#123;value:2,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());<span class="comment">//세번째 호출 &#123;value:undefined,done:true&#125;;</span></span><br></pre></td></tr></table></figure>

<p>일반 함수를 호출하면 return 문으로 반환값을 리턴하지만 제너레이터 함수를 호출하면 제너레이터를 반환한다. 이 제너레이터는 이터러블이면서 동시에 이터레이터인 객체이다. 다시 말해 제너레이터 함수가 생성한 제너레이터는 Symbol.iterator메소드를 소유한 이터러블이다. 그리고 제너레이터는 next()메소드를 소유하며 next메소드를 호출하면 value,done 프로퍼티를 갖는 이터레이터 객체를 반환하는 이터레이터이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//제너레이터 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> v <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="keyword">yield</span> v;</span><br><span class="line">  <span class="comment">//=&gt;yield* [1,2,3];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//제너레이터 함수를 호출하면 제너레이터를 반환한다.</span></span><br><span class="line"><span class="keyword">let</span> generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터는 이터러블이다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> generatorObj) <span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i int generatorObj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)<span class="comment">// 1 2 3 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터는 이터레이터이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span> <span class="keyword">in</span> generatoroBJ)	<span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:1,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:2,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:3,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:undefined,done:true&#125;;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-제너레이터-함수의-정의"><a href="#2-제너레이터-함수의-정의" class="headerlink" title="2.제너레이터 함수의 정의"></a>2.제너레이터 함수의 정의</h1><p>제너레이터 함수는 function* 키워드로 선언을 한다. 그리고 하나 이상의 yield문을 포함한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//제너레이터 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genDecFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObj = genDecFunc();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 함수 표현식</span></span><br><span class="line"><span class="keyword">const</span> genExpFunc = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 메소드 </span></span><br><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">  *generatorObjMethod()&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">generatorObj = obj.generatorObjMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 클래스 메소드</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">  *generatorClsMethod()&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">generatorObj = myClass.generatorClsMethod();</span><br></pre></td></tr></table></figure>

<h1 id="3-제너리이터-함수의-호출과-제너레이터-객체"><a href="#3-제너리이터-함수의-호출과-제너레이터-객체" class="headerlink" title="3.제너리이터 함수의 호출과 제너레이터 객체"></a>3.제너리이터 함수의 호출과 제너레이터 객체</h1><p>제너레이터 함수를 호출하면 제너레이터 함수의 코드 블록이 실행되는 것이 아니라 제너레이터 객체를 반환한다. 앞에서 살펴본 바와 같이 제너레이터 객체는 이터러블이며 동시에 이터레이터이다. 따라서 next메소드를 호출하기 위해 Symbol.iterator 메소드로 이터레이터를 별도로 생성할 필요가 없다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//제너레이터 함수 정의 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 1'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>; <span class="comment">//첫번째 next메소드 호출시 여기 까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 2'</span>)</span><br><span class="line"> 	<span class="keyword">yield</span> <span class="number">2</span>; <span class="comment">//두번째 next메소드 호출시 여기 까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 3'</span>)</span><br><span class="line"> 	<span class="keyword">yield</span> <span class="number">3</span>; <span class="comment">//세번째 next메소드 호출시 여기 까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 4'</span>)</span><br><span class="line"> 	</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.</span></span><br><span class="line"><span class="comment">//제너레이터 객체는 이터러블이며 동시에 이터레이터이다.</span></span><br><span class="line">.<span class="comment">//따라서 Symbol.iterator 메소드로 이터레이터를 별도 생성할 필요가 없다.</span></span><br><span class="line"><span class="keyword">const</span> generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//첫번째 next 메소드 호출:첫번째 yield문까지 실행되고 일시 중단된다.</span></span><br><span class="line"><span class="comment">// Point 1</span></span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 두번째 next 메소드 호출: 두번째 yield 문까지 실행되고 일시 중단된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());</span><br><span class="line"><span class="comment">// Point 2</span></span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 세번째 next 메소드 호출: 세번째 yield 문까지 실행되고 일시 중단된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());</span><br><span class="line"><span class="comment">// Point 3</span></span><br><span class="line"><span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 네번째 next 메소드 호출: 제너레이터 함수 내의 모든 yield 문이 실행되면 done 프로퍼티 값은 true가 된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());</span><br><span class="line"><span class="comment">// Point 4</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>제너레이터 함수가 생성한 제너레이터 객체의 next메소드를 호출하면 처음만나는 yield문까지 실행되고 실시 중단된다. 또 다시 next메소드를 호출하면 중단된 위치에서 다시 실행이 시작하여 다음 만나는  yieldㅁ누 까지 실행되고 또 다시 일시 중단 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start -&gt; generatorObj.next() -&gt; <span class="keyword">yield</span> <span class="number">1</span> -&gt; generatorObj.next() -&gt; <span class="keyword">yield</span> <span class="number">2</span> -&gt; ... -&gt; end</span><br></pre></td></tr></table></figure>

<p>next 메소드는 이터레이터 결과 객체와 가티이 value,done이라는 프로퍼티를 갖는 객체를 반환한다.vlaue프로퍼티는 yield문이 실행되었는지를 나타내는 boolean타입의 값이다. 마지막 yield문까지 실행된 상태에서 next메소드를 호출하면 done프로퍼티 값을 true가 된다.</p>
<h1 id="4-제너레이터의-활용"><a href="#4-제너레이터의-활용" class="headerlink" title="4.제너레이터의 활용"></a>4.제너레이터의 활용</h1><h2 id="4-1-이터러블의-구현"><a href="#4-1-이터러블의-구현" class="headerlink" title="4.1. 이터러블의 구현"></a>4.1. 이터러블의 구현</h2><p>제너레이터는 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편하게 이터러블을 구현할 수 있다. 이터레이션 프로토콜을 준수하여 무한 피보나치 수열을 생성하는 함수를 구현해 보겠다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 이터러블을 생성하는 함수</span></span><br><span class="line"><span class="keyword">const</span> infinityFibonacci =(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [pre,cur] =[<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [sYMBOL.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;,</span><br><span class="line">    next()&#123;</span><br><span class="line">      [pre,cur] = [cur,pre+cur];</span><br><span class="line">      <span class="comment">//done프로퍼티를 생략한다.</span></span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>:cur&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//infinityFibonacci는 무한 이터러블이다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> infinityFibonacci)&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">10000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">//1 2 3 5 8..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이터레이션 프로토콜을 보다 간단하게 처리하기 위해 제너레이터를 활용할 수 있다. 제너레이터는 활용하여 무한 피보나치수열을 구현한 이터러블을 만들어보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 이터러블틀 생성하는 제너레이터 함수</span></span><br><span class="line"><span class="keyword">const</span> infinityFibonacci =(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">let</span> [pre,cur] = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    [pre,cur] = [cur,pre+cur];</span><br><span class="line">    <span class="keyword">yield</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">//infinityFibonacci는 무한 이터러블이다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> infinityFibonacci)&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &gt;<span class="number">10000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>제너레이터 함수에 최대값을 인수를 전달해보자</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 이터러블을 생성하는 제너레이터 함수</span></span><br><span class="line"><span class="keyword">const</span> createInfiniteFibByGen =<span class="function"><span class="keyword">function</span>* (<span class="params">max</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">let</span> [prec,curr] = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    [prev,curr] =[curr,prev+curr];</span><br><span class="line">    <span class="keyword">if</span>(curr &gt;= max)<span class="keyword">return</span><span class="comment">//제너레이터 함수 종료</span></span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> createInfiniteFibByGen(<span class="number">10000</span>))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이터레이터의 next메소드와 다르게 제너레이터 객체의next메소드에는 인수를 전달할 수도 있다. 이를 통해서 제너레이터 객체에 데이터를 전달 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> res;</span><br><span class="line">  res = <span class="keyword">yield</span> n <span class="comment">//n:0&lt;= gen함수에 전달한 인수</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//res:1 &lt;= 두번째 next 호출 시 전달한 데이터</span></span><br><span class="line">  res = <span class="keyword">yield</span> res;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//res:2 &lt;= 세번째 next 호출 시 전달한 데이터</span></span><br><span class="line">  res = <span class="keyword">yield</span> res;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// res: 3 ⟸ 네번째 next 호출 시 전달한 데이터</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generatorObj = gen(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());  <span class="comment">// 제너레이터 함수 시작</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next(<span class="number">1</span>)); <span class="comment">// 제너레이터 객체에 1 전달</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next(<span class="number">2</span>)); <span class="comment">// 제너레이터 객체에 2 전달</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next(<span class="number">3</span>)); <span class="comment">// 제너레이터 객체에 3 전달</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 3, done: true &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>이터레이터의 next메소드는 이터러블의 데이터를 꺼내 온다. 이에 반해 제너레이터의 next메소드에 인수를 전달하면 제너레이터 객체에 데이터를 밀어 넣는 다. 제너레이터의 이런 특성은 동시성 프로그래밍을 가능케 한다.</p>
<h1 id="4-비동기-처리"><a href="#4-비동기-처리" class="headerlink" title="4.비동기 처리"></a>4.비동기 처리</h1><p> 제너레이터를 사용해 비동기 처리를 동기 처리처럼 구현할 수 있다. 다시말해 비동기 처리 함수가 처리 결과를 반환하도록 구현할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params">genObj,username</span>)</span>&#123;</span><br><span class="line">  fetch(<span class="string">`https://api.github.com/users/<span class="subst">$&#123;username&#125;</span>`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span>res.json())</span><br><span class="line">  <span class="comment">//1.제너레이터 객체에 비동기 처리 결과를 전달한다.</span></span><br><span class="line">  .then(<span class="function"><span class="params">user</span>=&gt;</span> genObj.next(user.name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//제너레이터 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> g =(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> user;</span><br><span class="line">  <span class="comment">//2.비동기 처리 함수가 결과를 반환한다.</span></span><br><span class="line">  <span class="comment">//비동기 처리의 숭성가 보장된다.</span></span><br><span class="line">  user = <span class="keyword">yield</span> getUser(g,<span class="string">'kim'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user); <span class="comment">//</span></span><br><span class="line">  </span><br><span class="line">  user =<span class="keyword">yield</span> getUser(g,<span class="string">'lee'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">  </span><br><span class="line">  user = <span class="keyword">yield</span> getUser(g,<span class="string">'park'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 함수 시작</span></span><br><span class="line">g.next();</span><br></pre></td></tr></table></figure>

<p>1.비동기 처리가 완료되면 next메소드를 통해 제너레이터 객체에 비동기 처리 결과를 전달한다.<br>2.제너레이터 객체에 전달된 비동기 처리 결과는 user 변수에 할당한다.<br>제너레이터를 통해 비동기 처리를 동기 처럼 구현 할 수 있으나 코드는 장황해졌다. 따라서 좀더 간편하게 비동기 처리를 구현할 수있는 async/await가 es7에 도입되었다.</p>
<p><strong>async -await 을 통한 비동기 처리</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise을 반환하는 함수정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params">username</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`https://api.github.com/users/<span class="subst">$&#123;username&#125;</span>`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span>res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">user</span> =&gt;</span>user.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">async</span> fucntion getUsersAll()&#123;</span><br><span class="line">  <span class="keyword">let</span> user;</span><br><span class="line">  user = <span class="keyword">await</span> getUsers(<span class="string">'kim'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">  </span><br><span class="line">  user = <span class="keyword">await</span> getUsers(<span class="string">'park'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">  </span><br><span class="line">  user = <span class="keyword">await</span> getUsers(<span class="string">'lee'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;</span><br><span class="line">getUsersAll();</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>제어레이터와 async-await에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM(DOCUMENT OBJECT MODEL)</title>
    <url>/2020/06/23/dom/</url>
    <content><![CDATA[<p>#DOM</p>
<p>DOM(DOCUMENT OBJECT MODEL)은  HTML문서의 계층적 구조와 정보를 표현하며 이를 제어할 수있는 API,프로퍼티와 메소드를 제공하는 트리 자료 구조이다.</p>
<p>HTML 문서는 HTML요소들의 집합으로 이루어지며 , html요소는 중첩 관계를 갖는다. html콘텐츠 영역에는 텍스트 뿐아니라 다른 html 요소도 포함 될수 있다. 이때 html요소들 간의 계증적인 관계가 형성이 된다.</p>
<p>이러한 HTML 요소 간의 부자 관계를 반영하여 HTML 문서의 구성 요소인 HTML 요소를 객체화한 모든 노드 객체들을 트리 자료 구조로 구성한다.</p>
<p>노드 객테들로 구성된 트리자료 구조를 DOM이라한다. 노드객체의 트리로 구조화되었기 때문에 dom을 dom트리라고 한다.</p>
<p> DOM은 노드 객체의 계층적인 구조로 구성된다. 노드 객체는 종류가 있고 상속 구조를 갖는다. 노드 객체는 총 12개의 종류(노드 타입)가 있다. 이 중에서 중요한 노드 타입은 아래와 같이 4가지이다.</p>
<ul>
<li><ul>
<li><p><strong>문서 노드</strong></p>
<p>문서 노드(document node)는 DOM 트리의 최상위에 존재하는 루트 노드로서 document 객체를 가리킨다. document 객체는 브라우저가 렌더링한 HTML 문서 전체를 가리키는 객체로서 전역 객체 window의 document 프로퍼티에 바인딩되어 있다. 따라서 window.document 또는 document로 참조할 수 있다.브라우저 환경의 모든 자바스크립트 코드는 script 태그에 의해 분리되어 있어도 하나의 전역 객체 window를 공유한다. 따라서 모든 자바스크립트 코드는 전역 객체 window의 document 프로퍼티에 바인딩되어 있는 하나의 document 객체를 바라본다. 즉, HTML 문서 당 document 객체는 유일하다.문서 노드, 즉 document 객체는 DOM 트리의 루트 노드이므로 DOM 트리의 노드들에 접근하기 위한 진입점(entry point) 역할을 담당한다. 즉, 요소, 어트리뷰트, 텍스트 노드에 접근하려면 문서 노드를 통해야 한다.</p>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>요소 노드</strong></p>
<p>요소 노드(element node)는 HTML 요소를 가리키는 객체이다. 요소 노드는 HTML 요소 간의 중첩에 의해 부자 관계를 가지며 이 부자 관계를 통해 정보를 구조화한다. 따라서 요소 노드는 문서의 구조를 표현한다고 할 수 있다.</p>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>어트리뷰트 노드</strong></p>
<p>어트리뷰트 노드(attribute node)는 HTML 요소의 어트리뷰트를 가리키는 객체이다. 어트리뷰트 노드는 어트리뷰트가 지정된 HTML 요소의 요소 노드와 형제(sibling) 관계를 갖는다. 따라서 요소 노드에 접근하면 어트리뷰트 노드에 접근하여 어트리뷰트를 참조하거나 변경할 수 있다.</p>
</li>
</ul>
</li>
<li><ul>
<li><p><strong>텍스트 노드</strong></p>
<p>텍스트 노드(text node)는 HTML 요소의 텍스트를 가리키는 객체이다. 텍스트 노드는 요소 노드의 자식 노드이며 자신의 자식 노드를 가질 수 없는 리프 노드(leaf node)이다. 즉, 텍스트 노드는 DOM 트리의 최종단이다. 요소 노드가 문서의 구조를 표현한다면 텍스트 노드는 문서의 정보를 표현한다고 할 수 있다.</p>
</li>
</ul>
</li>
</ul>
<p>위 4가지 노드 타입 이외에도 주석을 위한 Comment 노드, DOCTYPE을 위한 DocumentType 노드, 복수의 노드를 생성하여 추가할 때 사용하는 DocumentFragment 노드 등 총 12개의 타입이 있다. </p>
<p><strong>노드 객체로 자바스트립트의 객체이므로 프로토타입에 의한 상속에 으한 상속구조를 가진다.</strong> </p>
<p><img src="https://poiemaweb.com/assets/fs-images/39-4.png" alt="39-4"></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// input 요소 노드 객체를 선택</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $input = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// input 요소 노드 객체의 프로토타입 체인</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(</span></span><br><span class="line"><span class="javascript">      <span class="built_in">Object</span>.getPrototypeOf($input) === HTMLInputElement.prototype,</span></span><br><span class="line"><span class="javascript">      <span class="built_in">Object</span>.getPrototypeOf(HTMLInputElement.prototype) === HTMLElement.prototype,</span></span><br><span class="line"><span class="javascript">      <span class="built_in">Object</span>.getPrototypeOf(HTMLElement.prototype) === Element.prototype,</span></span><br><span class="line"><span class="javascript">      <span class="built_in">Object</span>.getPrototypeOf(Element.prototype) === Node.prototype,</span></span><br><span class="line"><span class="javascript">      <span class="built_in">Object</span>.getPrototypeOf(Node.prototype) === EventTarget.prototype,</span></span><br><span class="line"><span class="javascript">      <span class="built_in">Object</span>.getPrototypeOf(EventTarget.prototype) === <span class="built_in">Object</span>.prototype</span></span><br><span class="line"><span class="javascript">    ); <span class="comment">// 모두 true</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>배열이 객체인 동시에 배열인 것 처럼 input요소의 노도 객체도 다양한 특성을 갖는 객체이다. 이러한 특성을 나타내는 기능을 상속 관계를 통해 구분하여 제공한다. </p>
<table>
<thead>
<tr>
<th align="left">input 요소 노드 객체의 특성</th>
<th align="left">프로토타입을 제공하는 객체</th>
</tr>
</thead>
<tbody><tr>
<td align="left">객체</td>
<td align="left">Object</td>
</tr>
<tr>
<td align="left">이벤트를 발생시키는 객체</td>
<td align="left">EventTarget</td>
</tr>
<tr>
<td align="left">트리 자료 구조의 노드 객체</td>
<td align="left">Node</td>
</tr>
<tr>
<td align="left">브라우저가 렌더링할 수 있는 웹 문서의 요소(HTML, XML, SVG)를 표현하는 객체</td>
<td align="left">Element</td>
</tr>
<tr>
<td align="left">웹 문서의 요소 중에서 HTML 요소를 표현하는 객체</td>
<td align="left">HTMLElement</td>
</tr>
<tr>
<td align="left">HTML 요소 중에서 input 요소를 표현하는 객체</td>
<td align="left">HTMLInputElement</td>
</tr>
</tbody></table>
<p>Object.prototype.toString 메서드를 호출하여 프로토 타입을 확인 할 수도 있다. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//input요소 노드객체를 선택</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $input = <span class="built_in">document</span>.querySelector(<span class="string">'input'</span>);</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//input 요소 노드 객체의 프로토 타입 확인</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($input.toString())<span class="comment">//[object HTMLInputElement];</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//well-known symbol인 Sumbol.toStringTag은 toString 메서드이 반환하는 </span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//객체 설명 디폴드 문자열의 적성에 사용되는 문자열이다. </span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($input[<span class="built_in">Symbol</span>.toStringTag])<span class="comment">//HTMLInputElement;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>노드 객체는 공통적인 기능도 있지만 노드 객체의 종류에 따라 고유한 기능도 갖는다. 예를 들어, 모든 노드 객체는 공통적으로 이벤트를 발생시킨다. 이벤트에 관련된 기능(EventTarget.addEventListener, EventTarget.removeEventListener 등)은 <a href="https://developer.mozilla.org/ko/docs/Web/API/EventTarget" target="_blank" rel="noopener">EventTarget 인터페이스</a>가 제공한다.</p>
<p>또한 모든 노드 객체는 트리 자료 구조의 노드로서 공통적으로 트리 탐색 기능(Node.parentNode, Node.childNodes, Node.previousSibling, Node.nextSibling 등)이나 노드 정보 제공 기능(Node.nodeType, Node.nodeName 등)이 필요하다. 이같은 노드 관련 기능은 <a href="https://developer.mozilla.org/ko/docs/Web/API/Node" target="_blank" rel="noopener">Node 인터페이스</a>가 제공한다.</p>
<p>HTML 요소가 객체화된 요소 노드 객체는 HTML 요소가 갖는 공통적인 기능도 있다. 예를 들어 input 요소 노드 객체와 div 요소 노드 객체는 모두 HTML 요소의 스타일을 나타내는 style 프로퍼티가 있다. 이같이 HTML 요소가 갖는 공통적인 기능은 <a href="https://developer.mozilla.org/ko/docs/Web/API/HTMLElement" target="_blank" rel="noopener">HTMLElement 인터페이스</a>가 제공한다.</p>
<p>하지만 요소 노드 객체는 HTML 요소의 종류에 따라 고유한 기능도 있다. 예를 들어 input 요소 노드 객체는 value 프로퍼티가 필요하지만 div 요소 노드 객체는 value 프로퍼티가 필요하지 않다. 따라서 필요한 기능을 제공하는 인터페이스(HTMLInputElement, HTMLDivElement 등)가 HTML 요소의 종류에 따라 각각 다르다.</p>
<p>이처럼 노드 객체는 공통된 기능일수록 프로토타입 체인의 상위에, 개별적인 고유 기능일수록 프로토타입 체인의 하위에 프로토타입 체인을 구축하여 노드 객체에 필요한 기능, 즉 프로퍼티와 메서드를 제공하는 상속 구조를 갖는다.</p>
<p>이와 같이 <strong>DOM은 HTML 문서의 계층적 구조와 정보를 표현하는 것은 물론 노드 객체의 종류에 따라 상속을 통해 자신에 필요한 기능, 즉 프로퍼티와 메서드의 집합인 DOM API(Application Programming Interface)를 제공한다. DOM API를 통해 HTML의 구조나 내용 또는 스타일 등을 동적으로 조작할 수 있다.</strong></p>
<p>DOM API를 사용하기 위해 지금까지 살펴본 노드 객체의 상속 구조를 자세히 알아야 할 필요는 없다. 상속 구조를 모른다 하더라도 노드 객체는 상속을 통해 마치 자신의 프로퍼티와 메서드처럼 DOM API를 사용할 수 있다.</p>
<p>중요한 것은 DOM API 즉, DOM이 제공하는 프로퍼티와 메서드를 사용하여 노드에 접근하고 HTML의 구조나 내용 또는 스타일 등을 동적으로 변경하는 방법을 익히는 것이다. 프런트엔드 개발자에게 HTML이란 단순히 미리 정의되어 있는 태그와 어트리뷰트를 선언적으로 배치하여 뷰를 구성하는 것 이상의 의미를 갖는다. 즉, HTML을 DOM과 연관지어 바라보아야 한다.</p>
<h2 id="id이용한-요소-노드의-취득"><a href="#id이용한-요소-노드의-취득" class="headerlink" title="id이용한 요소 노드의 취득"></a>id이용한 요소 노드의 취득</h2><p><strong>Document.prototype.getElementById</strong> 메소드는 인수로 전달한 id 어트리뷰트 값(id 값)을 갖는 하나의 요소 노드를 탐색하여 반환한다.getElementById 메서드는 Document.prototype의 프로퍼티이다 .따라서 반드시 문서 노드 document를 통해 호출해야한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">     <span class="comment">//id값이 'banana'인 요소 노드를 탐색하여 반환</span></span></span><br><span class="line"><span class="javascript">     <span class="comment">//두번째 li요소가 파싱되어 생성된 요소 노드가 반환</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $elem = <span class="built_in">document</span>.getElemetById(<span class="string">'banana'</span>);</span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="comment">//취득한 요소 노드의 style.color 프로터피 값을 변경</span></span></span><br><span class="line"><span class="javascript">      $elem.style.color =<span class="string">'red'</span>;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>id 값은 html문서 내에서 유일한 값이어야하며 class 어틍리뷰트와는 달리 공백 문자와 구분하여 여러 개의 값을 가질 수 없다 .단 HTML문서 내에  중복된 id 값을 갖는 요소가 여러개 존재 하더라도 어떠한 에러도 발생하지 않는다. 즉 HTML 문서내에는 중복된 id 값을 갖는 요소가 여러개 존재 할 가능성이 있다. 이러한 경우,getElementById 메서드는 인수로 전달된 id값을 갖는 첫번째 요소 노드만을 반환한다. 즉 getElementById 메소드는 언제난 단하나의 요소노드를 반환한다. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"banana"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"banana"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// id 값이 'banana'인 요소 노드를 탐색하여 반환한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 첫번째 li 요소가 파싱되어 생성된 요소 노드가 반환된다.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $elem = <span class="built_in">document</span>.getElementById(<span class="string">'banana'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 취득한 요소 노드의 style.color 프로퍼티 값을 변경한다.</span></span></span><br><span class="line"><span class="javascript">      $elem.style.color = <span class="string">'red'</span>;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>만약 인수로 전달된 id값을 갖는 요소가 존재하지 않는경우 ,getElemnetById는 null을 반환한다. </p>
<p>HTML요소에 id 어트리뷰트를 부여하면 id 값과 동일한 이름 의 전역 변수가 암묵적으로 선언되고 해당 노드의 객체가 할당되는 부수 효과가 있다. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">foo</span>""&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">     <span class="comment">//id 값과 동일한 이름의 전역 변수가 암묵적으로 선언되고 해당 노드 객체가 할당된다.</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(foo === <span class="built_in">document</span>.getElemetById(<span class="string">'foo'</span>)) <span class="comment">//true;</span></span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="comment">//암묵적으로 전역에 생성된 전역 프로퍼티는 삭제되지만 전역변수는 삭제되지않는다. </span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">delete</span> foo;</span></span><br><span class="line"><span class="xml">      console.log(foo) // <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>단, id 값과 동일한 이름의 전역변수가 이미 선언 되어있다면 이 전역 변수에 노드 객체가 할당되지 않는다. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> foo = <span class="number">1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// id 값과 동일한 이름의 전역 변수가 이미 선언되어 있으면 노드 객체가 재할당되지 않는다.</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(foo); <span class="comment">// 1</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="태그-이름을-이용한-요소-노드-취득"><a href="#태그-이름을-이용한-요소-노드-취득" class="headerlink" title="태그 이름을 이용한 요소 노드 취득"></a>태그 이름을 이용한 요소 노드 취득</h2><p><strong>Document.prototype/Element.prototype.getElementBytagName</strong> 메소드는 인수로 전달한 태그 이름을 갖는 모든 요소 노드들을 탐색하여 반환한다. 메서드 이름에 포함된  Elemenents 가 복수형인 것엥서 알 수 있듯이 getElemenetsByTagName 메서드는 여러개의 요소 노드 객체를 갖는 객체를 DOM 컬렉션 객체인 HTMLCollection 객체를 반환한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 태그 이름이 li인 요소 노드를 모두 탐색하여 반환한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 탐색된 요소 노드 들은 HTMLCollection 객체에 담겨 반환된다.</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// HTMLCollection 객체는 유사 배열 객체이며 이터러블이다.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $elems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 취득한 모든 요소 노드의 style.color 프로퍼티 값을 변경한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// HTMLCollection 객체를 배열로 변환하여 순회하며 color 프로퍼티 값을 변경한다.</span></span></span><br><span class="line"><span class="javascript">		[...$elem].foEach(<span class="function"><span class="params">elem</span>=&gt;</span>elem.style.color=<span class="string">"red"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>함수는 하나의 값만을 반환 할 수 있으므로 여러개의 값을 반환하려면 배열이나 객체와 같은 자료 구조에 담아야 한다. getElemenetsbyTagName 메서드가 반환하는 DOM 컬렉션 객체인 HTMLCollection  객체는 유사배열 객체이자 이터러블이다. </p>
<p>getElementsByTagName 메서드는 Document.prototype에 정의된 메서드와 Element.prototype에 정의된 메서드가 있다. Document.prototype.getElementsByTagName 메서드는 DOM의 루트 노드인 문서 노드 즉, document를 통해 호출하며 HTML 문서 전체에서 요소 노드를 탐색하여 반환한다. Element.prototype.getElementsByTagName 메서드는 특정 요소 노드를 통해 호출하며 특정 요소 노드부터 시작하여 요소 노드를 탐색하여 반환한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>HTML<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// HTML 문서 전체에서 태그 이름이 li인 요소 노드를 모두 탐색하여 반환한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $lisFromDcoument = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'li'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// ul#fruits 요소부터 시작하여 태그 이름이 li인 요소 노드를 모두 탐색하여 반환한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $fruits = <span class="built_in">document</span>.getElementById(<span class="string">'fruits'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $lisFromFruits = $fruits.getElementsByTagName(<span class="string">'li'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log($lisFromDcoument); <span class="comment">// HTMLCollection(4) [li, li, li, li]</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log($lisFromFruits);   <span class="comment">// HTMLCollection(3) [li, li, li]</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>만역 인수로 전달된 태그 이름을 갖는 요소가 존재하지 않는 경우,getElementsByTagName 메소드는 빈 HTMLCollection을 반환한다.</p>
<h2 id="class을-이용한-요소의-취득"><a href="#class을-이용한-요소의-취득" class="headerlink" title="class을 이용한 요소의 취득"></a>class을 이용한 요소의 취득</h2><p><strong>Document.prototype/Element.prototype.getElementsByClassName</strong> 메서드는 인수로 전달된 class 어트리뷰트값(class값)을 갖는 모든 요소 노드들을 탐색하여 반환. 인수로 전달할 class 값은 공백으로 구분하여 여러 개의 class 를 지정 할 수 있다. getElementdbytagN</p>
<p>getElementsByTagName 메서드와 마찬가지로 getElementsByClassName 메서드는 여러 개의 요소 노드 객체를 갖는 DOM 컬렉션 객체인 HTMLCollection 객체를 반환한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"fruit apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"fruit banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"fruit orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $elem = <span class="built_in">document</span>.getElementByClassName(<span class="string">'fruit'</span>);</span></span><br><span class="line"><span class="javascript">      [...elem].forEach(<span class="function"><span class="params">elem</span>=&gt;</span>elem.style.color=<span class="string">"red"</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $apples = <span class="built_in">document</span>.getElememtsByClassName(<span class="string">'fruit apple'</span>);</span></span><br><span class="line">      </span><br><span class="line"><span class="javascript">      [...$apples].forEach(<span class="function"><span class="params">apple</span>=&gt;</span>apple.style.color=<span class="string">"blue"</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>getElementsByTagName 메서드와 마찬가지로 getElementsByClassName 메서드는 Document.prototype에 정의된 메서드와 Element.prototype에 정의된 메서드가 있다. Document.prototype.getElementsByClassName 메서드는 DOM의 루트 노드인 문서 노드 즉, document를 통해 호출하며 HTML 문서 전체에서 요소 노드를 탐색하여 반환하고 Element.prototype.getElementsByClassName 메서드는 특정 요소 노드를 통해 호출하며 특정 요소 노드부터 시작하여 요소 노드를 탐색하여 반환한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// HTML 문서 전체에서 class 값이 'banana'인 요소 노드를 모두 탐색하여 반환한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $bananasFromDcoument = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'banana'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// ul#fruits 요소부터 시작하여 class 값이 'banana'인</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 요소 노드를 모두 탐색하여 반환한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $fruits = <span class="built_in">document</span>.getElementById(<span class="string">'fruits'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $bananasFromFruits = $fruits.getElementsByClassName(<span class="string">'banana'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log($bananasFromDcoument); <span class="comment">// HTMLCollection(2) [li.banana, div.banana]</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log($bananasFromFruits);   <span class="comment">// HTMLCollection [li.banana]</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>인수로 전달된 class 값을 요소가 존재 하지않는 경우, getElementsByClassName 메서드는 빈 HTMLCollection 객체를 반환 </p>
<h2 id="CSS-선택자를-이용한-요소의-취득"><a href="#CSS-선택자를-이용한-요소의-취득" class="headerlink" title="CSS 선택자를 이용한 요소의 취득"></a>CSS 선택자를 이용한 요소의 취득</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 전체 선택자: 모든 요소를 선택 */</span></span><br><span class="line">* &#123; ... &#125;</span><br><span class="line"><span class="comment">/* 태그 선택자: 모든 p 태그 요소를 모두 선택 */</span></span><br><span class="line">p &#123; ... &#125;</span><br><span class="line"><span class="comment">/* id 선택자: id 값이 foo인 요소를 모두 선택 */</span></span><br><span class="line">#foo &#123; ... &#125;</span><br><span class="line"><span class="comment">/* class 선택자: class 값이 foo인 요소를 모두 선택 */</span></span><br><span class="line">.foo &#123; ... &#125;</span><br><span class="line"><span class="comment">/* 어트리뷰트 선택자: input 요소 중에 type 어트리뷰트 값이 text인 요소를 모두 선택 */</span></span><br><span class="line">input[type=text] &#123; ... &#125;</span><br><span class="line"><span class="comment">/* 후손 선택자: div 요소의 후손 요소 중 p 요소를 모두 선택 */</span></span><br><span class="line">div p &#123; ... &#125;</span><br><span class="line"><span class="comment">/* 자식 선택자: div 요소의 자식 요소 중 p 요소를 모두 선택 */</span></span><br><span class="line">div &gt; p &#123; ... &#125;</span><br><span class="line"><span class="comment">/* 인접 형제 선택자: p 요소의 형제 요소 중에 p 요소 바로 뒤에 위치하는 ul 요소를 선택 */</span></span><br><span class="line">p + ul &#123; ... &#125;</span><br><span class="line"><span class="comment">/* 일반 형제 선택자: p 요소의 형제 요소 중에 p 요소 뒤에 위치하는 ul 요소를 모두 선택 */</span></span><br><span class="line">p ~ ul &#123; ... &#125;</span><br><span class="line"><span class="comment">/* 가상 클래스 선택자: hover 상태인 a 요소를 모두 선택 */</span></span><br><span class="line">a:hover &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Document.prototype/Element.prototype.querySelector</strong> 메서드는 인수로 전달한 css 선택자를 만족시키는 요소 노드가 여러 개인 경우, 첫번째 요소 노드만 반환한다. .인수로 전달된 CSS 선택자를 만족 시키지 않는 경우,null 반환</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// class 어트리뷰트 값이 'banana'인 첫번째 요소 노드를 탐색하여 반환한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $elem = <span class="built_in">document</span>.querySelector(<span class="string">'.banana'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 취득한 요소 노드의 style.color 프로퍼티 값을 변경한다.</span></span></span><br><span class="line"><span class="javascript">      $elem.style.color = <span class="string">'red'</span>;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Document.prototype/Element.prototype.querySelectorAll</strong>  메서드는 인수로 전달한 css 선택자를 만족시키는  모든 요소를 탐색하여 반환한다. querySelecotAll 메서드는 여러 개의 요소 노드 객체를 갖는 DOM컬렉션 객체인 NodeList 객체를 반환한다. 인수로 전달된 css 선택자를 만족시키는 요소가 존재하지 않는 경우 , 빈 NodeList 객체를 반환한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// ul 요소의 자식 요소인 li 요소를 모두 탐색하여 반환한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $elems = <span class="built_in">document</span>.querySelectorAll(<span class="string">'ul &gt; li'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 취득한 요소 노드 들은 NodeList 객체에 담겨 반환된다.</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log($elems); <span class="comment">// NodeList(3) [li.apple, li.banana, li.orange]</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 취득한 모든 요소 노드의 style.color 프로퍼티 값을 변경한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// NodeList는 forEach 메서드를 제공한다.</span></span></span><br><span class="line"><span class="javascript">      $elems.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> elem.style.color = <span class="string">'red'</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>인수로 전달한 css 선택자가 문법에 맞지않는 경우,DomException 에러가 발생한다.</p>
<p>getElementsByTagName, getElementsByClassName 메서드와 마찬가지로 querySelector, querySelectorAll 메서드는 Document.prototype에 정의된 메서드와 Element.prototype에 정의된 메서드가 있다. Document.prototype에 정의된 메서드는 DOM의 루트 노드인 문서 노드 즉, document 를 통해 호출하며 HTML 문서 전체에서 요소 노드를 탐색하여 반환한다. Element.prototype에 정의된 메서드는 특정 요소 노드를 통해 호출하며 특정 요소 노드부터 시작하여 요소 노드를 탐색하여 반환한다.</p>
<p>CSS 선택자 문법을 사용하는 querySelector, querySelectorAll 메서드는 getElementById, getElementsBy*** 메서드보다 다소 느린 것으로 알려져 있다. 하지만 CSS 선택자 문법으로 보다 구체적인 조건으로 요소 노드를 취득할 수 있고 일관된 방식으로 요소 노드를 취득할 수 있다는 장점이 있다. 따라서 id가 있는 요소를 취득하는 경우에는 getElementById 메서드를 사용하고 그 외의 경우에는 querySelector, querySelectorAll 메서드를 사용하는 것을 추천한다.</p>
<h2 id="요소-노드의-취득-가능-여부-확인"><a href="#요소-노드의-취득-가능-여부-확인" class="headerlink" title="요소 노드의 취득 가능 여부 확인"></a>요소 노드의 취득 가능 여부 확인</h2><p>Element.prototype.matches 메소드는 인수로 전달된 선택자에 특정 요소 노드를 탐색 가능한지 확인한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $elem = <span class="built_in">document</span>.querySelector(<span class="string">'.apple'</span>);</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($apple.matches(<span class="string">'#fruits &gt; li.apple'</span>));  <span class="comment">// true</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($apple.matches(<span class="string">'#fruits &gt; li.banana'</span>)); <span class="comment">// false</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Element.prototype.matches 메서드는 이벤트 위임을 사용할 때 유용하다. </p>
<h2 id="HTMLCollection과-NodeList"><a href="#HTMLCollection과-NodeList" class="headerlink" title="HTMLCollection과  NodeList"></a>HTMLCollection과  NodeList</h2><p>HTMLCollection과 NodeList는 DOM API가 여러 개의 결과값을 반환하기 위한 DOM 컬렉션 객체이다. HTMLCollection과 NodeList는 모두 유사 배열 객체이자 이터러블이다. 따라서 for…of 문으로 순회할 수 있으며 <a href="https://poiemaweb.com/fastcampus/spread-syntax" target="_blank" rel="noopener">스프레드 문법</a>을 사용하여 간단히 배열로 변환할 수 있다.</p>
<p>HTMLCollection과 NodeList의 중요한 특징은 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는(live) 객체라는 것이다. HTMLCollection은 언제나 live 객체로 동작한다. 단, NodeList는 대부분의 경우 노드 객체의 상태 변화를 실시간으로 반영하지 않고 과거의 정적 상태를 유지하는 non-live 객체로 동작하지만 경우에 따라 live 객체로 동작할 때가 있다.</p>
<h3 id="HTMLCollection"><a href="#HTMLCollection" class="headerlink" title="HTMLCollection"></a>HTMLCollection</h3><p>getElementsByTagName, getElementsByClassName 메서드가 반환하는 HTMLCollection 객체는 노드 객체의 상태 변화를 실시간으로 반영하는 살아 있는(live) DOM 컬렉션 객체이다. 따라서 HTMLCollection 객체를 살아 있는(live) 객체라고 부르기도 한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.red</span>&#123;<span class="attribute">color</span>:red;&#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.blue</span>&#123;<span class="attribute">color</span>:blue;&#125;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"red"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// class 값이 'red'인 요소 노드를 모두 탐색하여 반환한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 탐색된 요소 노드 들은 HTMLCollection 객체에 담겨 반환된다.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> $elems = <span class="built_in">document</span>.getElementsByClassName(<span class="string">'red'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="comment">// HTMLCollection 객체에는 3개의 요소가 담겨 있다.</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log($elems); <span class="comment">// HTMLCollection(3) [li.red, li.red, li.red]</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// HTMLCollection 객체의 모든 요소의 class 값을 'blue'로 변경한다.</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; $elems.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">        $elems[i].className = <span class="string">'blue'</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// HTMLCollection 객체의 요소가 3개에서 1개로 변경되었다.</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log($elems); <span class="comment">// HTMLCollection(1) [li.red]</span></span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>위 예제는 getElementsByClassName 메서드로 class 값이 ‘red’인 요소 노드를 모두 취득하고, 취득된 모든 요소를 담고 있는 HTMLCollection 객체를 for 문으로 순회하며 모든 요소의 class 값을 ‘red’에서 ‘blue’로 변경한다.</p>
<p>따라서 위 예제가 에러없이 실행되면 모든 li 요소의 class 값이 ‘blue’로 변경되고 CSS에 의해 파란색으로 렌더링될 것이다. 하지만 위 예제를 실행해 보면 예상대로 동작하지 않는다. 두번째 li 요소만 class 값이 변경되지 않는다.</p>
<p>위 예제가 예상대로 동작하지 않은 이유를 알아보자. $elems.length는 3이므로 for 문의 코드 블록은 3번 반복된다.</p>
<p><strong>1. 첫번째 반복 (i === 0)</strong></p>
<p>$elems[0]은 첫번째 li 요소이다. 이 요소는 className 프로퍼티에 의해 class 값이 red에서 blue로 변경된다. 이때 class 값이 ‘red’에서 ‘blue’로 변경되었으므로 getElementsByClassName 메서드의 인자로 전달한 ‘red’와 더이상 일치하지 않으므로 $elems에서 실시간으로 제거된다. 이처럼 HTMLCollection 객체는 실시간으로 노드 객체의 상태 변경을 반영하는 살아 있는(live) DOM 컬렉션 객체이다.</p>
<p><strong>2. 두번째 반복 (i === 1)</strong></p>
<p>$elems에서 첫번째 요소는 제거되었으므로 $elems[1]은 세번째 li 요소이다. 이 세번째 li 요소의 class 값도 ‘blue’로 변경되고 마찬가지로 HTMLCollection 객체인 $elems에서 실시간으로 제외된다.</p>
<p><strong>3. 세번째 반복 (i === 2)</strong></p>
<p>HTMLCollection 객체인 $elems에서 첫번째, 세번째 li 요소가 실시간으로 제거되었으므로 $elems에는 두번째 li 요소 노드만 남았다. 이때 $elems.length는 1이므로 for 문의 조건식 i &lt; $elems.length가 false로 평가되어 반복을 종료한다. 따라서 $elems에 남아 있는 두번째 li 요소의 class 값은 변경되지 않는다.</p>
<p>이처럼 HTMLCollection은 실시간으로 노드 객체의 상태 변경을 반영하기 때문에 HTMLCollection 객체를 for 문으로 순회하면서 노드 객체의 상태를 변경해야 할 때 주의가 필요하다. 이 문제는 for 문을 역방향으로 순회하는 방법으로 회피할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for문의 역방향으로 순회</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i =$elem.length<span class="number">-1</span>;i&gt;=;i++)&#123;</span><br><span class="line">  $elem[i].className = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>또는 while문을 사용하여 HTMLCollection에 노드 객체가 남아 있지 않을때 까지 무한반복을 하는 방법으로 회피 가능</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//while문으로 HTMLColleciton에 요소가 남아있지 않을때 까지 무한 반복</span></span><br><span class="line"><span class="keyword">let</span> i =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>($elem.length &gt;i)&#123;</span><br><span class="line">  $elem[i].className = <span class="string">'blue'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>보다 간단한 해결책은 부작용을 발생 시키는 원인인 HTMLCollection을 사용하지않는것이다.유사 배열 객체 이면서 이터러블인 HTMLColleciton을 배열로 변환하면 더 이상 HTMLColleciton을 사용할 필요가 없고 유용하나 배열의 고차함수를 사용할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//유사 배열 객체이면서 이터러블인 HTMLCollection을 배열로 변환하여 순회</span></span><br><span class="line">[...$elem].forEach(<span class="function"><span class="params">elem</span> =&gt;</span> elem.className = <span class="string">'blue'</span>);</span><br></pre></td></tr></table></figure>

<h3 id="NodeList"><a href="#NodeList" class="headerlink" title="NodeList"></a>NodeList</h3><p>또는 querySelectorAll 메서드를 사용하는 방법도 있다.querySelectorAll 메서드는  DOM컬렉션 객체인  NodeList을 반환한다. 이때 NodeList 객체는 실시간으로 노드 객체의 상태 변경을 반영하지 않는 non-live객체 이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//querySelectorAll은 DOM 컬렉션 객체인 NodeList를 반환한다.</span></span><br><span class="line"><span class="keyword">const</span> $elem = <span class="built_in">document</span>.querySelectorAll(<span class="string">'.red'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//querySelrctorAll가 반환하는 노드 객체는</span></span><br><span class="line"><span class="comment">//NodeList.porototype.forEach 메서드를 상속 받아 사용할 수 있다. </span></span><br><span class="line">$elem.forEach(<span class="function"><span class="params">elem</span> =&gt;</span>elem.className =<span class="string">"blue"</span>);</span><br></pre></td></tr></table></figure>

<p>querySelectorAll가 반환하는 노드 객체는 NodeList.prototype.forEach 메서드를 상속받아 사용할 수 있다. NodeList.prototype.forEach 메서드는 Array.prototype.forEach 메서드와 사용 방법이 동일하다. NodeList.prototype은 forEach 이외에도 item, entries, keys, values 메서드를 제공한다.</p>
<p>NodeList 객체는 대부분의 경우, 노드 객체의 상태 변경을 실시간으로 반영하지 않고 과거의 정적 상태를 유지하는 non-live 객체로 동작한다. 하지만 경우에 따라 HTMLCollection과 같이 실시간으로 노드 객체의 상태 변경을 반영하는 live 객체로 동작할 때가 있다. childNodes 프로퍼티가 반환한 NodeList 객체는 live 객체로 동작하므로 주의가 필요하다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $fruit = <span class="built_in">document</span>.getElementById(<span class="string">'fruits'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// childNodes 프로퍼티는 NodeList 객체(live)를 반환한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123; childNodes &#125; = $fruits;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(childNodes <span class="keyword">instanceof</span> NodeList); <span class="comment">// true</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// $fruits 요소의 자식 노드는 5개이다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(childNodes); <span class="comment">// NodeList(5) [text, li, text, li, text]</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childNodes.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// $fruits 요소의 모든 자식 노드를 DOM에서 삭제 ("39.6.9. 노드 삭제" 참고)</span></span></span><br><span class="line"><span class="javascript">      $fruits.removeChild(childNodes[i]); <span class="comment">// 첫번째, 세번째 다섯번째만 삭제된다.</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 예상대로 $fruits 요소의 모든 자식 노드가 삭제되지 않는다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(childNodes); <span class="comment">// NodeList(2) [li, li]</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>따라서 <strong>노드 객체의 상태 변경과 상관없이 안전하게 DOM 컬렉션을 사용하려면 HTMLCollection이나 NodeList 객체를 배열로 변환하여 사용하는 것을 추천한다.</strong> </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $fruits = <span class="built_in">document</span>.getElementById(<span class="string">'fruits'</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// childNodes 프로퍼티는 NodeList 객체(live)를 반환한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123; childNodes &#125; = $fruits;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(childNodes <span class="keyword">instanceof</span> NodeList); <span class="comment">// true</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// $fruits 요소의 자식 노드는 5개이다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(childNodes); <span class="comment">// NodeList(5) [text, li, text, li, text]</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// NodeList 객체를 배열로 변환</span></span></span><br><span class="line"><span class="javascript">    [...childNodes].forEach(<span class="function"><span class="params">childNode</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// $fruits 요소의 모든 자식 노드를 DOM에서 삭제 ("30.8.9 노드 삭제" 참고)</span></span></span><br><span class="line">      $fruits.removeChild(childNode);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// $fruits 요소의 모든 자식 노드가 모두 삭제되었다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(childNodes); <span class="comment">// NodeList []</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="노드-탐색"><a href="#노드-탐색" class="headerlink" title="노드 탐색"></a>노드 탐색</h2><p>요소 노드를 취득한 다음, 취득하나 요소 노드를 기점으로  DOM트리의 토드를 옮겨다니면 부모,형제,자식을 탐색 해야할 때가 있다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>ul#fruits 요소는 3개의 자식 요소를 갖는다. 이때 먼저 ul#fruits 요소 노드를 취득한 다음, 자식 노드를 모두 탐색하거나 첫번째 자식 노드 또는 마지막 자식 노드 만을 탐색할 수 있다.</p>
<p>li.banana 요소는 2개의 형제 요소와 부모 요소를 갖는다. 이때 먼저 li.banana 요소 노드를 취득한 다음, 형제 노드를 탐색하거나 부모 노드를 탐색할 수 있다.</p>
<p>이처럼 DOM 트리 상의 노드를 탐색할 수 있도록 Node, Element 인터페이스는 트리 탐색 프로퍼티를 제공한다.</p>
<p>DOM 트리를 구성하는 노드로서 갖추어야 할 트리 노드 탐색을 위한 프로퍼티인 parentNode, previousSlibling, firstChild, childNodes 등은 Node.prototype이 제공하고 프로퍼티 키에 Element가 포함된 previousElementSlibling, nextElementSlibling과 children은 Element.prototype이 제공하는 프로퍼티이다.</p>
<p>노드 탐색 프로퍼티는 모두 <a href="https://poiemaweb.com/fastcampus/property-definition#32-접근자-프로퍼티" target="_blank" rel="noopener">접근자 프로퍼티</a>이다. 단, setter없이 getter만 존재하여 참조만 가능한 읽기 전용 프로퍼티이다. 읽기 전용 접근자 프로퍼티에 값을 할당하면 아무런 에러없이 무시된다.</p>
<h2 id="공백-텍스트-노드"><a href="#공백-텍스트-노드" class="headerlink" title="공백 텍스트 노드"></a>공백 텍스트 노드</h2><p>HTML 요소 사이의 개행이나 공백은 텍스트 노드를 생성한다. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>HTML문서에 엔터 키를 입력하면 개행 문자가 추가된다. 개행이나 공백은 텍스트노드를 생성한다. 따라ㅓㅅ 토드 탐색시에는 개행이나 공백 문자가 생ㅅ어한 텍스트 노드에 주의해야한다.  인위적으로 개행이나 공백을 제거하면 공백텍스트 노드를 생성하지 않는다. 하지만 가독성이 좋지 않아진다. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="자식-노드-탐색"><a href="#자식-노드-탐색" class="headerlink" title="자식 노드 탐색"></a>자식 노드 탐색</h2><p>자식 노드를 탐색하기 위해 다음의 노드 탐색 프로퍼티를 사용한다. </p>
<table>
<thead>
<tr>
<th align="left">프로퍼티</th>
<th align="left">설명</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Node.prototype.childNodes</td>
<td align="left">자식 노드를 모두 탐색하여 DOM 컬렉션 객체인 NodeList에 담아 반환한다. <strong>childNodes 프로퍼티가 반환한 NodeList에는 텍스트 노드 또는 요소 노드가 포함되어 있다.</strong></td>
</tr>
<tr>
<td align="left">Element.prototype.children</td>
<td align="left">자식 요소 노드 만을 모두 탐색하여 DOM 컬렉션 객체인 HTMLCollection에 담아 반환한다. <strong>children 프로퍼티가 반환한 HTMLCollection에는 텍스트 노드는 포함되지 않고 요소 노드만이 포함되어 있다.</strong></td>
</tr>
<tr>
<td align="left">Node.prototype.firstChild</td>
<td align="left">첫번째 자식 노드를 반환한다. firstChild 프로퍼티가 반환한 노드는 텍스트 노드 또는 요소 노드이다.</td>
</tr>
<tr>
<td align="left">Node.prototype.lastChild</td>
<td align="left">마지막 자식 노드를 반환한다. lastChild 프로퍼티가 반환한 노드는 텍스트 노드 또는 요소 노드이다.</td>
</tr>
<tr>
<td align="left">Element.prototype.firstElementChild</td>
<td align="left">첫번째 자식 노드를 반환한다. firstElementChild 프로퍼티는 요소 노드 만을 반환한다.</td>
</tr>
<tr>
<td align="left">Element.prototype.lastElementChild</td>
<td align="left">마지막 자식 노드를 반환한다. lastElementChild 프로퍼티는 요소 노드 만을 반환한다.</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $fruits = <span class="built_in">document</span>.getElementsById(<span class="string">'fruits'</span>);</span></span><br><span class="line"><span class="javascript">  	<span class="comment">// ul#fruits 요소의 모든 자식 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// childNodes가 반환한 NodeList에는 텍스트 노드가 포함되어 있다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($fruits.childNodes);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// NodeList(7) [text, li.apple, text, li.banana, text, li.orange,   text];</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// ul#fruits 요소의 모든 자식 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// children이 반환한 HTMLCollection에는 텍스트 노드가 포함되어 있지 않다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($fruits.children);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// HTMLCollection(3) [li.apple, li.banana, li.orange]</span></span></span><br><span class="line"><span class="javascript">     <span class="comment">// ul#fruits 요소의 첫번째 자식 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 텍스트 노드가 반환된다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($fruits.firstChild); <span class="comment">// #text</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// ul#fruits 요소의 마지막 자식 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 텍스트 노드가 반환된다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($fruits.lastChild); <span class="comment">// #text</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// ul#fruits 요소의 첫번째 자식 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// firstElementChild는 요소 노드 만을 반환한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($fruits.firstElementChild); <span class="comment">// li.apple</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// ul#fruits 요소의 마지막 자식 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// lastElementChild는 요소 노드 만을 반환한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($fruits.lastElementChild); <span class="comment">// li.orange</span></span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="자식-노드의-존재-확인"><a href="#자식-노드의-존재-확인" class="headerlink" title="자식 노드의 존재 확인"></a>자식 노드의 존재 확인</h2><p>자식 노드의 존재 여부는 불리언 값을 반환하는 <strong>Node.prototype.hasChildNode</strong> 메서드로 확인할 수 있다. 단,  hasChildNodes 메서드는 childNodes 프로퍼티와 마찬가지로 텍스트 노드를 포함하여 자식 노드의 존재를 확인 한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="comment">//노드의 탐색의 기점이 되는 요소 노드 취득</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $fruits = <span class="built_in">document</span>.getElementById(<span class="string">'fruits'</span>);</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//ul#fruits 요소의 자식 노드 존재 확인</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//hasChildNodes 메서드는 텍스트 노드를 포함하여 자식 노드의 존재를 확인한다.</span></span></span><br><span class="line"><span class="javascript">     <span class="built_in">console</span>.log($fruits.hasChildNodes()) <span class="comment">//true;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>요소 노드인 자식 노드가 존재하는 지 확인하고 싶은 경우에는 hasChildNodes 메서드 대신에  children.length 또는 Element 인터 페이스의 childElementCount 프로퍼티를 사용한다. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//노드 탐색의 기점이 되는 요소 노드 취득</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $fruists = <span class="built_in">document</span>.getElementById(<span class="string">'fruits'</span>);</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//텍스트 노드를 포함하여 자식 노드 존재 확인 </span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($fruits.hasChildNodes())<span class="comment">// true;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//요소 노드 만을 포함하여 자식 노드 존재 확인</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(!!$fruits.children.length) <span class="comment">//0 -&gt; false;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//요소 노드 만을 포함하여 자식 노드 존재 확인</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(!!$fruits.childrElementCount); <span class="comment">//0 -&gt;false;</span></span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="텍스트-노드-탐색"><a href="#텍스트-노드-탐색" class="headerlink" title="텍스트 노드 탐색"></a>텍스트 노드 탐색</h2><p>요소의 노드의 텍스트 노드는 요소 노드의 자식 노드이다. 따라서 요소 노드의 텍스트 노드는  firstCHild 프로퍼티로 접근 할 수 있다. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">   <span class="comment">//요소 노드의 텍스트는 firstChild 프로펄티로 접근이 가능하다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>).fristhChild)<span class="comment">//#text;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="부모-노드탐색"><a href="#부모-노드탐색" class="headerlink" title="부모 노드탐색"></a>부모 노드탐색</h2><p>부모 노드를 탐색하기 위해 Node.prototype.parentNode 프로퍼티를 사용한다. 텍스트 노드는 DOM 트리의 최종단 노드인 리프 노드이므로 탐색한 부모 노드가 텍스트 노드인 경우는 없다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//노드 탐색의 기접이 되는 요소 노드 취득 </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $ banana = <span class="built_in">document</span>.querySelector(<span class="string">'.banana'</span>);</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//li.banana 요소의 부모 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($banana.parretNode); <span class="comment">// ul#fruits</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="형제-노드의-탐색"><a href="#형제-노드의-탐색" class="headerlink" title="형제 노드의 탐색"></a>형제 노드의 탐색</h2><p>같은 부모 노드를 갖는 형제 노드를 탐색하기 위해서는 아래와 같은 노드 탐색 프로퍼티를 사용한다. 단 , 어트비뷰트 노드는 요소 노드의 형제 노드이지만 같은 부모 노드를 갖는 형제 노드가 아니기 때문에 반환 되지않는다 . 즉 . 아래 프로퍼티는 텍스트 노드 또는 요소 노드만을 반환한다. </p>
<table>
<thead>
<tr>
<th align="left">프로퍼티</th>
<th align="left">설명</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Node.prototype.previousSibling</td>
<td align="left">같은 부모 노드를 갖는 형제 노드에서 이전 형제 노드를 탐색하여 반환한다. 텍스트 노드 또는 요소 노드가 반환된다.</td>
</tr>
<tr>
<td align="left">Node.prototype.nextSibling</td>
<td align="left">같은 부모 노드를 갖는 형제 노드에서 다음 형제 노드를 탐색하여 반환한다. 텍스트 노드 또는 요소 노드가 반환된다.</td>
</tr>
<tr>
<td align="left">Element.prototype.previousElementSibling</td>
<td align="left">같은 부모 노드를 갖는 형제 요소 노드에서 이전 형제 요소 노드를 탐색하여 반환한다. 요소 노드만 반환된다.</td>
</tr>
<tr>
<td align="left">Element.prototype.nextElementSibling</td>
<td align="left">같은 부모 노드를 갖는 형제 요소 노드에서 다음 형제 요소 노드를 탐색하여 반환한다. 요소 노드만 반환된다.</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"fruits"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"apple"</span>&gt;</span>Apple<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"banana"</span>&gt;</span>Banana<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"orange"</span>&gt;</span>Orange<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//노드의 탐색 기점이 되든 요소 취득 </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $fruits = <span class="built_in">document</span>.getElementbyId(<span class="string">'fruits'</span>);</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// ul#fruits 요소의 첫번째 자식 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123;fristChild&#125; = $fruits;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(firstChild) <span class="comment">//#text</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// ul#fruits 요소의 첫번째 자식 노드(텍스트 노드)의 다음 형제 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123; nextSibling &#125; = firstChild;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(nextSibling); <span class="comment">// li.apple</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// li.apple 요소의 이전 형제 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123; previousSibling &#125; = nextSibling;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(previousSibling); <span class="comment">// #text</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// ul#fruits 요소의 첫번째 자식 요소 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123; firstElementChild &#125; = $fruits;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(firstElementChild); <span class="comment">// li.apple</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// ul#fruits 요소의 첫번째 자식 요소 노드(li.apple)의 다음 형제 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123; nextElementSibling &#125; = firstElementChild;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(nextElementSibling); <span class="comment">// li.banana</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">// li.banana 요소의 이전 형제 요소 노드를 탐색한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> &#123; previousElementSibling &#125; = nextElementSibling;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(previousElementSibling); <span class="comment">// li.apple</span></span></span><br><span class="line">    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="노드-정보-취득"><a href="#노드-정보-취득" class="headerlink" title="노드 정보 취득"></a>노드 정보 취득</h2><p> 노드객체에 대한 정보를 확인하여면 아래와 같은 노드 정보 프로터피를 사용한다. </p>
<table>
<thead>
<tr>
<th align="left">프로퍼티</th>
<th align="left">설명</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Node.prototype.nodeType</td>
<td align="left">노드 객체의 종류를 나타내는 상수를 반환한다. 노드 객체의 종류를 나타내는 노드 타입 상수는 Node에 정의되어 있다.요소 노드: 상수 Node.ELEMENT_NODE, 즉 숫자 1을 반환텍스트 노드: 상수 Node.TEXT_NODE, 즉 숫자 3을 반환문서 노드: 상수 Node.DOCUMENT_NODE, 즉 숫자 9를 반환</td>
</tr>
<tr>
<td align="left">Node.prototype.nodeName</td>
<td align="left">노드의 이름을 문자열로 반환한다.요소 노드: 대문자 문자열로 태그 이름(“UL”, “LI” 등)을 반환텍스트 노드: 문자열 “#text”를 반환문서 노드: 문자열 “#document”를 반환</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//문서 노드 정보 </span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.nodeType) <span class="comment">//9;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.nodeName) <span class="comment">//#document;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//요소 노드의 정보 </span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $foo = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($foo.nodeType) <span class="comment">//1</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($foo.nodeName) <span class="comment">//DIV</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//텍스트 노드의 정보</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $textNode = $foo.firstChild;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($textNode.nodeType)<span class="comment">//3;</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($textNode.nodeName)<span class="comment">//#text;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="요소-노드의-텍스트-조작"><a href="#요소-노드의-텍스트-조작" class="headerlink" title="요소 노드의 텍스트 조작"></a>요소 노드의 텍스트 조작</h2><h3 id="nodeValue"><a href="#nodeValue" class="headerlink" title="nodeValue"></a>nodeValue</h3><p>지금까지 살펴본 노드 탐색, 노드 정보 프로퍼티는 모두 읽기 전용 접근자 프로퍼티이다. 하지만 Node.prototype.nodeValue 프로퍼티는 setter와 getter 모두 존재하는 접근자 프로퍼티이다. 따라서 nodeValue 프로퍼티는 참조와 할당 모두 가능하다.</p>
<p>노드의 nodeValue 프로퍼티를 참조하면 노드의 값을 반환한다. 이때 텍스트 노드가 아닌 노드, 즉 문서 노드나 요소 노드의 nodeValue 프로퍼티를 참조하면 null을 반환한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//문서 노드의 값 참조</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.nodeValue)<span class="comment">//null</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//요소 노드의 값 참조</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $foo = <span class="built_in">document</span>.getElementbyId(<span class="string">'foo'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($foo.nodeValue) <span class="comment">//null;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//텍스트 노드의 값 참조</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $textNode = $foo.firstChild;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($textNode.nodeVlue) <span class="comment">//Hello;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>이 처럼 텍스트 노드가 아닌 노드의 nodeValue 프로퍼티는 null을 반환 하므로 의미 없고 텍스트 노드의 nodeValue 프로퍼티를 참조 할 때만 텍스트 노드의 값, 즉 텍스트를 반환한다. </p>
<p>텍스트 노드의 nodeValue 프로퍼티에 값을 할당하면 텍스트 노드의값, 즉 , 텍스트를 변경 할 수 있다. 이를 통해 요소 노드의 텍스트를 변경하려면 다음의 순서 처리가 필요하다. </p>
<ol>
<li>텍스트를 변경할 요소 노드를 취득한 다음 , 취득한 요소 노드의 텍스트 노드를 탐색한다 . 텍스트 노드는 요소 노드의 자식 노드이므로 firstChild 프로퍼티를 사용하여 탐색한다. </li>
<li>nodeValue 프로퍼티를 사용하여 탐색한 텍스트 노드의 값을 변경한다. </li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//1. div#foo요소의 텍스트 노드의 취득</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $textNode = <span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>).firstChild;</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="comment">//2. 텍스트 노드의 텍스트 변경,div#foo 요소의 텍스트가 변경이 된다.</span></span></span><br><span class="line"><span class="javascript">    $textNode.nodeValue = <span class="string">'World'</span>;</span></span><br><span class="line">    </span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($textNode.nodeValue); <span class="comment">//World;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="textContent"><a href="#textContent" class="headerlink" title="textContent"></a>textContent</h3><p>Node.prototype.textContentsetter와 getter 모두 존재하는 접근자 프로퍼티로서 요소 노드의 텍스트와 모든 자손 노드의 텍스트를 모두 취득하거나 변경한다.</p>
<p>요소 노드의 textContent 프로퍼티를 참조하면 요소 노드의 콘텐츠 영역(시작 태그와 종료 태그 사이) 내의 텍스트를 모두 반환한다. 다시 말해, 요소 노드의 childNodes 프로퍼티가 반환한 모든 노드들의 텍스트 노드의 값, 즉 텍스트를 모두 반환한다. 이때 HTML 마크업은 무시된다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>world!<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// div#foo 요소의 텍스트를 모두 취득</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// HTML의 마크업은 무시된다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>).textContent)<span class="comment">// Hello World;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>nodeValue 프로퍼티를 참조 하여도 텍스트를 취득할 수 있었다. 단. 텍스트 노드가 아닌 노드의 nodeValue 프로퍼티는 null을 반환하므로 의미가 없고 텍스트 노드의 nodeValue 프로퍼티를 참조 할 때 만 텍스트 노드의 값, 즉  텍스트를 반환한다.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>world!<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//div#foo 요소는 텍스트 노드가 아니다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>).nodeValue)<span class="comment">//null;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//div#foo 요소의 텍스트 노드의 값을 취득한다.</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementbtId(<span class="string">'foo'</span>).firtsChild.nodeValue)<span class="comment">//Hello</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//span요소의 택스트 노드의 값을 텍스트를 취득</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">'foo'</span>).lastChild.firstChild.nodeValue) <span class="comment">//world;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>만약 요소의 노드의 콘텐츠 영역에 다른 노드가 없고 텍스트만 존재 한다면 firstChild.nodeValue와 textContent 프로퍼티는 같은 결과를 반환한다. 따라서 이경우 , textContent 프로퍼티를 사용하는 것이 좋다. </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 요소 노드의 콘텐츠 영역에 다른 요소 노드가 없고 텍스트만 존재 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> $foo = <span class="built_in">document</span>.getElementbyId(<span class="string">'foo'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log($foo.textContent === $foo.fristChild.nodeValue);</span></span><br><span class="line"><span class="javascript">    <span class="comment">//true;</span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>요소 노드의 textContent 프로퍼티에 문자열을 할다앟면 요소 노드의 모든 자식 노드가 제거되고 할당한 문자열이 텍스트로 추가된다. 이때 할당하나 문자열에 HTML 마크업이 포함되어 있더라도 문자열 그대로 텍스트 취급된다. 즉  HTML 마크업이 파싱되지 않는다.</p>
]]></content>
      <tags>
        <tag>DOM에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>제어문</title>
    <url>/2020/05/12/control-flow-statement-md/</url>
    <content><![CDATA[<h1 id="1-블록문"><a href="#1-블록문" class="headerlink" title="1. 블록문"></a>1. 블록문</h1><p>블록문는 0개이 상의 문을 중괄호로 묶은것으로 콛블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블ㄹ고문을 하나의 시랳아 단위로 취급한다. 블록문은 단독으로 사용할 수도 있으나 일반적으로 제어문이나 함수를 정의할때 상요하는 것이 일반적이다.<br>블록문이 사용되는 다양한 예제가 있다. 문의 끝에는 세미 콜론을 붙이는 것이 일반적이다. 하지만 블록 문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다는 것에 주의하자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//블록문</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//제어문</span></span><br><span class="line"><span class="keyword">var</span> x =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">10</span>)&#123;</span><br><span class="line">  x++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-조건문"><a href="#2-조건문" class="headerlink" title="2. 조건문"></a>2. 조건문</h1><p>조건문은 주어진 조건식의 평가 결과에 따라 코드블록의(블록문)의 실행을  결정한다. 조건식은 불리언 값으로 평가 될 수있는 표현식이다. 자바스크립트는 2가지의 조건문 if …else if 문과 switch문을 제공한다.</p>
<h2 id="2-1-if-…-else-if-문"><a href="#2-1-if-…-else-if-문" class="headerlink" title="2.1. if … else if 문"></a>2.1. if … else if 문</h2><p>if .. else  문은 주언진 조건식(불리언 값으로 평가 될수 있는 표현식)의 평가 결과,즉 놀리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다. 조건식의 평가 결과가 참일 경우,if 문 다음의 코들 블록이 실행되고 거짓일 경우 else일경우 다음의 코드 블록이 실행된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(조건식)&#123;</span><br><span class="line">  <span class="comment">//조건식이  참이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//조건식이 거짓이면 이 코드 블록리 실행된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if의 조건식은 불리언 값으로 평가 되어야한다. 만약if문의 조건식이 불리언값이 아닌 다른 값으로 평가 되면 자바스크립트 엔진에 의해서 암묵적으로 데이터 타입이 불리언 값으로 강제로 변환이 되어 실행할 코드 블록을 결정한다.<br>조건식을 추가하여 조건에 따라 실행될 코드 블록을 늘리고 싶으면 else if문을 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(조건식)&#123;</span><br><span class="line">  <span class="comment">//조건식1이 참이면 이 코드 블록을 실행</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(조건식)&#123;</span><br><span class="line">  <span class="comment">//조건식2이 참이면 이 코드블록을 실행</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//조건식1과 조건식2가 모두 거짓이면 이 코들 블록을 실행</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> else if문과 else문은 옵션이다. 즉 사용 할 수도 있고 사용하지 않을 수도 있다. if문과 else문은 2번이상 사용할수 없지만 else if문은 2 이상 사용 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind;</span><br><span class="line"><span class="comment">//if문</span></span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  kind =<span class="string">'양수'</span>;<span class="comment">//양수</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kind);</span><br><span class="line"></span><br><span class="line"><span class="comment">//if else 문</span></span><br><span class="line"><span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">  kind = <span class="string">'양수'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  kind =<span class="string">'음수'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kind<span class="comment">//양수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if else if문 </span></span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  kind =<span class="string">'양수'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt;<span class="number">0</span>)&#123;</span><br><span class="line">  kind = <span class="string">'음수'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  kind = <span class="string">'영'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kind); <span class="comment">//양수</span></span><br></pre></td></tr></table></figure>

<p>만약에 코드 블록의 문이 하나라면 중괄호를 생략 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind;</span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span> )kind = <span class="string">'양수'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">0</span>)kind = <span class="string">'음수'</span>;</span><br><span class="line"><span class="keyword">else</span> kind = <span class="string">'영'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(kind) <span class="comment">//양수</span></span><br></pre></td></tr></table></figure>

<p>대부분의 if…else 문은 삼항 조건 연산자로 바꿔 사용가능하다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"><span class="keyword">if</span>(x % <span class="number">2</span>)&#123;</span><br><span class="line">  result = <span class="string">'홀수'</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  result = <span class="string">'짝수'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//짝수</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> result = (x % <span class="number">2</span> )? <span class="string">'홀수'</span>:<span class="string">'짝수'</span>;</span><br><span class="line">consoel.log(result) <span class="comment">//짝수</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind = num ? (n &gt;<span class="number">0</span>? <span class="string">'양수'</span>: <span class="string">'음수'</span>):<span class="string">'영'</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">//양수</span></span><br></pre></td></tr></table></figure>

<p>(n &gt;0? ‘양수’: ‘음수’)는 표현식이다. 즉 삼항 조건 연산자는 값으로 평가되는 표현식을 만든다. 하지만 if . else 문은 표현식이 아닌 문이다. 따라서 삼항 조건 연산자 표현식은 값 처럼 사용 할 수 있기 때문에 변수 할당 할 수 있다.하지만 if..else문은  값처럼 사용 할수 없다는 차이가 있다. 따라서 조건에 따라 단순히 값을 결정하는 경우 if ..else문 보다 삼항 조건 연산자를 사용하는 것이 가독성이 좋다. 하지만 조건에 따라 실행하여야 하는 내용이 복잡하여 여러 줄의 문이 필요하다면 if ..else문을 사용 하는 평이 가독성이 좋다.</p>
<h2 id="2-2-switch문"><a href="#2-2-switch문" class="headerlink" title="2.2. switch문"></a>2.2. switch문</h2><p>switch문은 주어진 표현식을 형가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행하는 순서를 이동 시킨다. case문은 상화을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행 할  문들을 위치 시킨다.<br>switch문의 표현식과 일치하는 표현식을 갖는 case문이 없다면 실행 순서는 default 문으로 이동한다. default 문은 옵션으로 사용 할 수 있고 않을 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(표현식)&#123;</span><br><span class="line">  <span class="keyword">case</span> 표현식<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 표현식<span class="number">1</span>이 일치하면 실행될 문;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 표현식<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 표현식<span class="number">2</span>이 일치하면 실행될 문;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 일치하는 표현식을 갖는 <span class="keyword">case</span>문이 없을 때 실핼될 문</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>else if 문의 조건식은 불리언 값으로 평가되어야 하지만 , switch 문의 표현식은 불리언 값 보다는 문자열 ,숫자 값인 경우가 많다. if ..else 문은 논리적 참,거짓으로 실행할 코들 블록을 결정한다.switch문은 논리적참,거짓 보다 다양한 상황에 따라 실행될 코드 블록을 결정 할 때가 많다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> month = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> monthName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: monthName = <span class="string">'January'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: monthName = <span class="string">'February'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: monthName = <span class="string">'March'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>: monthName = <span class="string">'April'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>: monthName = <span class="string">'May'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>: monthName = <span class="string">'June'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>: monthName = <span class="string">'July'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>: monthName = <span class="string">'August'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>: monthName = <span class="string">'September'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>: monthName = <span class="string">'October'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>: monthName = <span class="string">'November'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>: monthName = <span class="string">'December'</span>;</span><br><span class="line">  <span class="keyword">default</span>: monthName = <span class="string">'Invalid month'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(monthName); <span class="comment">// November</span></span><br></pre></td></tr></table></figure>

<p>그런데 위 예제를 실행해 보면은 ‘November’가 출력되지 않고 ‘Invalid  month’을 출력한다. 이는 switch문의 표현식의 평가 결과와 일치하는 case 문으로 실행한 것은 맞지만 ,문을 실행한 후  switch문을 탈출 하지않고 switch문이 끝날 때 까지 이후의 모든 case문과 default문을 실행 했기 때문이다. 이를 <strong><u>폴 스루</u></strong> 했다고 한다. 다시 말해 변수 monthName에  ‘November’가 할당된 후 switch 문을 탈출 하지않고 연이어 재할되기 때문이다. 때문에 ‘Invalid month’출력된다.<br>결과가 이러한 이유는 case문에 해당하는 문의 마지막 break문을 사용하지 않았기 때문이다. break 키워드로 구성된 break문은 코드 블록에서 탈출하는 역할을 한다. break문이 없다면 case문의 표현식과 일치하지 않더라도 실행 순서는 다음 case문으로 연이어 이동한다. 올바른 switch문의 예는 다음과 같다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> month = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> monthName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: monthName = <span class="string">'January'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: monthName = <span class="string">'February'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: monthName = <span class="string">'March'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>: monthName = <span class="string">'April'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>: monthName = <span class="string">'May'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>: monthName = <span class="string">'June'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>: monthName = <span class="string">'July'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>: monthName = <span class="string">'August'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>: monthName = <span class="string">'September'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>: monthName = <span class="string">'October'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>: monthName = <span class="string">'November'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>: monthName = <span class="string">'December'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: monthName = <span class="string">'Invalid month'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(monthName); <span class="comment">// November</span></span><br></pre></td></tr></table></figure>

<p>deafult 문에는 break문을 생략하는 것이 일반적이다. default문은 switch문의 가장 마지막에 위치하므로 defualt문의 실행은 따라서 별도의 break문이 필요 없다.</p>
<p>break문을 생략한 폴 스루가 유용한 경우도 있다 폴스루는 여러개의 case문을 하나의 조건으로 사용할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> year =<span class="number">2020</span>;</span><br><span class="line"><span class="keyword">var</span> month = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> days = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> :<span class="keyword">case</span> <span class="number">3</span>:<span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    days = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:<span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">    days = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    days =((year % <span class="number">4</span> ===<span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !== <span class="number">0</span>) || (yaer % <span class="number">400</span> === <span class="number">0</span>))?<span class="number">29</span>:<span class="number">28</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Invalid month'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(days);</span><br></pre></td></tr></table></figure>

<p>switch문은 case, default,break등 다양한 키워드를 사용해야하고 상화에 따라 실행될 코들 블록리 중괄호로 붂어 있지 안흥며 폴스루가 발생하는 등 문법도 복잡하다. 따라서 C언어를 기반으로 하는 프로그래밍 언어는 대부분 switch문을 지원하지만 피이썬과 같이 switch문을 지원 하지 않는 프로그래밍 언어도 존재한다.<br>만약 if ..else문으로 해결 할 수 있다면 switch문 보다 if ..else문을 사용했을때 가독성이 더 좋다. 하지만 if…else 문보다는 switch 문을 사용했을때 더 가독성이 좋다면 switch문을 사용하는 편이 좋다.</p>
<h1 id="3-반복문"><a href="#3-반복문" class="headerlink" title="3. 반복문"></a>3. 반복문</h1><p>반복문은 주어진 조건식의 평가 결과가 참인 경우 코드블럭을 실행한다. 그 후 저건식을 다시 검사하여 여전히 참인 경우 코드블록을 다시 실행한다. 이는 조건식이 거짓일때 까지 반복한다.<br>자바스크립트는 3가지의 반복문 for문 while문 do while문 을 제공한다.<br>반복문을 대체 할 수 있는 다양한 기능 </p>
<p>자바스크립트는 배열을 순회할때 사용하는 forEach 메소드,객체의 프로퍼티를 열거할 때 사용하는 for ..in문 Es6에서 새롭게 이터러블을  순회할 수 있는 for..of문과 같이 반복문을 대체 할 수 있는 다양한 기능을 제공한다.</p>
<h2 id="3-1-for문"><a href="#3-1-for문" class="headerlink" title="3.1. for문"></a>3.1. for문</h2><p>for문은 조건식이 거짓으로 판별 될때 까지 코드 블록을 반복 실행한다. 가장 일반적으로 사용되는 for문의 형태는 다음과 같다. 변수 선언문의 변수이름은 반복을 의미하는 iteration의 i을 사용하는 것이 일반적이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(변수 선언문 또는 할당문;조건식;증감식)&#123;</span><br><span class="line">  조건식이 참인 경우 반복 실행될 문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">  consoel.log(i) <span class="comment">// 0 1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poiemaweb.com/assets/fs-images/8-1.png" alt="img"></p>
<p>for문의 변수 선언문,조건식,증감식은 모구 옵션이다. 반드시 사용할 필요는 없다. 어떤식도 선언하지 않으면 무한 루프가 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 루프</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;=<span class="number">6</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j =<span class="number">0</span>;j&lt;=<span class="number">6</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i+j === <span class="number">6</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;i&#125;</span>,<span class="subst">$&#123;j&#125;</span>]`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="3-2-while문"><a href="#3-2-while문" class="headerlink" title="3.2. while문"></a>3.2. while문</h2><p>while문은 주언진 조건식의 평가가 참이면 코드블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이면 실행을 종료한다. 만약 조건식의 평가 결과가 블리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참 거짓을 구별하게 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//count가 3보다 작을 때 까지 코드블록을 계속 반복 실행한다.</span></span><br><span class="line"><span class="keyword">while</span>(count &lt;<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count); <span class="comment">// 0 1 2 </span></span><br><span class="line">  count++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>조건식의 평가 결과 가 언제나 참이면 무한 루프를 돈다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 루프를 탈출하기 우해서 조건을 만들고 break을 사용하여 탈출한다.</span></span><br><span class="line"> <span class="keyword">var</span> count =<span class="number">0</span>;</span><br><span class="line"><span class="comment">//무한 루프</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  consoel.log(count);</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">//count가 3이면 코들블록을 탈출한다.</span></span><br><span class="line">  <span class="keyword">if</span>(count ===<span class="number">3</span>)<span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">//0 1 2 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-do-while문"><a href="#3-3-do-while문" class="headerlink" title="3.3. do while문"></a>3.3. do while문</h2><p>do…while문은 코드블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드블록은 무조건 한번이상 실행된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counr =<span class="number">0</span>;</span><br><span class="line"><span class="comment">//count가 3보다 작을때 까지 코드블록을 곗고 반복 실행;</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125;<span class="keyword">while</span>(count &lt;<span class="number">3</span>) <span class="comment">//0 1 2;</span></span><br></pre></td></tr></table></figure>

<h1 id="4-break문"><a href="#4-break문" class="headerlink" title="4.  break문"></a>4.  break문</h1><p>switch문과 while문 네서 살펴 보았듯이 break문은 코드 블록을 탈출한다. 좀 더 정확히 말하면 코드블록을 탈출하는 것이 아니라 레이블문 ,반복문(for,for..in,for…of ,while문,do…while문) 또는 switch문의 코드블록을 탈출한다.<br>레이블 문,반복문,switch 문의 코드블록 이외에 break 문을 사용하면 SyntaxError문법에러가 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">break</span>;<span class="comment">// Uncaught SyntaxError: Illegal break statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>레이블 문(label statement)이란 식별자가 붙은 문을 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foo라는 레이블 식별자가 붙은 레이블 문</span></span><br><span class="line">foo: <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure>

<p>레이블 문은 프로그램의 실행 순서를 제어하기 위햇 사용한다. 사실  switch 문의 case문과 default도 레이블 문이다. 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foo라는 식별자가 붙은 레이블 블록문</span></span><br><span class="line">foo:&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">break</span> foo;<span class="comment">//foo 레이블 블록문을 탈출한다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br></pre></td></tr></table></figure>

<p>중첩된 for 문의 내부 for문에서 break문을 실행하면 내부 for문을 탈출하여 외부 for문으로 진입한다. 이때 내부for문이 아닌 외부 for문을 탈출하려면 레이블문을 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//outer라는 식별자가 붙은 레이블 for문</span></span><br><span class="line">outer:<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">    <span class="comment">//i+j === 3 이면 outer라는 식별자가 붙은 레이블 for문을 탈출한다.</span></span><br><span class="line">    <span class="keyword">if</span>( i+j === <span class="number">3</span>) <span class="keyword">break</span> outer;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`inner [<span class="subst">$&#123;i&#125;</span>,<span class="subst">$&#123;j&#125;</span>]`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Done!'</span>);</span><br></pre></td></tr></table></figure>

<p>레이블 문은 중첩된 for문 외부로 탈출할 때 유용하지만 그 외의 경우 레이블 문은 일반적으로 권장 하지않는다. 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문이다.</p>
<p>break문은 레이블 문 뿐 만이 아니라 반복문,switch문에서도 사용 할 수 있다. 이 경우에는 break문에 레이블 식별자를 지정하지 않는다. break문은 반복문을 더 이상 진행하지 않아도 될때 불필요한 반복을 회피할 수 있어 유용하다.</p>
<p>아래는 문자열에서 특정한 인덱스의 위치를 검색하는 예제이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">'Hello world'</span>;</span><br><span class="line"><span class="keyword">var</span> search = <span class="string">'l'</span>;</span><br><span class="line"><span class="keyword">var</span> index ;</span><br><span class="line"><span class="comment">//문자열은 유사배열이므로 for문으로 순회할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i &lt; string.length;i++)&#123;</span><br><span class="line">  <span class="comment">//문자열의 개별 문자가 'l'이면;</span></span><br><span class="line">  <span class="keyword">if</span>(string[i] === search)&#123;</span><br><span class="line">    index = i;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//반복문은 탈출한다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">//2;</span></span><br><span class="line"></span><br><span class="line">consoel.log(string.indexOf(search)) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h1 id="5-continue문"><a href="#5-continue문" class="headerlink" title="5. continue문"></a>5. continue문</h1><p>continue문은 반복문의 코드블록 실행 을 현 시점에서 중담하고 반복문의 증감식으로 이동한다. break문처럼 반복문을 탈출하지않는다.<br>문자열에서 특정 문자의 개수를 카운트하는 예제이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">'Hello world'</span>;</span><br><span class="line"><span class="keyword">var</span> search =<span class="string">'l'</span>;</span><br><span class="line"><span class="keyword">var</span> index ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;string.length;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(string [i] !== serach) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">//string[i] === 'l'일때에만 아래의 count++가 실행된다.</span></span><br><span class="line">  <span class="comment">//string[i] !== 'l'일 때에는 for문의 조건의 증감식으로 이동한다.</span></span><br><span class="line">  count++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">//3;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> regexp =<span class="keyword">new</span> <span class="built_in">RegExp</span>(search,<span class="string">'g'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regexp).length); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;string.length;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(string[i] === search)&#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 if문 내에서 실행해야 할 코드가 한 줄이라면 continue문을 사용했을때 보다 간편하며 가독성이 좋다. 하지만 if문 내에서 실행할 코드가 길다면 들여쓰기가 한 단계 더 깊어지므로 continue 문을 사용하는 것이 가독성이 더 좋다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// continue 문을 사용하지않으면 if문 내에 코드를 작성해야한다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;string.length;i++)&#123;</span><br><span class="line">  <span class="comment">//'l'이면 카운트를 증가 시킨다.</span></span><br><span class="line">  <span class="keyword">if</span>(string[i] === search)&#123;</span><br><span class="line">    count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//continue 문을 사용하면 id문 밖에 코드를 작성할수있다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;string.length;i++)&#123;</span><br><span class="line">  <span class="comment">//'l'이 아니면 카운트를 증가 시키지 않는다.</span></span><br><span class="line">  <span class="keyword">if</span>( string[i] !== search) <span class="keyword">continue</span>;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>제어문에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML콘텐츠 모델과 다양한 API</title>
    <url>/2020/06/03/html-contents-model-md/</url>
    <content><![CDATA[<p>HTML5는 html4.01,xHTML1.0과 도입한 마크업 언어입니다. 기존 HTML과 HTML5의 차이점은 새롭게 도입된 콘텐츠 모델이라는 개념과 구조관련 요소가 추가 되었다는 점을 들을수 있습니다. 또한 기존에 사용했던 요소중에서 의미가 변한 요소도 있습니다. </p>
<hr>

<h2 id="콘텐츠-모델-Contents-Model"><a href="#콘텐츠-모델-Contents-Model" class="headerlink" title="콘텐츠 모델(Contents Model)"></a>콘텐츠 모델(Contents Model)</h2><p>기존 HTML기반의 마크업에서 일잔적인 인라인 요소와 블록 요소로 구분하는정도의 개념만 존재하였지만 ,HTML15에서는 좀더 명확한 정보 구조 설계 및 구성을 위해 카테고리를 정의하여 각 요소별로 비슷한 성격을 가지고 있는 것들끼리 그룹화 하였는데 이를 HTML5의 콘텐츠 모델이라고 합니다. </p>
<p>특히 HTML5에 추가된 콘텐츠 모델이란 ,’어떤 요소에 어떤 콘텐츠를 포함해야하는지’,’어떤 요소가 어떤요소를 포함할 수있는지’를 정의한 것을 말합니다. 이 콘텐츠 모델이라는 개념을 통해 자식 요소로 포함 할 수이쓴느 카테고리에 제한을 두었으며 , 이와 반대로 자식 요소가 작성 될 수 있는 카테고리를 제한하였스빈다. 이런 HTML5의 콘텐츠 모델은 단순히 기존 HTML 에서의 문법적인 변화만을 의미하는 것으로 그치지 않고 구조와 구성을 중시하는 마크업으로 진화했다는 점을 이해할수있습니다. </p>
<p>HTML5의 카테고리(Category)에는 Sectioning Root, Metadata Content, Flow Content, Sectioning Content, Heading Content, Phrasing Content, Embedded Content, Interactive Content, Palpable Content, Script-supporting Elements, Transparent Content 등의 그룹이 있으며, 하나의 요소가 여러 그룹에 속해 있을 수도 있고, 그렇지 않을 수도 있습니다.</p>
<p><img src="https://user-images.githubusercontent.com/54792457/83939268-a2112180-a816-11ea-9605-8715918241c9.png" alt="콘텐츠 모델"></p>
<ul>
<li><strong>섹셔닝 루트(Sectioning Root)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>, <span class="tag">&lt;<span class="name">body</span>&gt;</span>, <span class="tag">&lt;<span class="name">detail</span>&gt;</span>, <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>, <span class="tag">&lt;<span class="name">figure</span>&gt;</span>, <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>몇몇 요소는 섹셔닝 루트라는 그룹으로 구분합니다. 섹셔닝 루트에 속하는 요소는 section이나 article 요소와 같이 장이나 절과 같은 계층 구조로 구분되지 않고 독립적인 콘텐츠로 분리되기 때문에 아웃라인에 영향을 주지 않습니다.</p>
<ul>
<li>** 메타데이터 콘텐츠(Metadata Content)**</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span>&gt;</span>, <span class="tag">&lt;<span class="name">link</span>&gt;</span>, <span class="tag">&lt;<span class="name">meta</span>&gt;</span>, <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>, <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml">, <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="xml">, <span class="tag">&lt;<span class="name">title</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure>

<p>메타데이터는 문서의 정보를 포함하는 메타데이터, 스타일 표현을 위한 style 요소, 행동을 설정하는 script 요소들을 나타냅니다. 기본적인 웹 브라우저에 직접적으로 표시되지 않으며, 문서(document)와 문서 간의 관계를 설정합니다.</p>
<ul>
<li><strong>플로우 콘텐츠(Flow Content)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>, <span class="tag">&lt;<span class="name">abbr</span>&gt;</span>, <span class="tag">&lt;<span class="name">address</span>&gt;</span>, <span class="tag">&lt;<span class="name">area</span>&gt;</span>(<span class="tag">&lt;<span class="name">map</span>&gt;</span> 요소의 자손인 경우), <span class="tag">&lt;<span class="name">article</span>&gt;</span>, <span class="tag">&lt;<span class="name">aside</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span>&gt;</span>, <span class="tag">&lt;<span class="name">b</span>&gt;</span>, <span class="tag">&lt;<span class="name">bdi</span>&gt;</span>, <span class="tag">&lt;<span class="name">bdo</span>&gt;</span>, <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>, <span class="tag">&lt;<span class="name">br</span>&gt;</span>, <span class="tag">&lt;<span class="name">button</span>&gt;</span>, <span class="tag">&lt;<span class="name">canvas</span>&gt;</span>, <span class="tag">&lt;<span class="name">cite</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>, <span class="tag">&lt;<span class="name">data</span>&gt;</span>, <span class="tag">&lt;<span class="name">datalist</span>&gt;</span>, <span class="tag">&lt;<span class="name">del</span>&gt;</span>, <span class="tag">&lt;<span class="name">details</span>&gt;</span>, <span class="tag">&lt;<span class="name">dfn</span>&gt;</span>, <span class="tag">&lt;<span class="name">dialog</span>&gt;</span>, <span class="tag">&lt;<span class="name">div</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>, <span class="tag">&lt;<span class="name">em</span>&gt;</span>, <span class="tag">&lt;<span class="name">embed</span>&gt;</span>, <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>, <span class="tag">&lt;<span class="name">figure</span>&gt;</span>, <span class="tag">&lt;<span class="name">footer</span>&gt;</span>, <span class="tag">&lt;<span class="name">form</span>&gt;</span>, <span class="tag">&lt;<span class="name">h1</span>&gt;</span>, <span class="tag">&lt;<span class="name">h2</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>, <span class="tag">&lt;<span class="name">h4</span>&gt;</span>, <span class="tag">&lt;<span class="name">h5</span>&gt;</span>, <span class="tag">&lt;<span class="name">h6</span>&gt;</span>, <span class="tag">&lt;<span class="name">header</span>&gt;</span>, <span class="tag">&lt;<span class="name">hr</span>&gt;</span>, <span class="tag">&lt;<span class="name">i</span>&gt;</span>, <span class="tag">&lt;<span class="name">iframe</span>&gt;</span>, <span class="tag">&lt;<span class="name">img</span>&gt;</span>, <span class="tag">&lt;<span class="name">input</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span>, <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>, <span class="tag">&lt;<span class="name">keygen</span>&gt;</span>, <span class="tag">&lt;<span class="name">label</span>&gt;</span>, <span class="tag">&lt;<span class="name">main</span>&gt;</span>, <span class="tag">&lt;<span class="name">map</span>&gt;</span>, <span class="tag">&lt;<span class="name">mark</span>&gt;</span>, <span class="tag">&lt;<span class="name">math</span>&gt;</span>, <span class="tag">&lt;<span class="name">meter</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span>, <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>, <span class="tag">&lt;<span class="name">object</span>&gt;</span>, <span class="tag">&lt;<span class="name">ol</span>&gt;</span>, <span class="tag">&lt;<span class="name">output</span>&gt;</span>, <span class="tag">&lt;<span class="name">p</span>&gt;</span>, <span class="tag">&lt;<span class="name">pre</span>&gt;</span>, <span class="tag">&lt;<span class="name">progress</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">q</span>&gt;</span>, <span class="tag">&lt;<span class="name">ruby</span>&gt;</span>, <span class="tag">&lt;<span class="name">s</span>&gt;</span>, <span class="tag">&lt;<span class="name">samp</span>&gt;</span>, <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml">, <span class="tag">&lt;<span class="name">section</span>&gt;</span>, <span class="tag">&lt;<span class="name">select</span>&gt;</span>, <span class="tag">&lt;<span class="name">small</span>&gt;</span>, <span class="tag">&lt;<span class="name">span</span>&gt;</span>, </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>, <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="xml">(scoped 속성이 있는 경우) <span class="tag">&lt;<span class="name">sub</span>&gt;</span>, <span class="tag">&lt;<span class="name">sup</span>&gt;</span>, <span class="tag">&lt;<span class="name">svg</span>&gt;</span>, <span class="tag">&lt;<span class="name">table</span>&gt;</span>, </span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span>, <span class="tag">&lt;<span class="name">time</span>&gt;</span>, <span class="tag">&lt;<span class="name">u</span>&gt;</span>, <span class="tag">&lt;<span class="name">ul</span>&gt;</span>, <span class="tag">&lt;<span class="name">var</span>&gt;</span>, <span class="tag">&lt;<span class="name">video</span>&gt;</span>, <span class="tag">&lt;<span class="name">wbr</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>HTML5의 콘텐츠 모델 관계도에 표시한 것과 같이 메타데이터 콘텐츠 요소 중 일부를 제외하고 문서 본문에 해당하는 body 요소에 들어가는 대부분의 요소들이 플로우 콘텐츠 모델에 속하며, 이 중에서 area, link, meta, style 요소는 조건부로 플로우 콘텐츠가 됩니다.</p>
<ul>
<li><strong>섹셔닝 콘텐츠(Sectioning Content)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span>, <span class="tag">&lt;<span class="name">aside</span>&gt;</span>, <span class="tag">&lt;<span class="name">nav</span>&gt;</span>, <span class="tag">&lt;<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>섹셔닝 콘텐츠는 대부분 HTML5에서 새롭게 추가된 요소들이며, 제목과 그 내용을 포함한 범위를 지정하는 콘텐츠를 나타냅니다. 모든 섹셔닝 콘텐츠는 헤딩과 아웃라인을 가집니다.</p>
<ul>
<li><strong>헤딩 콘텐츠(Heading Content)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>, <span class="tag">&lt;<span class="name">h2</span>&gt;</span>, <span class="tag">&lt;<span class="name">h3</span>&gt;</span>, <span class="tag">&lt;<span class="name">h4</span>&gt;</span>, <span class="tag">&lt;<span class="name">h5</span>&gt;</span>, <span class="tag">&lt;<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>헤딩 콘텐츠는 섹션의 제목을 나타냅니다. 문서의 아웃라인을 고려하여 사용해야 합니다.</p>
<ul>
<li><strong>프레이징 콘텐츠(Phrasing Content)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>, <span class="tag">&lt;<span class="name">abbr</span>&gt;</span>, <span class="tag">&lt;<span class="name">area</span>&gt;</span>(<span class="tag">&lt;<span class="name">map</span>&gt;</span> 요소의 자손인 경우), <span class="tag">&lt;<span class="name">audio</span>&gt;</span>, <span class="tag">&lt;<span class="name">b</span>&gt;</span>, <span class="tag">&lt;<span class="name">bdi</span>&gt;</span>, <span class="tag">&lt;<span class="name">bdo</span>&gt;</span>, <span class="tag">&lt;<span class="name">br</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">button</span>&gt;</span>, <span class="tag">&lt;<span class="name">canvas</span>&gt;</span>, <span class="tag">&lt;<span class="name">cite</span>&gt;</span>, <span class="tag">&lt;<span class="name">code</span>&gt;</span>, <span class="tag">&lt;<span class="name">data</span>&gt;</span>, <span class="tag">&lt;<span class="name">datalist</span>&gt;</span>, <span class="tag">&lt;<span class="name">del</span>&gt;</span>, <span class="tag">&lt;<span class="name">dfn</span>&gt;</span>, <span class="tag">&lt;<span class="name">em</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span>&gt;</span>, <span class="tag">&lt;<span class="name">i</span>&gt;</span>, <span class="tag">&lt;<span class="name">iframe</span>&gt;</span>, <span class="tag">&lt;<span class="name">img</span>&gt;</span>, <span class="tag">&lt;<span class="name">input</span>&gt;</span>, <span class="tag">&lt;<span class="name">ins</span>&gt;</span>, <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>, <span class="tag">&lt;<span class="name">keygen</span>&gt;</span>, <span class="tag">&lt;<span class="name">label</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span>, <span class="tag">&lt;<span class="name">mark</span>&gt;</span>, <span class="tag">&lt;<span class="name">math</span>&gt;</span>, <span class="tag">&lt;<span class="name">meter</span>&gt;</span>, <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>, <span class="tag">&lt;<span class="name">object</span>&gt;</span>, <span class="tag">&lt;<span class="name">output</span>&gt;</span>, <span class="tag">&lt;<span class="name">progress</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">q</span>&gt;</span>, <span class="tag">&lt;<span class="name">ruby</span>&gt;</span>, <span class="tag">&lt;<span class="name">s</span>&gt;</span>, <span class="tag">&lt;<span class="name">samp</span>&gt;</span>, <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="xml">, <span class="tag">&lt;<span class="name">select</span>&gt;</span>, <span class="tag">&lt;<span class="name">small</span>&gt;</span>, <span class="tag">&lt;<span class="name">span</span>&gt;</span>, <span class="tag">&lt;<span class="name">strong</span>&gt;</span>, </span></span><br><span class="line"><span class="xml"> <span class="tag">&lt;<span class="name">sub</span>&gt;</span>, <span class="tag">&lt;<span class="name">sup</span>&gt;</span>, <span class="tag">&lt;<span class="name">svg</span>&gt;</span>, <span class="tag">&lt;<span class="name">textarea</span>&gt;</span>, <span class="tag">&lt;<span class="name">time</span>&gt;</span>, <span class="tag">&lt;<span class="name">u</span>&gt;</span>, <span class="tag">&lt;<span class="name">var</span>&gt;</span>, <span class="tag">&lt;<span class="name">video</span>&gt;</span>, <span class="tag">&lt;<span class="name">wbr</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>프레이징 콘텐츠는 문서의 텍스트를 나타내며, 그 텍스트를 문단 내부 레벨로 마크업하는 요소들입니다. 프레이징 콘텐츠가 모여 문단을 구성합니다. a 요소와 같은 일부 요소들은 콘텐츠로 다른 요소를 포함하지 않는다는 전제하에 조건부로 프레이징 콘텐츠가 되기도 합니다. 프레이징 콘텐츠로 분류되는 요소의 대부분은 플로우 콘텐츠 전체를 포함할 수 없으며, 프레이징 콘텐츠로 분류된 요소만을 포함할 수 있습니다. 또한 프레이징 콘텐츠는 텍스트 이외에 임베디드 콘텐츠를 포함할 수 있습니다.</p>
<ul>
<li><strong>임베디드 콘텐츠(Embedded Content)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span>&gt;</span>, <span class="tag">&lt;<span class="name">canvas</span>&gt;</span>, <span class="tag">&lt;<span class="name">embed</span>&gt;</span>, <span class="tag">&lt;<span class="name">iframe</span>&gt;</span>, <span class="tag">&lt;<span class="name">img</span>&gt;</span>, <span class="tag">&lt;<span class="name">math</span>&gt;</span>, <span class="tag">&lt;<span class="name">object</span>&gt;</span>, <span class="tag">&lt;<span class="name">svg</span>&gt;</span>, <span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>임베디드는 ‘포함된’이라는 뜻을 가지고 있으며, 문서 안에 외부 자원(‘외부 리소스’라고 불리기도 함) 또는 HTML이 아닌 다른 언어로 표현되는 콘텐츠를 말합니다. 외부 자원에는 이미지, 동영상, 플러그인, 아이프레임 콘텐츠 등이 있고, 다른 언어로 된 콘텐츠에는 수학 공식을 표현하는 MathML과 SVG 등이 있습니다.</p>
<ul>
<li><strong>인터랙티브 콘텐츠(Interactive Content)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>, <span class="tag">&lt;<span class="name">audio</span>&gt;</span>(controls 속성이 있는 경우),<span class="tag">&lt;<span class="name">button</span>&gt;</span>, <span class="tag">&lt;<span class="name">details</span>&gt;</span>, <span class="tag">&lt;<span class="name">embed</span>&gt;</span>, <span class="tag">&lt;<span class="name">iframe</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">img</span>&gt;</span>(usemap 속성이 있는 경우), <span class="tag">&lt;<span class="name">input</span>&gt;</span>(type 속성이 hidden이 아닌 경우), <span class="tag">&lt;<span class="name">keygen</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">label</span>&gt;</span>, <span class="tag">&lt;<span class="name">object</span>&gt;</span>(usemap 속성이 있는 경우), <span class="tag">&lt;<span class="name">select</span>&gt;</span>, <span class="tag">&lt;<span class="name">textarea</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span>(controls 속성이 있는 경우)</span><br></pre></td></tr></table></figure>

<p>인터랙티브 콘텐츠는 사용자가 어떤 기능을 조작할 수 있는 (상호 작용) 콘텐츠를 말합니다. 예를 들면, 회원가입 정보를 입력한 후 [확인] 버튼을 누른다거나, 문서에 포함된 동영상을 재생한다거나, 링크를 클릭하는 것 등을 의미합니다. audio, img, input, object, video 요소는 이러한 특성을 바탕으로 조건부 인터랙티브 콘텐츠가 됩니다.</p>
<ul>
<li><strong>팰퍼블 콘텐츠(Palpable Content)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span>&gt;</span>, <span class="tag">&lt;<span class="name">abbr</span>&gt;</span>, <span class="tag">&lt;<span class="name">address</span>&gt;</span>, <span class="tag">&lt;<span class="name">article</span>&gt;</span>, <span class="tag">&lt;<span class="name">aside</span>&gt;</span>, <span class="tag">&lt;<span class="name">audio</span>&gt;</span>(controls 속성이 있는 경우), </span><br><span class="line"><span class="tag">&lt;<span class="name">base-img</span>&gt;</span>, <span class="tag">&lt;<span class="name">bdi</span>&gt;</span>, <span class="tag">&lt;<span class="name">bdo</span>&gt;</span>, <span class="tag">&lt;<span class="name">blockquote</span>&gt;</span>, <span class="tag">&lt;<span class="name">button</span>&gt;</span>, <span class="tag">&lt;<span class="name">canvas</span>&gt;</span>, <span class="tag">&lt;<span class="name">cite</span>&gt;</span>, <span class="tag">&lt;<span class="name">code</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span>, <span class="tag">&lt;<span class="name">details</span>&gt;</span>, <span class="tag">&lt;<span class="name">dfn</span>&gt;</span>, <span class="tag">&lt;<span class="name">div</span>&gt;</span>, <span class="tag">&lt;<span class="name">embed</span>&gt;</span>, <span class="tag">&lt;<span class="name">form</span>&gt;</span>, <span class="tag">&lt;<span class="name">fieldset</span>&gt;</span>, <span class="tag">&lt;<span class="name">figure</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span>(dl 요소의 자식 요소로 하나 이상의 이름과 값으로 구성되어 있는 경우), <span class="tag">&lt;<span class="name">em</span>&gt;</span>, <span class="tag">&lt;<span class="name">footer</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>, <span class="tag">&lt;<span class="name">h2</span>&gt;</span>, <span class="tag">&lt;<span class="name">h3</span>&gt;</span>, <span class="tag">&lt;<span class="name">h4</span>&gt;</span>, <span class="tag">&lt;<span class="name">h5</span>&gt;</span>, <span class="tag">&lt;<span class="name">h6</span>&gt;</span>, <span class="tag">&lt;<span class="name">header</span>&gt;</span>, <span class="tag">&lt;<span class="name">i</span>&gt;</span>, <span class="tag">&lt;<span class="name">iframe</span>&gt;</span>, <span class="tag">&lt;<span class="name">img</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span>(hidden 속성 값이 아닌 경우), <span class="tag">&lt;<span class="name">ins</span>&gt;</span>, <span class="tag">&lt;<span class="name">kbd</span>&gt;</span>, <span class="tag">&lt;<span class="name">keygen</span>&gt;</span>, <span class="tag">&lt;<span class="name">label</span>&gt;</span>, <span class="tag">&lt;<span class="name">main</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span>, <span class="tag">&lt;<span class="name">mark</span>&gt;</span>, <span class="tag">&lt;<span class="name">math</span>&gt;</span>, <span class="tag">&lt;<span class="name">menu</span>&gt;</span>(toolbar 속성이 있는 경우), <span class="tag">&lt;<span class="name">meter</span>&gt;</span>, <span class="tag">&lt;<span class="name">nav</span>&gt;</span>, <span class="tag">&lt;<span class="name">object</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span>(자식 요소로 하나 이상의 li 요소를 포함한 경우), <span class="tag">&lt;<span class="name">output</span>&gt;</span>, <span class="tag">&lt;<span class="name">p</span>&gt;</span>, <span class="tag">&lt;<span class="name">pre</span>&gt;</span>, <span class="tag">&lt;<span class="name">progress</span>&gt;</span>,</span><br><span class="line"><span class="tag">&lt;<span class="name">q</span>&gt;</span>, <span class="tag">&lt;<span class="name">ruby</span>&gt;</span>, <span class="tag">&lt;<span class="name">s</span>&gt;</span>, <span class="tag">&lt;<span class="name">samp</span>&gt;</span>, <span class="tag">&lt;<span class="name">section</span>&gt;</span>, <span class="tag">&lt;<span class="name">select</span>&gt;</span>, <span class="tag">&lt;<span class="name">small</span>&gt;</span>, <span class="tag">&lt;<span class="name">span</span>&gt;</span>, <span class="tag">&lt;<span class="name">strong</span>&gt;</span>, </span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span>, <span class="tag">&lt;<span class="name">sup</span>&gt;</span>, <span class="tag">&lt;<span class="name">svg</span>&gt;</span>, <span class="tag">&lt;<span class="name">table</span>&gt;</span>, <span class="tag">&lt;<span class="name">textarea</span>&gt;</span>, <span class="tag">&lt;<span class="name">time</span>&gt;</span>, <span class="tag">&lt;<span class="name">u</span>&gt;</span>, <span class="tag">&lt;<span class="name">var</span>&gt;</span>, <span class="tag">&lt;<span class="name">video</span>&gt;</span>, <span class="tag">&lt;<span class="name">span</span>&gt;</span>,</span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span>(자식 요소로 하나 이상의 li 요소를 포함한 경우)</span><br></pre></td></tr></table></figure>

<p>팰퍼블 콘텐츠는 기존 콘텐츠 모델에 새롭게 추가된 개념으로 구체적으로 보여지고 이해할 수 있는 콘텐츠 요소를 말하며, 최소한 하나 이상의 요소가 존재해야 합니다. 이때 해당 요소는 숨김 상태여서는 안됩니다.</p>
<ul>
<li><strong>스크립트 지원 요소(Script-supporting Elements)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>스크립트 지원 요소는 요소 자체가 어떤 정보를 표현하지는 않지만 사용자에 대한 기능 등에 해당하는 스크립트를 지원하는 데 사용됩니다.</p>
<ul>
<li><strong>트랜스 패어런트 콘텐츠(Transparent Content)</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span>, <span class="tag">&lt;<span class="name">audio</span>&gt;</span>, <span class="tag">&lt;<span class="name">canvas</span>&gt;</span>, <span class="tag">&lt;<span class="name">del</span>&gt;</span>, <span class="tag">&lt;<span class="name">ins</span>&gt;</span>, <span class="tag">&lt;<span class="name">map</span>&gt;</span>, <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>, <span class="tag">&lt;<span class="name">object</span>&gt;</span>, <span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>모든 요소는 콘텐츠 모델을 가지지만, 앞에서 설명한 카테고리에 속하지 않은 경우도 있습니다. 이러한 요소들을 ‘트랜스 패어런트(Transparent)’라고 합니다. 트랜스페어런트 콘텐츠는 투명하다는 의미가 아니라 트랜스 패어런트 콘텐츠 요소와 그 안에 담긴 콘텐츠를 바꾸어 마크업해도 HTML5 문법에 오류가 없다는 것을 의미합니다.</p>
<hr>

<h2 id="다양한-API의-추가"><a href="#다양한-API의-추가" class="headerlink" title="다양한 API의 추가"></a>다양한 API의 추가</h2><p>HTML5의 커다란 변화 중 하나로는 다양한 API(Application Programming Interface)의 추가를 들 수 있습니다. API란, 프로그램을 개발할 때 필요한 기본 기능을 의미합니다. 새로운 프로그램을 만들 때 사용하는 프로그래밍 언어(C 언어, Java, JavaScript 등) 차원에서 제공되거나 프로그램이 구동되는 환경을 의미하는 플랫폼에서 만들어져 제공되며 프로그램 개발자는 API를 활용하여 실제 필요로 하는 기능을 완성할 수 있습니다.</p>
<p>HTML5에서는 자바스크립트(JavaScript) 기술을 좀 더 편리하게 이용할 수 있도록 다양한 API를 지원하고 있습니다. HTML5에 추가된 API는 다음과 같습니다.</p>
<p><strong>오프라인 웹 구현을 위한 API</strong></p>
<p>오프라인에서 동작할 수 있는 웹 기능을 구현하기 위한 API로, Web Strorage, Web SQL Database, IndexedDB, Application Cache 등의 API가 추가되었습니다.</p>
<ul>
<li>Web Storage : 브라우저에 데이터를 저장하기 위한 공간으로, 쿠키와 비교했을 때 크기 제한과 유효 기간이 없고, 데이터가 서버로 전송되지 않으며, JavaScript 객체를 저장할 수 있다는 장점을 가지고 있습니다.</li>
<li>Web SQL Database/Indexed Database : Web SQL Database와 Indexed Database API는 클라이언트(웹 브라우저)에서 관리되는 데이터베이스를 제어할 수 있는 API로 구성되어 있습니다.</li>
<li>Application Cache : Application Cache는 웹 애플리케이션을 오프라인에서 사용하는 데 필요한 리소스(HTML, CSS, JS, 이미지 등)를 클라이언트 쪽에 캐시하기 위한 기능으로, 이를 활용하면 리소스가 로컬에 캐시된 상태에서 웹브라우저가 네트워크에 접속하지 않고 캐시된 리소스를 이용할 수 있습니다.</li>
</ul>
<p><strong>실시간 커뮤니케이션 API</strong></p>
<ul>
<li>Web Workers : Web Workers는 메인 스레드(UI)와 독립적인 백그라운드 프로세스로 처리되는 스크립트를 말하며, 이를 활용하면 웹브라우저 내에서 자바스크립트로 멀티스레드 프로그램을 구현할 수 있습니다.</li>
<li>Web Socket : Web Socket은 웹 브라우저와 서버 간 양방향 전이중 통신(Full Duplex)을 구현한 Web Socket 프로토콜을 이용할 수 있는 API 입니다.</li>
<li>Notifications : Notifications API는 운영 체제에 독립적인 플랫폼 수준의 알림 메시지를 보여주는 API 입니다.</li>
</ul>
<p><strong>파일/하드웨어 접근 API</strong></p>
<p>웹브라우저에서 로컬 저장 장치 간 파일을 주고받을 수 있는 API와 웹 브라우저가 설치된 단말기의 하드웨어에 접근할 수 있는 API 입니다.</p>
<ul>
<li>File API(Desktop Drag-In, Desktop Drag-Out) : File API를 이용하면 로컬 파일 시스템과 웹 브라우저 간에 파일을 주고받을 수 있습니다.</li>
<li>Geolocation : Geolocation은 웹 브라우저가 설치되어 있는 단말기(데스크톱, 스마트폰 등)의 GPS 장치를 구동하여 현재 위치 정보를 받아오는 기능을 정의한 API 입니다.</li>
<li>Device Orientation : Device Orientation은 단말기의 센서를 이용하여 현재 방향과 기울기가 같은 정보를 구할 수 있는 API 입니다.</li>
<li>Speech Input : Speech Input은 단말기의 마이크로폰을 이용하여 음성을 입력받은 후 이를 문자로 바꿔주는 새로운 입력 방식입니다.</li>
</ul>
<p><strong>GUI를 위한 API</strong></p>
<ul>
<li>Drag &amp; Drop : HTML4.01에서는 Drag &amp; Drop을 구현하기 위해 직접 자바스크립트로 개발하거나 UI 관련 자바스크립트 라이브러리를 이용해야 했지만, HTML5에서는 Drag &amp; Drop API를 이용하여 쉽게 구현할 수 있습니다.</li>
</ul>
]]></content>
      <tags>
        <tag>HTML콘텐츠 모델과 다양한에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>let과 const 블록 레벨스코프</title>
    <url>/2020/05/09/letconst-md/</url>
    <content><![CDATA[<h1 id="1-var키워드로-선언한-변수의-문제점"><a href="#1-var키워드로-선언한-변수의-문제점" class="headerlink" title="1. var키워드로 선언한 변수의 문제점"></a>1. var키워드로 선언한 변수의 문제점</h1><h2 id="1-1-변수-중복-선언이-가능"><a href="#1-1-변수-중복-선언이-가능" class="headerlink" title="1.1.변수 중복 선언이 가능"></a>1.1.변수 중복 선언이 가능</h2><p>-변수의 중복 선언이 가능하고,이때문에 의도치 않은 값의 변경이 일어나는 부작용이 발생한다.</p>
<h2 id="1-2-함수레벨-스코프"><a href="#1-2-함수레벨-스코프" class="headerlink" title="1.2, 함수레벨 스코프"></a>1.2, 함수레벨 스코프</h2><p>var키워드로 선언한 변수는 오로지 함수의 코드블록만을 지역스코프로 인정한다. 따라서 외부에서 선언한 변수는 모두 전역변수가 된다. 함수레벨 스코프는 전역변수를 남발할 가능성이 높다. 이로인해 의도치 않은 전역변수가 중복되는 경우가 발생한다.</p>
<h2 id="1-3-변수의-호이스팅"><a href="#1-3-변수의-호이스팅" class="headerlink" title="1.3. 변수의 호이스팅"></a>1.3. 변수의 호이스팅</h2><p>변수ㅣ 호이스팅에 의해 선언문이 스코프를 선두로 끌어 올려진것 처럼 동작한다. 즉 변수 호이스팅에 의해 var키워드로 선언한 변수는 변수 선언문 이전에 참조할 수있다. 단 할당문 이전에 변수를  참조하면 언제나 undefined를 반환한다. 변수호이스팅은 가독성을 떨어뜨리고 오류를 발생시킬 수있는 여지를 만든다.</p>
<hr>

<h1 id="2-let키워드"><a href="#2-let키워드" class="headerlink" title="2.let키워드"></a>2.let키워드</h1><p>let은 키워드는 var키워드와 동일하게 변수를 선언할때 사용한다. var키워드와의 차이점은</p>
<h2 id="2-1-변수의-중복선언-금지"><a href="#2-1-변수의-중복선언-금지" class="headerlink" title="2.1. 변수의 중복선언 금지"></a>2.1. 변수의 중복선언 금지</h2><p>var 키워드로 선언한 변수를 중복선언하면 에러가 발생하지 않고 덮어씌어진다. 하지만 let키워드로 동일한 이름을 갖는 변수를 중복선언하면 문법에러가 발생한다.<br> let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.</p>
<h2 id="2-2-블록-레벨-스코프"><a href="#2-2-블록-레벨-스코프" class="headerlink" title="2.2. 블록 레벨 스코프"></a>2.2. 블록 레벨 스코프</h2><p>var키워드롤 선언한 변수는 오로지 함수의코드블록을 지역변수로 인정하는 함수레벨 스코프를 따랐다. 하지만 let 키워드로 선언한 변수는 모든 코드블록에(if/for/while/try/catch)을 지역 스코프로 인정하는 블록레벨 스코프를 따른다.</p>
<p>함수도 코드블록이므로 스코프를 만든다. 이때 함수 내의 코드 블록은 함수레벨 스코프에 중첩된다.</p>
<h2 id="2-3-변수의-호이스팅"><a href="#2-3-변수의-호이스팅" class="headerlink" title="2.3. 변수의 호이스팅"></a>2.3. 변수의 호이스팅</h2><p>var키워드와는 달리 let키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는것 처럼 동작한다.<br> var 키워드를 사용해 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해서 암묵적으로 선언단계와 초기화 단계를 한번에 진행한다.<br>그러나 let  키워드를 사용해 선언한 변수는 자바스크립트엔진이 선언단계와 초기화 단계가 분리되어 실행된다. 즉 런타임 이전에 자바스크립트 엔진에 의해서 암묵적으로 선언단계가 실행되지만 초기화단계는 변수선언문에 도달했을때 실행된다.<br>스코프의 시작지점부터 초기화 시작 지점까지의 구간을 <strong>일시적 사각사각지대</strong>라고 한다.<br>자바스크립트에 도입된 모든 선언들은 호이스팅한다.(var.let,const,function,class)</p>
<h2 id="2-4-전역객체와-let"><a href="#2-4-전역객체와-let" class="headerlink" title="2.4. 전역객체와  let"></a>2.4. 전역객체와  let</h2><p>전역객체는 어떤 객체보다도 먼저 생성되어 어떤객체에도 속하지 않은 최상위 객체이다. 일반적으로 브라우저 환경에서는 window객체,node.js환경에서는 global객체를 의미한다.<br>var키워드로 선언한 전역변수와 선언하지 않은 변수에 전역값을 할당하는 암묵적 번역변수 그리고 전역함수는 정겨 객체릐 프로퍼티가 된다. 전역깩체의 프로퍼티를 참조할때 window응 생략 할 수있따.</p>
<p><strong>let키워드로 선언한 전역변수는 전역객체 window의 프로퍼티가 아니다</strong>. <strong>즉window.foo와 같이 접근 할 수없다.</strong>let전역변수는 보이지 않는 개념적인 블록내에 존재 하게 된다.</p>
<hr>

<h1 id="3-const키워드"><a href="#3-const키워드" class="headerlink" title="3. const키워드"></a>3. const키워드</h1><p>const키워드는 상수(변하지 않는 고정된 값)를 선언하기 위해 사용한다. 하지만 반드시 상수 만을 위해 사용하지 않는다. </p>
<h2 id="3-1-선언과-초기화"><a href="#3-1-선언과-초기화" class="headerlink" title="3.1 선언과 초기화"></a>3.1 선언과 초기화</h2><p>let키워들 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할다잉 금지된다. const키워드로 선언한 변수는 값을 변경,재할당 할 수 없으므로 처음 할당한 갓을 그대로 유지한다. 따라서 변하지 않는 고정된 값,상수를 할당하기 위해사용한다.</p>
<p>cost키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야한다.그렇지 않으면 문법적인 에러가 발생한다.</p>
<p>const키워드로 let키워드와ㅏ 마찬가지로 블록 레벨 스코프를 가진다.</p>
<h2 id="3-2-상수"><a href="#3-2-상수" class="headerlink" title="3.2. 상수"></a>3.2. 상수</h2><p>상수는 가독성과 유지보수의 편의를 위해 적극적으로 사용해야한다.</p>
<p>상수를 값으로 갖는 변수는 일반적으로 변수이름을 대문자로 선언하고 상수가 저장되어있음을 명확하게 나타낸다. 여러 단어로 이루어진 경우 _로 구분을 하는 것이 일반적이다.</p>
<h2 id="3-3-const키워드와-객체"><a href="#3-3-const키워드와-객체" class="headerlink" title="3.3. const키워드와 객체"></a>3.3. const키워드와 객체</h2><p>const키워드로 선언된 변수는 재할당이 금지된다. const키워드로 선언된 변수에 원시값을 할당한 경우,원시값은 변경할 수 없는 값이고,const키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.</p>
<p>const키워드로 선언한 변수에 깩체를 할당하는 경우, 원시값을 할당한 경우와 마찬가지로 재할당이 금지된다. 그러나 객체는 변경가능한 값이다.따라서 const 키워드로 선언된 변수에 할당된 객체는 변경이 가능하다.</p>
<p>const키워드는 재할당을 금지할뿐 불변을 의미하지 않는다. 새로운 객체를 재할당하는 것은 불가능하지만 객체의 내용을 변경하는 것은 가능하다.객체의 내용이 변경되더라도 변수에 할당된 주소값은 변경되지않는다.</p>
<hr>

<h1 id="4-var-대-let-대-const"><a href="#4-var-대-let-대-const" class="headerlink" title="4. var 대 let 대 const"></a>4. var 대 let 대 const</h1><p>변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해서 사용하는 것이 좋다. 원시값의 경우,가급적 상수를 사용하는 것이 좋다. 그리고 객체를 재할당하는 경우는 생각보다 흔하지않다. const 키워드를 사용하면 의도치 않은 재할당을 방지해주기때문이다.</p>
<p>es6에서는 var을 사용하지않는다.<br>재할당이 필요한경우에는 한정해 letd을 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.<br>변경이 발생하지않는(재할당이 필요없는 상수)원시값과 객체에는 const키워드를 사용한다. const키워드는 재할당을 금지하므로 var,let보다 안전하다.</p>
<p>변수를 선언하는 시점에는 재할다잉 필요할지 잘 모르는 경우가 많다. 그리고 객체는 의외로 재할당하는 경우가 드물다. 따라서 변수를 선언할때 일단 const 키워드로 사용하도록하자 .반드시 재할당이 필요하다면 그때 const를 let으로 변경하면 된다.</p>
]]></content>
      <tags>
        <tag>let과 const 블록레벨 스코프에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>객체 리터럴</title>
    <url>/2020/05/21/objectliteral-md/</url>
    <content><![CDATA[<h1 id="1-객체란"><a href="#1-객체란" class="headerlink" title="1. 객체란?"></a>1. 객체란?</h1><p>자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 모든 것이 객체이다. 원시값을 제외한 나머지(힘수,배열,정규표현식 등) 은 모두 객체이다.</p>
<p>원시 타입은 단하나의 값만을 나타내지만 객체 타입은 다양한 타입의 값들을 하나의 단위로 구성한 복합적인 자료구조이다. 또한 원시타입의 값, 즉 <strong>원시값은 변경 불가능한 값이지만 객체 타입의 값, 즉 객체는 변경이 가능한 값이다.</strong><br>객체는 0 개 이상의 프로퍼티의 집합으로 프로퍼티의 키는 값으로 구성된다.<br><img src="https://poiemaweb.com/assets/fs-images/10-1.png" alt="10-1"></p>
<p>자바스크립트에서 사용할 수 있는 모든값은 프로퍼티 값이 될 수 있다. 자바스크립트의 함수는 일급객체이므로 값으로 취급할 수 있다. 따라서 함수도 프로퍼티의 값으로 사용 할 수 있다. <strong>프로퍼티의 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드라고 부른다.</strong></p>
<p><img src="https://poiemaweb.com/assets/fs-images/10-2.png" alt="10-2"></p>
<p>이 처럼 객체는 프로퍼티와 메소드로 구성된 집합체 이다. 프로퍼티와 메소드의 역할은 다음과 같다.</p>
<ol>
<li>프로퍼티 : 객체의 상태를 나타내는 값</li>
<li>메소드 : 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작</li>
</ol>
<p>이와 같이 객체는 객체의 상태를 나타내는 값(프로퍼티)와 프로퍼티를 참조 하고 동작(메소드)를 모두 포함하기 때문에 상태 와 동작을 하나의 단위로 구조화할 수있어 유용하다.</p>
<p>객체와 함수 - 자바스크립트의 객체는 함수와 밀접한 관계를 갖는다. 함수로 객체를 생성하기도 하며 함수 자체가 객체이다. 자바스크립트에서 함수와 객체는 분리해서 생각할 수없는 개념이다. 즉 객체를 이해해야 함수를 제대로 이해할 수 있고 반대로 함수를 이해해야 객체를 정확히 이해 할 수 있다.</p>
<p>객체들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 <strong>객체 지향 프로그래밍이라고한다.</strong></p>
<h1 id="2-객체-리터럴에-의한-객체-생성"><a href="#2-객체-리터럴에-의한-객체-생성" class="headerlink" title="2. 객체 리터럴에 의한 객체 생성"></a>2. 객체 리터럴에 의한 객체 생성</h1><p>C++,JAVA와 같은 클래스 기반의 언어는 클래스를 사전에 정의하고 필요한 시점에서 new 연산자와 함게 생성자(constructor)를 호출하여 인스턴스를 생성하는 방시긍로 객체를 생성한다.</p>
<p>인스턴스 - 인스턴스란 클래스에 의해 생성되어 메모리에 저장된 실페를 의미한다. 객체 지향 프로그래밍에서 객체는 클래스 와 인스턴스를 포함하는 개념이다.  틀래스는 인스턴스를 생성하기 위한 템플릿의 역할 을 한다. 인스턴스는 객체가 메모리에 저장되어 실제로 존재하는것에 초접을 맞춘 용어이다.</p>
<p> 하지만 자바크립트는 프로토 타입기반의 객체 지향 언어로서 클래스 기반 객체 지향 언어와는 다름 객체 생성 방법이 존재한다.</p>
<ol>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create메소드</li>
<li>클래스(Es6)</li>
</ol>
<p>위 객체 생성 방법 중에서 가장 일반적이로 간단한 방법은 객체 리터럴을 사용하는 방법이다. 리터럴은 사람이 이해 할 수인는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기법을 말한다. 객체를 생성하기 위한 표기법이다.</p>
<p>객체 리터럴은 중괄호({..})내에 0 개 이상의 프로퍼티를 정의한다. 변수에 할당이 이루어지는 자바스크립트 엔진은 객체 리터럴을 해석하여 객체를 생성한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span> person =&#123;</span><br><span class="line">    name:<span class="string">'lee'</span>,</span><br><span class="line">    sayHello:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hello May name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> person) <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123;name:'lee',sayHello:f&#125;</span></span><br></pre></td></tr></table></figure>

<p>만약 중괄호 내에 프로퍼티를 정의하지 않으면 빈객체를 생성한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> empty = &#123;&#125; <span class="comment">//빈객체</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> empty) <span class="comment">//object</span></span><br></pre></td></tr></table></figure>

<p>객체 리터럴의 중괄호는 코드블록을 의미하지않음에 주의하자. 코드 블록의 닫는 중괄호 뒤에는 세미콜론을 붙이지 않는다.하지만 객체 리터럴은 값으로 평가되는 표현식이다. 따라서 객체 리터럴의 중괄호 뒤에는 세미콜론을 닫는다.</p>
<p>객체 리터럴은 자바스크립트의 유연함과 강력함을 대표하는 객체 생성 방식이다. 객체를ㄹ 생성하기 위해서 클래스를 먼저 정의하고 new연산자와 함께  생성자를 호출할 필요가 없다. 숫자 값이나 문자열을 만드는 것과 유사하게 리터럴로 객체를 생성한다. 객체 리터럴에 프로퍼티를 포함시켜 객체의 생성과 동시에 프로퍼티를 만들수도 있고 객체를 생성한 이후에 프로퍼티를 동적으로 추가 할 수 도 있다.</p>
<p>객체 리터럴 이외의 객체 생성 방식은 모두 함수를 사용해 객체를 생성한다. </p>
<h1 id="3-프로퍼티"><a href="#3-프로퍼티" class="headerlink" title="3. 프로퍼티"></a>3. 프로퍼티</h1><p>객체는 프로퍼티들의 집하빙며 프로퍼티는 키와 갑승로 구성된다. 프로퍼티를 나열할 때는 쉼표로 구분응ㄹ 한다. 일반적으로 마지만 프로퍼티 뒤에는  쉽표를 사용하지않으나 사용해도 좋다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person =&#123;</span><br><span class="line">  <span class="comment">//프로퍼티 키는 name,프로퍼티 값은 'lee'</span></span><br><span class="line">  name:<span class="string">'lee'</span>,</span><br><span class="line">  age:<span class="number">36</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>프로퍼티 키와 프로퍼티 값으로 사용할 수 있는 값은 다음과 같다.</p>
<p> 프로퍼티 키 : 빈 문자열을 포함하는 모든 문자열 또는 Symbol값</p>
<p>프로퍼티 값 : 자바스크립트에서 사용할 수 있는 모든값</p>
<p>프로퍼티 키는 프로퍼티 값에 접근할 수 있는 이름으로 식별자 역할을 한다. 하지만 반드시 네이밍 규칙을 따라야하는 것은 아니다. 단 식별자 네이밍 규칙을 준수하는 프로퍼티와 그렇지 않은 프로퍼티 키는 미묘한 차이가 있다.</p>
<p>Symbol값도 프로퍼티 키로 사용할 수 있지만 일반적으로 문자열을 사용한다. 이때 프로퍼티 키는 문자열이므로 따옴표로 묶어야한다. 하지만 식별자 네이밍 규칙을 준수하는 이름,자바스크립트에서 사용 가능한 유효한 이름인 경우, 따옴표를 생략할 수 있다. 반대로 말하면 식별자 네이밍 규칙을 따르지 않아도 이름에는 반드시 다롬표를 사용해야한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">'kim'</span>, <span class="comment">// 식별자 네이밍 규칙을 준수하는 프로퍼티 키</span></span><br><span class="line">  <span class="string">'last-name'</span>: <span class="string">'Lee'</span>   <span class="comment">// 식별자 네이밍 규칙을 준수하지 않는 프로퍼티 키</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person); <span class="comment">// &#123;firstName: "Ung-mo", last-name: "Lee"&#125;</span></span><br></pre></td></tr></table></figure>

<p>프로퍼티 키로 사용한 firstName은 식별자 네이밍 규칙을 준수하고 있다. 따라서 따옴표를 생략할 수 있다. 하지만 last-name은 식별자 네이미 규칙을 준수하고 있지 않다. 따라서 따옴표를 생략 할 수 없다. 자바스크립트 엔진은 따옴표를 생략한 last-name을 연산자가 있는 표현식으로 해석한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  firstName: <span class="string">'kim'</span>,</span><br><span class="line">  last-name: <span class="string">'Lee'</span> <span class="comment">// SyntaxError: Unexpected token -</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>문자열 또는 문자열오 평가 할 수있는 표현식을 사용해 프로퍼티 키를 독적으로 생성할 수 있다. 프로퍼티 키로 사용할 표현식을 대괄호로 묶어야한다. 이를 계산된 프로퍼티 이름이라고 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> key =<span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5: 프로퍼티 키 동적 생성</span></span><br><span class="line">obj[key] =<span class="string">'world'</span>;</span><br><span class="line"><span class="comment">// ES6: 프로퍼티 키 동적 생성</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;[key]:<span class="string">'world'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj) <span class="comment">//&#123;hello : 'world'&#125;;</span></span><br></pre></td></tr></table></figure>

<p>빈 문자열을 프로퍼티 키로 사용해도 에러가 발생하지않는다. 하지만 키로서의 의미를 갖지 못하므로 권장하지않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo =&#123;</span><br><span class="line">  <span class="string">''</span>:<span class="string">''</span> <span class="comment">//빈 문자열도 프로퍼티 킬 사용할 숭 ㅆ다.</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">//&#123;'':''&#125;</span></span><br></pre></td></tr></table></figure>

<p>프로퍼티 키에 문자열이나 symbol값 이외의 값을 사용하면 타입변환을 통해 문자열이 된다. 예를 들어 , 프로퍼티 키로 숫자 리터럴을 사용하면 따옴표는 붙지않지만 내부적으로 문자열로 변환된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo =&#123;</span><br><span class="line">  <span class="number">0</span>:<span class="number">1</span>,</span><br><span class="line">  <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="number">2</span>:<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">//&#123;0: 1, 1: 2, 2: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>var,fuction와 같은 예약어를 프로퍼티키로 사용해도 에러가 발생하지 않는다. 하지만 예상못한 에러가 발생시킬 여지가 있으며 권장하지않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo =&#123;</span><br><span class="line">  <span class="keyword">var</span> :<span class="string">''</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>:''</span></span><br><span class="line"><span class="function">&#125;;</span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(<span class="params">foo</span>) // </span>&#123;<span class="keyword">var</span> :<span class="string">''</span>,<span class="attr">function</span> : <span class="string">''</span>&#125;</span><br></pre></td></tr></table></figure>

<p>이미 존재하는 프로퍼티 키를 중복 선언하면 나중에 선언한 프로퍼티를  덮어쓴다. 이때 에러가 발생하지않 것에 주의하자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo =&#123;</span><br><span class="line">  name:<span class="string">'lee'</span>,</span><br><span class="line">  name;<span class="string">'kim'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">//&#123;name: 'kim'&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="4-메소드"><a href="#4-메소드" class="headerlink" title="4. 메소드"></a>4. 메소드</h1><p>자바스크립트에서 사용할 수있는 모든 값은 프로퍼티 값으로 사용할 수 있다고 했다. 자바스크리븥 함수를 일급객체이다. 따라서 함수는 값으로 취급할 수 있기 때문에 프로퍼티 값으로 사용할 수 있다.</p>
<p>프로퍼티 값이 함수 일 경우 , 일반함수와 구분하기 위해 메소드 라고 부른다. 즉 메소드는 객체에 제한되어 있는 함수를 말한다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> circle =&#123;</span><br><span class="line">  radisus:<span class="number">5</span>,</span><br><span class="line">  getDiameter:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//메소드</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radisus <span class="comment">// this는 circle을 가리킨다</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(circle.getDiameter());  <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<p>메소드 내부에서 사용한 this키워드는 객체 자신을 가리키는 참조변수이다. </p>
<h1 id="5-프로퍼티-접근"><a href="#5-프로퍼티-접근" class="headerlink" title="5. 프로퍼티 접근"></a>5. 프로퍼티 접근</h1><p>프로퍼티 값에 접근하려면 마침표 연산자를 사용하는 마침표 표기법 또는 대괄호 연산자를 사용하는 대괄호 표기법을 사용한다. 프로퍼티 키가 식별자 네이밍 규칙을 준수하는 이름, 자바스크립트에서 사용 가능한 이름이면 마침표 표기법과 대괄호 표기법 모두 사용 할 수 있다. 마침표 연산자 또는 대괄호 연산자의 좌측에는 객체로 평가 되는 표현식을 기술한다. 마침표 연산자의 우측 또는 대괄효 연산자의 내부에는 프로퍼티 키를 지정한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person =&#123;</span><br><span class="line">  name;<span class="string">'lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//마침표 표기법에 의한 프로퍼티 접근 </span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// lee</span></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">'name'</span>]) <span class="comment">//lee</span></span><br></pre></td></tr></table></figure>

<p>대괄호 표기법을 사용하는 경우 , 대괄호 연산자 내부에 지정하는 프로퍼티 키는 반드시 따옴표로 감싼 문자열이어야한다. 대괄호 연산자 내의 따옴표로 감사지않은 이름을 프로퍼티 키로 사용하면 자바스크립트 엔진은 식별자로 해석한디.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[name]); <span class="comment">// ReferenceError: name is not defined</span></span><br></pre></td></tr></table></figure>

<p>ReferenceError가 발생한 이유는 대괄호 연산자 내의 따옴표로 감싸지 않은 이름, 즉 식별자 name을 평가하기 위해 선언된 name을 찾았지만 찾지못했기 때문이다.<br>객체에는 존재하징낳는 프로퍼티에 접근을 하면 undefined을 반환한다. 이때 ReferenceError가 발생하지 않는 것에 주의 하자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">'Lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>프로퍼티 키가 식별자 네이밍 규칙을 준수하지 않는 이름 , 즉 자바스크립트에서 사용 가능한 유효한 이름이 아니면 반드시 대괄호 표기법은 사용해야 한다. 단 , 프로퍼티가 숫자로 이루어진 문자열인 경우 ,따옴표를 생략 할 수 있다. 드 외의 경우 , 대괄호 내에 들어가는 플포티 키는 반드시 따옴표로 감산 문자열이어야함을 잊지 않도록하자</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="string">'last-name'</span>: <span class="string">'Lee'</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="number">10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="string">'last-name'</span>;  <span class="comment">// -&gt; SyntaxError: Unexpected string</span></span><br><span class="line">person.last-name;    <span class="comment">// -&gt; 브라우저 환경: NaN</span></span><br><span class="line">                     <span class="comment">// -&gt; Node.js 환경: ReferenceError: name is not defined</span></span><br><span class="line">person[last-name];   <span class="comment">// -&gt; ReferenceError: last is not defined</span></span><br><span class="line">person[<span class="string">'last-name'</span>]; <span class="comment">// -&gt; Lee</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 키가 숫자로 이루어진 문자열인 경우, 따옴표를 생략 가능하다.</span></span><br><span class="line">person<span class="number">.1</span>;     <span class="comment">// -&gt; SyntaxError: Unexpected number</span></span><br><span class="line">person.<span class="string">'1'</span>;   <span class="comment">// -&gt; SyntaxError: Unexpected string</span></span><br><span class="line">person[<span class="number">1</span>];    <span class="comment">// -&gt; 10 : person[1] -&gt; person['1']</span></span><br><span class="line">person[<span class="string">'1'</span>];  <span class="comment">// -&gt; 10</span></span><br></pre></td></tr></table></figure>

<p>여기서 퀴즈를 하나 풀어보자. 위 예제에서 <code>person.last-name</code>의 실행 결과는 Node.js 환경에서 ReferenceError: name is not defined이고 브라우저 환경에서는 NaN이다. 이유는 무엇인가?</p>
<p>자바스크립트 엔진은 먼저 person.last를 평가한다. 평가 결과는 undefined이다. person 객체에는 프로퍼티 키가 last인 프로퍼티가 없기 때문이다. 따라서 <code>person.last-name</code>는 <code>undefined - name</code>과 같다. 다음으로 자바스크립트 엔진은 name이라는 식별자를 찾는다. 이때 name은 프로퍼티 키가 아니라 식별자로 해석되는 것에 주의하자.</p>
<p>Node.js 환경에서는 현재 어디에도 name이라는 식별자(변수, 함수 등의 이름) 선언이 없으므로 ReferenceError: name is not defined이라고 에러가 발생한다. 그런데 그런데 브라우저 환경에서는 name이라는 전역 변수(전역 객체 window의 프로퍼티)가 암묵적으로 존재한다. 전역 변수 name은 창(window)의 이름을 가리키며 기본값은 빈 문자열이다. 따라서 <code>person.last-name</code>는 <code>undefined - &#39;&#39;</code>과 같으므로 NaN이 된다.  </p>
<h1 id="6-프로퍼티-값-갱신"><a href="#6-프로퍼티-값-갱신" class="headerlink" title="6. 프로퍼티 값 갱신"></a>6. 프로퍼티 값 갱신</h1><p>이미 존재하는 프로퍼티에 값을 할당하면 프로퍼티 값이 갱신된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person =&#123;</span><br><span class="line">  name;<span class="string">'lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//person 객체에 name 프로퍼티가 존재 하므로 name 프로퍼티의 값이 갱신된다.</span></span><br><span class="line">person.name = <span class="string">'kim'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">//&#123;name:'kim'&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="7-프로퍼티의-동적-생성"><a href="#7-프로퍼티의-동적-생성" class="headerlink" title="7.프로퍼티의 동적 생성"></a>7.프로퍼티의 동적 생성</h1><p>존재하지 않는 프로퍼티에 값을 할당하면 프로퍼티가 동적으로 생성되어 추가되고 프로퍼티 값이 할당된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person =&#123;</span><br><span class="line">  name:<span class="string">'lee'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//person 객체에는 age라는 프로퍼티가 존해하지 않는다.</span></span><br><span class="line"><span class="comment">//따라서 person 객체에 age 프로퍼티가 동적으로 생성되고 값이 할당 된다.</span></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">//&#123;name:'lee',age:20&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="8-프로퍼티-삭제"><a href="#8-프로퍼티-삭제" class="headerlink" title="8. 프로퍼티 삭제"></a>8. 프로퍼티 삭제</h1><p>delete 연산자는 객체의 프로퍼티를 삭제한다. 이때  delete연산자의 피연산자는 프로퍼티 값에 접근 할 수 있는 표현식이어야한다. 만약 존재하지 않는 프로퍼티를 삭제하면 아무런 에러없이 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person =&#123;</span><br><span class="line">  name:<span class="string">'lee'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//프로퍼티 동적 생성</span></span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person 객체에 age 프로퍼티가 존재한다.</span></span><br><span class="line"><span class="comment">//따라서 delete 연산자로 age 프로퍼티를 삭제 할 수 있다.</span></span><br><span class="line"><span class="keyword">delete</span> person.age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//person 객체에 address 프로퍼티가 존재하지 않는다.</span></span><br><span class="line"><span class="comment">//따라서 delete 연산자로 address 프러퍼티를 삭제 할 수없다 . 이때 에러가 발생하지 않는다.</span></span><br><span class="line"><span class="keyword">delete</span> person.address;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">//&#123;name: 'lee'&#125;;</span></span><br></pre></td></tr></table></figure>

<h1 id="9-ES6에서-추가된-객체-리터럴의-확장-기능"><a href="#9-ES6에서-추가된-객체-리터럴의-확장-기능" class="headerlink" title="9. ES6에서 추가된 객체 리터럴의 확장 기능"></a>9. ES6에서 추가된 객체 리터럴의 확장 기능</h1><p>ES6에서는 더욱 간편하고 표현력 있는 객체 리터럴의 확장 기능을 제공한다.</p>
<h2 id="9-1-프로퍼티-축약-표현"><a href="#9-1-프로퍼티-축약-표현" class="headerlink" title="9.1 프로퍼티 축약 표현"></a>9.1 프로퍼티 축약 표현</h2><p>객체 리터럴의 프로퍼티는 프로퍼티 키와 값으로 구성된다. 프로퍼티 변수에 할당된 값, 즉 식별자 표현식일 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  x: x,</span><br><span class="line">  y: y</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>ES6에서는 프로퍼티 값으로 변수를 사용하는 경우, 변수 이름과 프로퍼티 키가 동일한 이름일때 , 프로퍼티 키를 생략할  수 있다. 아때 프로퍼티 키는 변수 이름으로 자동 생성된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 축약 표현</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; x, y &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-2-프로퍼티-키의-동적-생성"><a href="#9-2-프로퍼티-키의-동적-생성" class="headerlink" title="9.2 프로퍼티 키의 동적 생성"></a>9.2 프로퍼티 키의 동적 생성</h2><p>문자열 또는 분자열로 변환 가능한 값을 반환하는 표현식을 사용해 프로퍼티 키를 생성 할 수 있다. 단, 프로퍼티 키를 사용할 표현식을 대괄호로 묶어야한다. 이를 계산된 프로퍼티 이름이라 한다.<br>ES5에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적으로 생성하려면 객체 리터럴 외부에서 대괄호 표기법을 사용해야한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> prefix = <span class="string">'prop'</span>;</span><br><span class="line"><span class="keyword">var</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj =&#123;&#125;;</span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">var</span> prefix = <span class="string">'prop'</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티 키 동적 생성</span></span><br><span class="line">obj[prefix + <span class="string">'-'</span> + ++i] = i;</span><br><span class="line">obj[prefix + <span class="string">'-'</span> + ++i] = i;</span><br><span class="line">obj[prefix + <span class="string">'-'</span> + ++i] = i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>ES6에서는 객체 리터럴 내부에서도 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> prefix = <span class="string">'prop'</span>;</span><br><span class="line"><span class="keyword">let</span> i =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">  [<span class="string">`<span class="subst">$&#123;prefix&#125;</span>-<span class="subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">  [<span class="string">`<span class="subst">$&#123;prefix&#125;</span>-<span class="subst">$&#123;++i&#125;</span>`</span>]: i,</span><br><span class="line">  [<span class="string">`<span class="subst">$&#123;prefix&#125;</span>-<span class="subst">$&#123;++i&#125;</span>`</span>]: i</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// &#123;prop-1: 1, prop-2: 2, prop-3: 3&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="9-3-메소드-축약-표현"><a href="#9-3-메소드-축약-표현" class="headerlink" title="9.3. 메소드 축약 표현"></a>9.3. 메소드 축약 표현</h2><p>ES5에서 메소드를 정의하려면 프로퍼티 값으로 함수를 할당한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">  name:<span class="string">'kim'</span>,</span><br><span class="line">  sayHello:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>+ <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.sayHello() <span class="comment">// 'hi kim';</span></span><br></pre></td></tr></table></figure>

<p>ES6에서는 메소드를 정의할 때, function 키워드를 생략한 축약 표현을 사용할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj =&#123;</span><br><span class="line">  name: <span class="string">'kim'</span>,</span><br><span class="line">  <span class="comment">//메소드 축약 표현</span></span><br><span class="line">  sayHello()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>+ <span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.sayHello() <span class="comment">// 'hi kim';</span></span><br></pre></td></tr></table></figure>

<p>ES6의 메소드 축약 표현을 정의된 메소드는 프로퍼티에 할당한 함수와 다르게 동작한다. </p>
]]></content>
      <tags>
        <tag>객체 리터럴에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>자바스크립트의 개발환경</title>
    <url>/2020/05/10/review3-md/</url>
    <content><![CDATA[<h2 id="1-자바스크립트-실행환경"><a href="#1-자바스크립트-실행환경" class="headerlink" title="1. 자바스크립트 실행환경"></a>1. 자바스크립트 실행환경</h2><hr>

<p>모든 브라우저는 자바스크립트를 해석하고 실행할 수 있는 자바스크립트 엔진을 내장하고 있다. node.js  또한 자바스크립트엔진을 내장하고 있으며, 자바스크립트는 nodejs 와 브라우저환경에서 실행 할 수 있다.<br>브라우저에서  자바스크립트의 목적은 html,css,자바스크립트를 실행하여 웹에 보여주는 것이 주된 목적이고,  node.js는 서버 개발 환경을 제공하는 목적을 가진다.<br>또한 모두 자바스크립트의 코어인 ECMAScript를 실행할 수 있지만 ECMAScript의 추가적으로 제공하는 기능은 호환 불가능하다.<br>브라우저에서는 DOM API를 기본적으로 제공하지만 , node.js 에서는 DOM API를 제공하지 않는다.</p>
<h2 id="2-웹"><a href="#2-웹" class="headerlink" title="2. 웹"></a>2. 웹</h2><hr>

<p>자바스크립트가 가장 많이 사용되는 분야는 웹페이지와 웹 애플리케이션이다. 웹 애플리케이션은 웹 브라우저 에서 html과css와 자바스크립트가  함께 실행된다.</p>
<p>웹 브라우저 환경을 고려할 때, 보다 효율적인 자바스크립트 프로그래밍이 가능하다.<br>자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리를 한다,html파서는 script태그를 만나면 자바 스크립트 코드를 실행하기 위해서 DOM생성 프로세스를 중지하고 자바 스크립트 엔진으로 제어권한을 넘긴다.제어 권한을 넘겨받은 자바 스크립트엔진은 script태그의 자바스크립트 파일을 파싱한다. </p>
<p>자바스크립트는 명시적인 컴파일러 단계를 거치지 않지만 인터프리터 언어의 장점인 동적기능지원을 살리면서 실행속도가 느리다는 단점을 극복한다.</p>
<p>head 요소 내부에 script 태그를 위치시키면 HTML 요소가 파싱되어 DOM 객체로 변환되기 이전에 자바스크립트가 실행된다. 따라서 body태그 아래에 script태그를 두는것이 바람직하다.</p>
<p><strong>async</strong> : 웹 페이지 파싱과 외부 스크립트 파일의 다운로드가 동시에 진행된다. 스크립트는 다운로드 완료직후 실행된다.<br><strong>defer</strong> : 웹페이지 파싱과 외부 스크립트 파일의 다운로드가 동시에 진행된다.스크립트는 웹페이지 파싱완료 직후 실행된다. 두개의 차이점은 스크립트의 실행 시점이다르다.</p>
<p> 어트리뷰트는 스크립트 로딩으로 인한 병목을 근본적으로 방지하기 위해서 html5부터 script태그에 추가되었다.</p>
<p>node.js는 클라이언트 사이드, 즉 웹 브라우저에서 동작하는 간단한 웹 애플리케이션은 브라우저만으로도 개발을 할 수 있다.<br>하지만 프로젝트의 규모가 커짐에 따라 React, jQuery와 같은 외부 라이브러리를 도입하거나 Babel, Webpack, ESLint 등 여러 가지 도구를 사용해야 할 필요가 있다. 이때 Node.js와 npm이 필요하다.</p>
]]></content>
      <tags>
        <tag>자바스크립트의 개발환경</tag>
      </tags>
  </entry>
  <entry>
    <title>클래스</title>
    <url>/2020/06/11/class-md/</url>
    <content><![CDATA[<p>자바스크립트는 프로토 타입의 객체 지향 언어이다.프로토타입기방의 객체 지향 언어는 클래스가 필요없는 객체 지향 프로그래밍 언이다. ES5에서는 class없이 생성자 함수와 프로토 타입을 통해 객체 지향언어의 상속을 구현할 수있다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//es5생성자 함수</span></span><br><span class="line"><span class="keyword">var</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//생성자 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//프로토타입의 메소드</span></span><br><span class="line">  Person.prototype.sayHello= <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//생성자 함수 반환</span></span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'kim'</span>);</span><br><span class="line">me.sayHello() <span class="comment">// Hello kim</span></span><br></pre></td></tr></table></figure>

<p>ES6에서는 클래스가 도입되었다.그러나 도입된 클래스는 프로토타입기반의 프로그래밍 언어를 버리고 새롭게  Java 나 C++ 같은 클래스 지향 객체를 제공하는 것이 아니다.  사실은 Es6의 클래스는 함수이면 기존의 프로토 타입 기반 패턴을 클래스 기반 패턴으로 사용할수있는 문법적 설탕이다.<br>클래스와 생성자 함수는 모두 프로토 타입 기반의 인스턴스를 생성하지만 정확히 동일하게 동작하지않는다. 클래스는 생성자 함수보다 엄격하며 생성자 ㅎ마수에서는 제공하지않는 기능도 제공한다.</p>
<p>클래스는 생성자 함수와 매우 유사하게 동작하지만 다음과 같은 차이가 있다.</p>
<ol>
<li>클래스는  new 연산자를 사용하지않고 호출하면 에러가 발생한다. </li>
<li>클래스는 상속을 지원하는 extends와  super 키워드를  제공한다. 하지만 생성자 함수는 extends와 super키워드를 사용하지 않는다.</li>
<li>클래스는 호이스팅이 발생하지 않는것 처럼 동작한다. 하지만 함수 선언문으로 정의된 생성자 함수는 호이스팅이 , 함수 표현식으로 정의한 생성자 함수는 변수 호이스팅이 발생한다.</li>
<li>클래스 내의 모든 코드에는 암묵적으로 strict모드가 지정되어 실행되며 strict모드를 해지 할 수 없다. 하지만 생성자 함수는 암묵적으로 strict모드가 지정 되지않는다.</li>
<li>클래스의 constructor, 프로토 타입의 메서드 ,정적 메서드는 모두 프로퍼티 어트리뷰트[[Enummerable]]의 값이 false이다. 다시말해 ,열거되지않는다.</li>
</ol>
<p>생성자 함수와 클래스는 프로토 타입 기반의 객체 지향을 구현 했다는 점에서 유사하다. 하지만 클래스는 생성자 함수를 기반으로한 객체 생성 방식보다 견고하고 명료하다.  클래스의 extend와super 키워드는 상속관계 구현을 보다 간결하고 명료하게 한다. </p>
<h1 id="1-클래스의-정의"><a href="#1-클래스의-정의" class="headerlink" title="1.클래스의 정의"></a>1.클래스의 정의</h1><p>클래스의 class키워드를 사용하여 정의한다. 클래스의 이름은 생성자 함수와 마찬가지로 파스칼케이스를 사용하는 것이 일반적이다.</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//클래스 선언문</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>일반적이지는 않지만 함수와 마찬가지로 표현식으로 정의할 수 있다. 이때 클래스는 함수와 마찬가지로 이름을 가질수도 ,않을수도 있다</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//익명 클래스의 표현식</span></span><br><span class="line"><span class="keyword">const</span> Person = <span class="class"><span class="keyword">class</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//기명 클래스이 표현식</span></span><br><span class="line"><span class="keyword">const</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>클래스를 표현식으로 정의할 수 있다는 것은 클래스가 값으로 사용할 수있는 일급객체라는 것을 의미한다. 즉 , 클래스는 길급객체로서 아래와 같은 특징을 가진다.</p>
<p>무명의 리터럴로 생성할 수 있다. 즉 런타임에 생성이 가능하다.<br>변수나 지료구조(객체, 배열)등에 저장 할 수 있다.<br>함수의 매개 변수에 전달 할 수있다.<br>함수의 반환값으로 사용할수있다.</p>
<p>좀더 자세히 말하면 클래스는 함수이다. 따라서 클래스를 값처럼 사용할 수있는 입급객체이다.  클래스의 몸체에는 0개이상의 메서드만 정의 할 수있다. 클래스의 몸체에서 정의 할 수 있는 메서드는 constructor(생성자 ), 프로토 타입 메서드 ,정적 메서드 3가지가 있다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//클래스이 선언문</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="comment">//생성자</span></span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="comment">//인스턴스 생성 및 초기화</span></span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">//name프로퍼티는 public이다.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//프로토타입 메서드</span></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//정적메서드</span></span><br><span class="line">  <span class="keyword">static</span> sayHi()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'kim'</span>);</span><br><span class="line"><span class="comment">// 인스턴스의 프로퍼티 참조</span></span><br><span class="line"><span class="built_in">console</span>.log(me.name); <span class="comment">// Lee</span></span><br><span class="line"><span class="comment">// 프로토타입 메서드 호출</span></span><br><span class="line">me.sayHello() <span class="comment">//</span></span><br><span class="line"><span class="comment">// 정적 메서드 호출</span></span><br><span class="line">Person.sayHi()</span><br></pre></td></tr></table></figure>

<p>클래스와 생성자 함수의 정의  방식은 형태적인 면에서 매우 유사하다. </p>
<p><img src="https://poiemaweb.com/assets/fs-images/25-1.png" alt="25-1"></p>
<h1 id="2-클래스의-호이스팅"><a href="#2-클래스의-호이스팅" class="headerlink" title="2.클래스의 호이스팅"></a>2.클래스의 호이스팅</h1><p>클래스는 함수로 평가된다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//클래스의 선언문</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person) <span class="comment">//function</span></span><br></pre></td></tr></table></figure>

<p>클래스 선언문으로 정의한 클래스는 함수 선언문 같이 소스코드를 평가 과정, 즉 런타임 이전에 먼저 평가되어 함수 객체를 생성한다. 이때 클래스가 평가 되어 생성된 함수 객체는 생성자 함수로서 호출할 수있는 함수 , 즉 constructor이다. 생성자 함수로서 호출할 수있는 함수 정의가 평가 되어 함수 객체를 생성하는 시점에 프로토 타입도 더불어 생성된다. 프로토 타입과 생성자 함수는 단독으로 존재 할 수 없고 , 언제나 쌍으로 존재하기 때문이다.</p>
<p>단, 클래스는 클래스 정의 이전에 참조 할 수 없다. <strong>즉 클래스 선언문은 호이스팅이 발생하지않는것 처럼 보인다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(Person);</span><br><span class="line"><span class="comment">// ReferenceError: Cannot access 'Person' before initialization</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 클래스 선언문</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="string">''</span>;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 호이스팅이 발생하지 않는다면 ''이 출력되어야 한다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(Person);</span><br><span class="line">  <span class="comment">// ReferenceError: Cannot access 'Person' before initialization</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 클래스 선언문</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>클래스 선언문도 변수 선언, 함수 정의와 마찬가지로 호이스팅이 발생한다. 단 클래스는 let,const 키워드로 선언한 변수 처럼 호이스팅된다. 따라서 클래스 선언문 이전에 일시적 사각지대 TDZD에 빠지기 때문에 호이스팅이 발생하지않는것 처럼 동작한다.</p>
<p>var, let, const, function, function*, class 키워드를 사용하여 선언된 모든 식별자는 호이스팅된다. 모든 선언문은 런타임 이전에 먼저 실행되기 때문이다.</p>
<h1 id="3-인스턴스의-생성"><a href="#3-인스턴스의-생성" class="headerlink" title="3.인스턴스의 생성"></a>3.인스턴스의 생성</h1><p>클래스는 생성자 함수이며 new연산자와 함께 호출되어 인스턴스를 생성한다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(me) <span class="comment">// Person&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>함수는 new 연산자의 사용 여부에 따라 일반 함수로 호출되거나 인스턴스 생성을 위한 함수로 호출되지만 인스턴스를 생성하는 것이 유일한 존재 이유이므로 반드시 new 연산자와 함께 호출해야한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//new 연산자 없이 호출하면 타입 에러가 발생한다.</span></span><br><span class="line"><span class="keyword">const</span> me = Person()</span><br><span class="line"><span class="comment">// TypeError: Class constructor Foo cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure>

<p>클래스 표현식으로 정의된 클래스의 경우 , 아래 예제와 같이 클래스를 가리키는 식별자(Person)을 사용해 인스턴스를 생성하지않고 기면 클래스 표현식의 클래스 이름을 사용해 인스턴스를 생성하면 에러가 발생한다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 표현식과 마찬가지로 클래스를 가리키는 식별자로 인스턴스를 생성해야 한다.</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 클래스 이름 MyClass는 함수와 동일하게 클래스 몸체 내부에서만 유효한 식별자이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(MyClass); <span class="comment">// ReferenceError: MyClass is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> you = <span class="keyword">new</span> MyClass(); <span class="comment">// ReferenceError: MyClass is not defined</span></span><br></pre></td></tr></table></figure>

<p>이는 기명 함수 표현식과 마찬가지로 크래스 표현식에서 사용한 틀래스 이름은 외부 코드에서 접근 불가능하기 때문이다.</p>
<h1 id="4-메서드"><a href="#4-메서드" class="headerlink" title="4. 메서드"></a>4. 메서드</h1><p>클래스의 몸체에는 0개 이상의 메서드 만을 선언할 수있다. 클래스 몸체에 정의 할 수 있는 메서드는 constructor(생성자),프로토 타입 메서드,정적메서드 3가지가있다.<br><strong>클래스의 정의에 대한 새로운 제안 사양</strong></p>
<p>현재 최신 ECMAScript 사양(ES10, ECMAScript 2019)에 따르면 <u>인스턴스 프로퍼티</u>는 반드시 constructor네부에서 정의해에 한다. 하지만 하지만 2020년 5월 현재, 클래스 몸체에 메서드 뿐만이 아니라 프로퍼티를 직접 정의할 수있는 새로운 사양이 제안되었다. 이 제안은 사양에 의해 머지않아 클래스 몸체에 프로퍼티를 정의할 수 있게 될것으로 보인다. (클래스 필드 정의 제안)</p>
<h2 id="4-1-constructor"><a href="#4-1-constructor" class="headerlink" title="4.1 constructor"></a>4.1 constructor</h2><p>constructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메서드이다. constructor라는 이름은 변경할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="comment">//생성자</span></span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="comment">//인스턴스 초기화</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>앞서 살펴본 바와 같이 클래스는 인스턴스를 생성하기 위한 생성자 함수이다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//클래스는 함수이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person) <span class="comment">// fucntion</span></span><br><span class="line"><span class="built_in">console</span>.dir(Person)</span><br></pre></td></tr></table></figure>

<p>console.dir의 실행 결과는 다음과 같다.</p>
<p><img src="https://poiemaweb.com/assets/fs-images/25-2.png" alt="25-2"></p>
<p>이처럼 클래스는 평가되어 함수 객체가 된다. 클래스도 함수 객체의 고유한 프로퍼티를 모두 가지고 있다. 함수와 동일하게 프로토타입과 연결되어 있으며 자신의 스코프 체인을 구성한다.</p>
<p>모든 함수가 객체가 가지고 있는 prototype 프로퍼티가 가리키는 객체의 constuctor 프로퍼티는 클래스 자신을 가리키고 있다. 이는 클래스가 인스턴스를 생성하는 생성자 함수라는 것을 의미한다. 즉 ,new 연산자와 함께 호출하면 클래스는 인스턴스를 생성한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'kim'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me)</span><br></pre></td></tr></table></figure>

<p>다음을 콘솔에 실행한 결과<br><img src="https://poiemaweb.com/assets/fs-images/25-3.png" alt="25-3" style="zoom:50%;"></p>
<p>Person클래스의 constructor 내부에서 thid에 추가한 name 프로퍼티가 틀래스가 생성한 인스턴스의 프로퍼티로 추가된 것을 확인할 수 있다. 즉 , 생성자 함수와 마찬가지로 constructor 내부에서 this에 추가한 프로퍼티는 인스턴스의 프로퍼티가 된다. constructor 내부의 this는 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스를 가리킨다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="comment">//생성자 </span></span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="comment">//인스턴스 생성 및 초기화</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//생성자 함수 </span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(name)&#123;</span><br><span class="line">  <span class="comment">//인스턴스 생성 및 초기화</span></span><br><span class="line">  <span class="keyword">this</span>,name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그런데 흥미로운 것은 클래스가 평가되어 생성된 함수 객체나 클래스가 생성한 인스턴스 어디에도 constructor 메서드가 보이지 않는다는 것이다. 이는 클래스 몸체에 정의한 constructor가 단순한 메서드가 아니라는 것을 의미한다. </p>
<p><strong>클래스의 constructor 메서드와 Person.prototype.constuctor</strong> - 이름은 같아 혼동 할 수 있으나 클래스 몸체에 정의한 constructor 와  Person.prototype.constructor는 직접적인 관련이 없다. 프로토타입의 constructor 프로퍼티는 모든 프로토타입이 가지고 있는 프로퍼티이며 생성자 함수를 가리킨다.</p>
<p>constructor는 메서드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다. 다시말해 , 클래스가 평가되면 constructor의 기술된 동작을 하는 함수 객체가 생성된다.<br>constructor 는 생성자 함수와 유사하지만 몇가지 차이가있다.<br> constructor 는 클래스 내에 최대한 한 개만 존재할 수 있다. 만약 클래스가 2개 이상의 constructor을 가지면 문법에러가 발생한다. </p>
<p><strong>constructor는 생략하면 클래스에  암묵적으로 정의된다.</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="comment">//constructor을 생략하면 아래와 같이 디폴트 constructor가 암묵적으로 정의된다.</span></span><br><span class="line">  <span class="keyword">constructor</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//빈객체가 생성된다.</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(me) <span class="comment">// Person&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>constructor을 생략한 클래스는 디폴트 constructor에 의해 빈객체를 생성한다. 프로퍼티가 추가되어 초기화된 인스턴스를 생성하려면 constructor 내부에서 this 프로퍼티를 추가 해야한다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="comment">//고정값으로 인스턴스 초기화</span></span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'kim'</span>;</span><br><span class="line">    <span class="keyword">this</span>.address =<span class="string">'Seoul'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//인스턴스 프로퍼티가 추가된다.</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(me) <span class="comment">// Person &#123;name: "Lee", address: "Seoul"&#125;</span></span><br></pre></td></tr></table></figure>

<p>인스턴스를 생성할때 , 클래스의 외부에서 인스턴스 프로퍼티의 초기값을 전달하려면 아래와 같이 constructor에 매개 변수를 선언하고 인스턴스를 생성할때 초기값을 전달한다. 이때 초기값은 constructor의 매개변수에게 전달된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name,address)&#123;</span><br><span class="line">    <span class="comment">//인수로 인스턴스 초기화</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.address =address;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//인수로 초기값을 전달한다/ 초기값은 constructor에 전달된다. </span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> person(<span class="string">'kim'</span>,<span class="string">'Seoul'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me) <span class="comment">//Person &#123;name: "Lee", address: "Seoul"&#125;</span></span><br></pre></td></tr></table></figure>

<p>이처럼 constructor내에선 인스턴스의 생성과 동시에 인스턴스 프로퍼티 추가를 통해 인스턴스의 초기화를 실행한다. 따라서 인스턴스를 초기화하려면 constructor를 생약해서는 안된다.</p>
<p>constructor는 별도의 반환문을 갖지않아야한다.  new 연산자와 함께 클래스가 호출되면 생성자 함수와 동일하게 암묵적으로 this,즉 인스턴스를 반환하기 때문이다.<br>만약 this가 아닌 다른 객체를 명시적으로 반환하면 this,즉 인스턴스가 반환되지 못하고 return 문에 명시한 객체가 반환된다.  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//명시적으로 객체를 반환하면 암묵적인 this반환이 무시된다.</span></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">cconst me = <span class="keyword">new</span> person(<span class="string">'kim'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me) <span class="comment">// &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>하지만 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'Lee'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// Person &#123; name: "Lee" &#125;</span></span><br></pre></td></tr></table></figure>

<p>이처럼 constructor 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 클래스의 기본 동작을 훼손한다. 따라서 <strong>constructor 내부에서 return 문을 반드시 생략해야 한다.</strong></p>
<h2 id="4-2-프로토-타입-메서드"><a href="#4-2-프로토-타입-메서드" class="headerlink" title="4.2 프로토 타입 메서드"></a>4.2 프로토 타입 메서드</h2><p>생성자 함수를 사용하여 인스턴스를 생성하는 경우, 프로포 타입 메서드를 생성하기 위해 명시적으로 프롶토 타입에 메서드를 추가해야한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//프로퍼 타입 메서드 </span></span><br><span class="line"> Person.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">`hi <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'kim'</span>);</span><br><span class="line">me.sayHi(); <span class="comment">// hi kim</span></span><br></pre></td></tr></table></figure>

<p>클래스 몸체에서 정의한 메서드는 생성자 함수에 의한 객체 생성 방식과 다르게 클래스이 prototypre 플퍼티에 메서드를 정의하지 않아도 기본적으로 프로토타입 메서드가 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="comment">//생성자</span></span><br><span class="line">   <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name;</span><br><span class="line">   &#125;</span><br><span class="line">  sayHi()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`hi <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'kim'</span>);</span><br><span class="line">me.sayHi() <span class="comment">// hi kim</span></span><br></pre></td></tr></table></figure>

<p>생성자 함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//me 객체의 프로토타입은 Person.prototype이다.</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(me) === Person.prototype; <span class="comment">//true;</span></span><br><span class="line">me <span class="keyword">instanceof</span> Person <span class="comment">// true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Person.prototype의 프로토타입은 Object.prototype이다.</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(Person.object) === <span class="built_in">Object</span>.prototype <span class="comment">//true;</span></span><br><span class="line">me <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//me 객체의 constructor는 Person 클래스이다.</span></span><br><span class="line">me.constructor === Person <span class="comment">//true;</span></span><br></pre></td></tr></table></figure>

<p>위의 예제는 다음과 같은 프로토 타입 체인을 생성한다.<br><img src="https://poiemaweb.com/assets/fs-images/25-4.png" alt="25-4"></p>
<p>이처럼 클래스 몸체에 정의한 메서드는 인스턴스의 프로토타입에 존재하는 프로토타입 메서드가 된다. 인스턴스는 프로토타입 메서드를 상속받아 사용할수있다. </p>
<p>프로토타입 체인은 기존의 모든 객체 생성방식(객체 리터럴,생성자 함수,Object.create 메서드 등)뿐만 아니라 클래스에 의해 생성된 인스턴스에도 동일하게 적용된다. 생성자함수의 역할을 클래스가 할 뿐이다.</p>
<p>결국 클래스는 생성자 함수와 같이 인스턴스를 생성하는 생성자 하뭇라고 볼 수있다. 다시말해 ,클래스는 생성자 함수와 마찬가지로 프로토 타입 기반의 객체 생성 매커니즘이다.</p>
<h2 id="4-3-정적메서드"><a href="#4-3-정적메서드" class="headerlink" title="4.3 정적메서드"></a>4.3 정적메서드</h2><p>정적메서드는 인스턴스를 생성하지않아도 호출할 수 있는 메서드를 말한다. 생성자 함수의 경에는 정적메서드를 생성하기 위해서 명시적으로 생성자 함수에 메서드를 추가해야한ㄷ. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//정적메서드</span></span><br><span class="line">Person.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//정적 메서드 호출</span></span><br><span class="line">Person.sayHi(); <span class="comment">// Hi</span></span><br></pre></td></tr></table></figure>

<p>클래스에서는 메소드 static 키워드를 붙이면 정적 메서드(클래스 메서드)가 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="comment">//생성자 </span></span><br><span class="line">  consturctor(name)&#123;</span><br><span class="line">    <span class="comment">//인스턴스 생성 및 초기화</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> sayHi()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hi'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제의 Person클래스는 아래와 같이 프로토타입 체인을 생성했다.</p>
<p><img src="https://poiemaweb.com/assets/fs-images/25-5.png" alt="25-5"></p>
<p>이처럼 정적메서드는 클래스 자신의 메서드가 된다. 클래스는 함수객체로 평가되므로 자신의 프로퍼티/메서드를 소유할 수있다. 클래스는 코드다 평가 되는 시점에 함수 객체가 되므로 별다른 생성 과정이 필요없다. 따라서 정적 메서드는 정의 이후 인스턴스를 생성하징낳아도 호출할수있다.</p>
<p>정적메서드는 프로토타입 메서드처럼 인스턴스로 호출하지않고 클래스로 호출한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//정적 메서드는 클래스로 호출한다. </span></span><br><span class="line"><span class="comment">//정적메서드는 인스턴스 없이도 호출할 수 있다. </span></span><br><span class="line">Person.sayHi(); <span class="comment">//Hi</span></span><br></pre></td></tr></table></figure>

<p>정적 메서드는 인스턴스로 호출할 수없다. 정적 메서드를 소유하는 클래스는 인스턴스의 프로포타입 체인 상에 존재 하지않기 때문이다. 다시말해 인스턴스의 프로토타입 체인상에는 클래스가 존재하지않기 때문에 인스턴스로 ㅌ클래스의 메서드를 상속받을수 없다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'kim'</span>);</span><br><span class="line">me.sayHi(); <span class="comment">//Hi kim</span></span><br></pre></td></tr></table></figure>

<h2 id="4-4-정적메서드와-프로토타입-메서드의-차이"><a href="#4-4-정적메서드와-프로토타입-메서드의-차이" class="headerlink" title="4.4 정적메서드와 프로토타입 메서드의 차이"></a>4.4 정적메서드와 프로토타입 메서드의 차이</h2><p>정적메서드와 프로토타입 메서드의 차이점</p>
<ol>
<li>정적메서드와 프로토타입 메서드는 자신이 속해있는 프로토타입 체인이다르다.</li>
<li>정적 메서드는 클래스로 호출하고 프로토타입 메서드는 인스턴스로 호출한다.</li>
<li>정적 메서드는 인스턴스 프로퍼티를 참조할 수없지만 프로토타입 메서드는 인스턴스 프로퍼티를 참조할 수 있다.</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span></span>&#123;</span><br><span class="line">  <span class="comment">//정적 메서드</span></span><br><span class="line">  <span class="keyword">static</span> area(width,height)&#123;</span><br><span class="line">    <span class="keyword">return</span> width * height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Square.area(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure>

<p>정적 메서드는 area는 2개의 인수를 전달 받아 면적을 계산한다. 이때 정적 메서드 area는 인스턴스 프로퍼티를 참조하지않는다. 만약 인스턴스 프로퍼티를 참조해야한면 정적메서드 대신 프로토타입 메서드를 사용해야한다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width,height)&#123;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//프로토 타입 메서드</span></span><br><span class="line">  area()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Square(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me.area()); <span class="comment">//100</span></span><br></pre></td></tr></table></figure>

<p>메서드 내부의 this는 메서드를 소유한 객체가 아니라 메서드를 호출한 객체, 즉 메서드 이름앞의 연산자 마침표 앞에 기술한 객체에 바인딩 된다. </p>
<p>프로토타입 메서드는 인스턴스로 호출해야 하므로 프로토타입 메서드 내부의 this는 프로토타입 메서드를 호출한 인스턴ㄴ스를 가리킨다. 위 예제의 경우 me객체로 프로토타입 메서드 area를 호출했기 때문에 area내부의  this는 me 객체를 가리킨다.</p>
<p>정적 메서드는 클래스로 호출해야하므로 정적메서드 내부의 this는 인스턴스가 아닌 클래스를 가리킨다. 즉 프로토타입 메서드와 정적 메서드 내부의this 바인딩이 다르다. </p>
<p>따라서 메서드 내붕에서 인스턴스 프로퍼티를 참조해야할 필요가 없다면 this 를 사용해야하며 이러한 경우, 프로토타입 메서드로 정의해야한다 하지만 메서드 내부에서 인스턴스 프로퍼티를 참조할 필요가 없다면 this을 사용하지 않게 된다.</p>
<p>물론 메서드 내부에서 this을 사용하지 않더라도 프로토타입 메서드로 정의 할 수 있다. 하지만 반드시 인스턴스를 생성한 다음 인스턴스로 호출해야하므로 this를 사용하지 않는 메서드는 정적 메서드로 정의하는 것이 좋다. </p>
<p>표준 빌트인 객체인 Math,Number,JSON,Object,Reflect 등은 다양하나 정적 메서드를 가지고 있다. 이들 정적 메서드는 애플리케이션 전역에서 사용할 유틸리티 함수이다. 예를 들어 , 전달 받은 인수 중에서 가장 큰수를 반환하는 정적 메서드는 Math.max는 인스턴스와 상관없이 애플리테이션 전역에서 사용할 유틸리티 함수이다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 표준 빌트인 객체의 정적 메서드</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);          <span class="comment">// -&gt; 3</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>);          <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">JSON</span>.stringify(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);   <span class="comment">// -&gt; "&#123;"a":1&#125;"</span></span><br><span class="line"><span class="built_in">Object</span>.is(&#123;&#125;, &#123;&#125;);          <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="built_in">Reflect</span>.has(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;, <span class="string">'a'</span>); <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p>이처럼 클래스 또는 생성자 함수를 하나의 네임 스페이스(Namespace <a href="https://poiemaweb.com/fastcampus/global-variable#32-네임-스페이스-객체" target="_blank" rel="noopener">“14.3.2. 네임 스페이스 객체”</a> 참고)로 사용하여 정적 메서드를 모아 놓으면 이름 충돌 가능성을 줄여 주고 관련있는 함수들을 구조화 할 수 있는 효과가 있다. 이와 같은 이유로 정적 메서드는 애플리케이션 전역에서 사용할 유틸리티 함수를 전역 함수로 정의하지 않고 메서드로 구조화할 때 유용하다.</p>
<ul>
<li><p>ES6에 추가된 표준 빌트인 객체 Number의 정적 메서드</p>
<p>ES6에서는 <a href="https://poiemaweb.com/fastcampus/built-in-object#42-빌트인-전역-함수" target="_blank" rel="noopener">“21.4.2. 빌트인 전역 함수”</a>에서 살펴본 isFinite, isNan, parseFloat, parsInt 등의 빌트인 전역 함수를 표준 빌트인 객체 Number의 정적 메서드로 추가 구현하였다. Number의 정적 메서드 isFinite, isNan, parseFloat, parsInt는 빌트인 전역 함수 isFinite, isNan, parseFloat, parsInt보다 엄격하다.</p>
</li>
</ul>
<h2 id="4-5-클래스에서-정의한-메서드-특징"><a href="#4-5-클래스에서-정의한-메서드-특징" class="headerlink" title="4.5 클래스에서 정의한 메서드 특징"></a>4.5 클래스에서 정의한 메서드 특징</h2><ol>
<li>function 키워드를 생략한 메서드 축약 표현을 사용한다.</li>
<li>객체 리터럴과는 다르게 클래스에 메서드를 정의할 때 , (콤마)가 필요없다.</li>
<li>암묵적으로 strict모드로 실행한다. </li>
<li>for…in문이나 Object.keys 메서드 등으로 열거 할 수 없다. 즉 프로퍼티의 열거 가능 여부를 나타내며 불리언 값으로 프로터피 어트리뷰트 [[Enumerable]]의 값이  false 이다.</li>
<li>내부 메서드 [[Construct]]를 갖지않는 non-contructor이다. 따라서 new 연산자와 함께 호출할 수없다.</li>
</ol>
<h1 id="5-클래스의-인스턴스-생성-과정"><a href="#5-클래스의-인스턴스-생성-과정" class="headerlink" title="5. 클래스의 인스턴스 생성 과정"></a>5. 클래스의 인스턴스 생성 과정</h1><p>new  연산자와 함께 클래스를 호출하며 ㄴ생성자 함수오 마찬가지로 클래스의 내부 메서드 [[Construct]]가 호출된다. 클래스는 new연산자 없이 호출할 수 없다.<br>1.인스턴스 생성과 this 바인딩</p>
<p>new 연산자와 함께 클래스르 호출하면 constructo의 내부 코드가 실행되기에 앞서 암묵적으로 빈 객체가 생성이 된다. 이 빈 객체가 바로 (아직 완성이 안된)클래스가 생성한 인스턴스이다. 이대 클래스가 생성한 인스턴스의 프로토타입으로 클래스의prototype 프로퍼티가 가리키는 객체가 설정된다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩 된다. 따라서 constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킨다.</p>
<p>2.인스턴스 초기화</p>
<p>constructor의 내부 코드가 실행되어 this에 바인딩 뵈어있는 인스턴스를 초기화 한다. 즉 this에 바인딩되어있는 인스턴스에 프로퍼티를 추가하고 constructor 가 인수로 전달 받은 초기값으로 인스턴스의 프로퍼티 값으,ㄹ 초기화한다. 만약constructor가 생략되어있다면 이 과정도 생략이된다. </p>
<p>3.인스턴스 반환</p>
<p>클래스의 모든 처리가 끝이나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="comment">//생성자</span></span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="comment">//인스턴스의 초기화 및 생성</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">// Person&#123;&#125; 빈객체 반환</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>) === Person.prototype)<span class="comment">//true;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//this에 바인딩되어 있는 인스턴스를 초기화한다.</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="comment">//완성된 인스턴스가 바인딩된 this 가 암묵적으로 반환</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-프로퍼티"><a href="#6-프로퍼티" class="headerlink" title="6. 프로퍼티"></a>6. 프로퍼티</h1><h2 id="6-1-인스턴스-프로퍼티"><a href="#6-1-인스턴스-프로퍼티" class="headerlink" title="6.1. 인스턴스 프로퍼티"></a>6.1. 인스턴스 프로퍼티</h2><p>인스턴스의 프로퍼티는 constructor 내부에서 정의해야한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'kim'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(me) <span class="comment">// Person&#123;name :'kim'&#125;</span></span><br></pre></td></tr></table></figure>

<p>constructor내부 코드가 실행되기 이전에 constructor 내부의 this에느 ㄴ이미 클래스가 암묵적으로 생성한 인스턴스인 빈 객체가 바인딩되어 있다. </p>
<p>생성자 함수에서 생성자 함수가 생성할 인스턴스의 프로퍼티를 정의하는 것과 마찬가지로 constructor내부에서 thisdㅔ 인스턴스 프로퍼티를 추가한다. 이로써 클래슥 암묵적으로 빈 객체를 ,즉 인스턴스에 프로퍼티가 추가되어 인스턴스가 초기화된다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="comment">//인스턴스 프로퍼티</span></span><br><span class="line">    <span class="keyword">this</span>.mname = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'kim'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//name은 public하다</span></span><br><span class="line"><span class="built_in">console</span>.log(me.name) <span class="comment">//kim</span></span><br></pre></td></tr></table></figure>

<p>constructor 내부에서  thid에 추가한 프로퍼티는 언제나 클래스가 생성한 인스턴스의 프로퍼티가 된다. es6의 클래스는 다른 객체 지향 언어처럼 private,public,protected 워드와같은 접근 제한자를 지원하지 않는다. 따라서 인스턴스 프로퍼티는 언제나 public하다 다행히도 private한 프로퍼티를 정의할 수 있는 사양이 현재 제안 중에 있다. 클래스 필드 정의 제안</p>
<h2 id="6-2-접근자-프로퍼티"><a href="#6-2-접근자-프로퍼티" class="headerlink" title="6.2. 접근자 프로퍼티"></a>6.2. 접근자 프로퍼티</h2><p>접근자 프로퍼티는 자체적으로 값([[Value]]내부슬롯)을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할때 사용하는 접근자 함수로 구성된 프로퍼티이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="comment">//데이터 프로퍼티 </span></span><br><span class="line">  firstName:<span class="string">'jaehun'</span>,</span><br><span class="line">  lstName:<span class="string">'kim'</span>,</span><br><span class="line">  <span class="comment">// fullName은 접근자 함수로 구성된 접근자 프로퍼티이다.</span></span><br><span class="line">  <span class="comment">//getter 함수 </span></span><br><span class="line">  <span class="keyword">get</span> fullName()&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">//setter 함수 </span></span><br><span class="line">  <span class="keyword">set</span> fullName(name)&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">this</span>.firstname,<span class="keyword">this</span>.lastName] = name.split(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//데이터 프로퍼티를 통한 프로퍼티 값의 참조 </span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;person.firstName&#125;</span>`</span> $&#123;person.lastName&#125;) <span class="comment">// jeahun kim</span></span><br><span class="line"><span class="comment">//접근자 프로퍼티를 통한 프로퍼티 값의 저장</span></span><br><span class="line"> <span class="comment">//접근자 프로퍼티 fullName에 값을 저장하면 setterㅎ마수가 호출된다.</span></span><br><span class="line"> person.fillName = <span class="string">'naHyung kim'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123;fristName:'nahyng', lastName:'kim'&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//접근자 프로퍼티를 통한 프로퍼티 값의 참조</span></span><br><span class="line"><span class="comment">//접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(person.fullName) <span class="comment">// nahyung kim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//fullName은 접근자 프로퍼티이다.</span></span><br><span class="line"><span class="comment">//접근자 프로퍼티는 get, set , enumerabel, configurable 프로퍼티 어트리뷰트를 갖는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(person,<span class="string">'fullName'</span>));</span><br><span class="line"><span class="comment">// &#123;get: ƒ, set: ƒ, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>접근자 프로퍼티는 클래스 에서도 사용할  수있다.  위 에제의 객체 리터럴을 클래스로 표현하면 다음과 같다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(firstName,lastName)&#123;</span><br><span class="line">    <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">    <span class="keyword">this</span>.lastName = lasteName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//fullName은 접근자 함수로 구성된 접근자 프로퍼티이다.</span></span><br><span class="line">  <span class="keyword">get</span> fullName()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`&#123;this.firstName&#125; <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//setter함수</span></span><br><span class="line">  <span class="keyword">set</span> fullName(name)&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">this</span>.firstName .this.lastName] = name.split(<span class="string">''</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'jaehun'</span>,<span class="string">'kim'</span>);</span><br><span class="line"><span class="comment">//데이터 프로퍼티를 통한 프로퍼티의 값 참조</span></span><br><span class="line"><span class="comment">// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;me.firstName&#125;</span> <span class="subst">$&#123;me.lastName&#125;</span>`</span>); <span class="comment">// jaehun kim;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 접근자 프로퍼티를 통한 프로퍼티 값의 저장</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.</span></span><br><span class="line">me.fullName = <span class="string">'naHyung kim'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(me); <span class="comment">// &#123;firstName: "naHyung", lastName: "kim"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fullName는 접근자 프로퍼티이다.</span></span><br><span class="line"><span class="comment">// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(Person.prototype, <span class="string">'fullName'</span>));</span><br><span class="line"><span class="comment">// &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>접근자 프로터피는 자체적으로 깂을 가지지않고 다른 데이터 프로퍼트이 값을 읽거나 저장 할때 사용하는 접근자 함수 ,즉 getter함수와 setter함수로 구성된다. </p>
<p>getter는 인스턴스 프로퍼티에 접근할때 마다 프로퍼티의 값을 조작하는 행위가 필요할때 사용하낟. getter는 네서드 이름 앞에 get 지워드를 사용해 정의한다. setter는 인스턴스 프로퍼티에 값을 할당 할 때만다 프로퍼티의 값을 조작하는 행위가 필요 할때 사용한다 . </p>
<p>이때 getter와 setter 이름은 인스턴스 프로퍼티처럼 사용된다. 다시 말해 getter는 호출하는 것이 아니라 프로퍼티처럼 참조하는 형식으로 사용하며 참조 시에 내부적으로 getter가 호출된다. setter도 호출하는 것이 아니라 프로퍼티처럼 값을 할당하는 형식으로 사용하며 할당 시에 내부적으로 setter가 호출된다.</p>
<p>getter는 이름 그대로 무언가를 취득할 때 사용하므로 반드시 무언가를 반환해야 하고 setter는 무언가를 프로퍼티에 할당해야 할 때 사용하므로 반드시 매개 변수가 있어야 한다. setter는 단 하나의 값만을 할당 받기 때문에 단 하나의 매개 변수만을 선언할 수 있다.</p>
<p>클래스의 메서드는 기본적으로 프로토타입 메서드가 된다. 따라서 클래스의 접근자 프로퍼티 또한 인스턴스 프로퍼티가 아닌 프로토타입의 프로퍼티가 된다.</p>
<h1 id="7-클래스의-상속과-생성자-함수-상속"><a href="#7-클래스의-상속과-생성자-함수-상속" class="headerlink" title="7. 클래스의 상속과 생성자 함수 상속"></a>7. 클래스의 상속과 생성자 함수 상속</h1><p>상속에 대한 클래스의 확장은 지금까지 살펴본 프로토타입 기반 상속과 는 다른 개념이다. 프로토타입 기반 상속은 프로토타입 체인에 의해 다른 객체의 자신을 상속 받는개념이지만 <strong>상속에 대한 클래스 확장은 기존의 클래스를 상속받아 새로운 클래스를 확장하여 정의하는</strong> <strong>것</strong>이다.</p>
<p>클래스와 생성자 함수는 인스턴스를 생성할 수 있는 함수라는 점에서 매우 유사하다. 하지만 클래스는 상속을 통해 기존의 클래스를 확장 할 수있는 문법이 기본적으로 제공되지만 생성자 함수는 그렇지 않다.</p>
<p>예를 들어 동물을 추상화한 Animal 클래스와 새와 사자를 추상화한 Bird,Lion 클래스를 정의한다고 생각해보자. 새와 사자는 동물에 속하므로 동물의 속성을 가진다. 하지만 새와 사자는 자신만의 고유한 속성도 가진다. 이때 Animal 클래스는 동물의 속석을 그대로 표현하고 Bird,Lion 클래스는 상속을 통해 동물 클래스의 속성을 그대로 사용할고 자신만의 고유한 속성만을 확장 할 수 있다. </p>
<p>Bird 클래스롸  Lion 클래스는 상석을 통해 Animal 클래스의 속성을 드래로 사용하고 자신만의 고유한 속성을 추가하여 확장 하였다. 이처럼 상속에 의한 클래스 확장은 코드 재사용 관점에서 매우 유용하다.<br>상속을 통해 Animal 클래스를 확장한 Bird 클래스를 구현 해보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(age,weight)&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">  eat()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'eat'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  move()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'move'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</span><br><span class="line">  fly()&#123;<span class="keyword">return</span> <span class="string">'fly'</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bird = <span class="keyword">new</span> Bird(<span class="number">1</span>,<span class="number">50</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bird) <span class="comment">// Bird &#123;age:1,weight:50&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(bird <span class="keyword">instanceof</span> Bird) <span class="comment">//true;</span></span><br><span class="line"><span class="built_in">console</span>.log(bird <span class="keyword">instanceof</span> Animal)<span class="comment">// true;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bird.move()) <span class="comment">//'move';</span></span><br><span class="line"><span class="built_in">console</span>.log(bird.eat()) <span class="comment">//'eat';</span></span><br><span class="line"><span class="built_in">console</span>.log(bird.fly()) <span class="comment">//'fly'</span></span><br></pre></td></tr></table></figure>

<p>클래스는 상속을 통해 다른 틀래스를 확장 할 수 있는 문법인 extends 키워드 가 기본적으로 제공이 된다. extends 키워드를 사용한  클래스의 확장은 간편하고 직관적이다. 하지만 생성자함수는 클래스와 같이 상속을 통해 다른 생성자 함수를 확장 할 수있는 문법이 제공되지 않는다.</p>
<p>자바스크립트는 클래스 기반의 언어가 아니므로 생성자 함수를 사용하여 ㅡㄹ래스는 흉내 애려는 시도를 권장하지는 않지만 의사 클래스 상속 패턴을 사용하여 상속에 의한 클래스 확장을 흉내 내기도 했다. 클래스의 등장으로 아래 에제와 같은 의사 클래스 상속 패턴은  더 이상 필요하지않다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//의사 클래스 상속</span></span><br><span class="line"><span class="keyword">var</span> Animal = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">age,weight</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.weight = weight;</span><br><span class="line">  &#125;</span><br><span class="line">  Animal.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'eat'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  Animal.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'move'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Animal;</span><br><span class="line">&#125;)()</span><br><span class="line">/Animal 생성자 함수를 상속하여 확장한 Bird 생성자 함수</span><br><span class="line"><span class="keyword">var</span> Bird = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Bird</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//Animal 생성자 함수 에게 this와 인수를 전달하면서 호출</span></span><br><span class="line">    Animal.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//Bird.prototype을 Animal.prototype을 프로토타입으로 갖는 객체로교체</span></span><br><span class="line">  Bird.prototype = <span class="built_in">Object</span>.create(Animal.prototype);</span><br><span class="line">  <span class="comment">//Bird.prototype.constructor을 Animal에서 Bird로 교체</span></span><br><span class="line">  Bird.prototypr.constructor = Bird;</span><br><span class="line">  bird.prototype.fly = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'fly'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> Bird;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bird = <span class="keyword">new</span> Bird(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(bird); <span class="comment">// Bird &#123;age: 1, weight: 5&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(bird.eat());  <span class="comment">// eat</span></span><br><span class="line"><span class="built_in">console</span>.log(bird.move()); <span class="comment">// move</span></span><br><span class="line"><span class="built_in">console</span>.log(bird.fly());  <span class="comment">// fly</span></span><br></pre></td></tr></table></figure>

<h2 id="7-2-extends-키워드"><a href="#7-2-extends-키워드" class="headerlink" title="7.2. extends 키워드"></a>7.2. extends 키워드</h2><p>상속을 통해 클래스를 확장하려면 extends 키워드를 사용하여 상속 받을 클래스를 정의한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//슈퍼(파생/부모) 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;&#125;;</span><br><span class="line"><span class="comment">//서브 클래스 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>상속을 통해 확장된 클래스를서브 클래스라 부르고, 서브클래스에게 상속된 클래스를 수퍼 클래스라 부른다. 서브 클래스를 파생클래스 또는 자식 클래스, 슈퍼 클래스를 베이스 클래스 똔느 부모 클래스라 부르기도 한다.</p>
<p>extends 키워드의 역할은 슈퍼클래스와 서브 클래스 간의 상속 관계를 설정하는 것이다. 클래스도 프로토타입을 통해 상속 관계를 구현 할 수 있다.</p>
<p>수퍼 클래스와 서브 클래스는 인스턴스의 포러터타입 체인 뿌 아니라 ,클래스 간의 프로토타입 체인도 생성한다. 이를 통해 ㅍ로토타입 메서드, 정적 메서드 모두 상속이 가능하다. </p>
<h2 id="7-3-동적-상속"><a href="#7-3-동적-상속" class="headerlink" title="7.3. 동적 상속"></a>7.3. 동적 상속</h2><p>extends 키워드는 생생자 함수를 상속 받아 클래스을 확장할 수도 있다. extends 키워드 앞에는 반드시 클래스가 와야한다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//생성자 함수를 상속받는 서브 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">const</span> derived = <span class="keyword">new</span> Derived(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(derived) <span class="comment">//Derived &#123;a:1&#125;</span></span><br></pre></td></tr></table></figure>

<p>extends 티워드 다음에는 클래스 뿐만 아니라 [[Construct]]내부 메서드를 갖는 함수 객체를 반환나는 모든 표현식을 사용할 수있다. 이를 동적으로 상속받을 대상을 결정 할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Base1</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base2</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> condition = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">//조건에 따라 동적으로 상속 대상을 결정하는 서브 클래스</span></span><br><span class="line">class Derived extends (condition ? Base1 : Base2)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> erived =<span class="keyword">new</span> Deriveed();</span><br><span class="line"><span class="built_in">console</span>.log(derived) <span class="comment">//Derived &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(derived <span class="keyword">instanceof</span> Base1);<span class="comment">//true;</span></span><br><span class="line"><span class="built_in">console</span>.log(deruved <span class="keyword">instanceof</span> Base2) <span class="comment">//false;</span></span><br></pre></td></tr></table></figure>

<h2 id="8-2-서브-클래스의-constructor"><a href="#8-2-서브-클래스의-constructor" class="headerlink" title="8.2 . 서브 클래스의 constructor"></a>8.2 . 서브 클래스의 constructor</h2><p>서브 클래스이 constructor을 생략하면 클래스에 아래 와 같이 디폴트  constructor가 암묵적으로 정의된다. args는  new 연산자와 함께 클래스를 호출할때 전달한 인수의 리스트이다. </p>
<p> REST 파라미터 - 매개변수에 … 을 붙이면  Rest 파라미터가된다.Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.</p>
<p>super()는 수퍼 클래스의  constructor( super - constructor)를 호출하여 인스턴스를 생성한다  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//암묵적으로 constrtuctor 생성</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;<span class="keyword">super</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> derived = <span class="keyword">new</span> Derived();</span><br><span class="line"><span class="built_in">console</span>.log(derived) <span class="comment">// Derived &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>위 예제와 같이 수퍼 클래스와 서브 클래스 모두 constructor를 생략하면 빈 객체가 생성된다. 프로퍼티를 소유하는 인스턴스를 생성하려면 constructor내부에서 인스턴스에 프로퍼티를 추가해여한다.</p>
<h2 id="7-5-super-키워드"><a href="#7-5-super-키워드" class="headerlink" title="7.5 super 키워드"></a>7.5 super 키워드</h2><p>super키워드는 함수처럼 호출할 수도 있고 this와 같이 식별자 처럼 참조 할 수 있는 특수한 키워드이다.  super는다음과 같이 동작 한다. </p>
<p>1.super를 호출하면 수퍼 클래스이  constructor(super - contstructor)를 호출한다. </p>
<p>2.super를 참조하면  수퍼  클래스리 메서드를 호출할 수있다. </p>
<p>super를 호출하면 수퍼 클래스의 constructor(super-constructor)를 호출한다.</p>
<p>아래 예제와 같이 수퍼 클래스의 constructor 내부에서 추가한 프로퍼티를 그대로 갖는 인스턴스를 생성한다면 서브 클래스의 constructor를 생략할 수 있다. 이때 new 연산자와 함께 서브 클래스를 호출하면서 전달한 인수는 모두 서브 클래스에 암묵적으로 정의된 디폴트 constructor의 super 호출을 통해 수퍼 클래스의 constructor에게 전달된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a,b)&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//서브 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">  <span class="comment">//아래와 같이 암묵적으로 디폴트 constructor가 정의 된다.</span></span><br><span class="line">   <span class="comment">//constructor(...args)&#123;super(...args)&#125;</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> derived = <span class="keyword">new</span> Derived(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(derived) <span class="comment">// Derived &#123;a:1,b:2&#125;;</span></span><br></pre></td></tr></table></figure>

<p>수퍼 클래스에서 추가한 프로퍼티와 서브 클래스에 푸가한 플퍼티를 갖는 인스턴스를 생성한다면 서브 클래스의 constructor를 생랙할 수없다. 이때 new 연산자와 함께 서브클래스를 호출하면서 전달한 인수 중에서  tnvj zmffotmdml  constructor에게 전달 할 필요가 있는 인수는  서브클래스의 constructor에서  호출한  super를 통해 전달한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//슈퍼 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a,b)&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = a;</span><br><span class="line">    <span class="keyword">this</span>.b = b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 서브 클래스 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(a,b,c)&#123;</span><br><span class="line">    <span class="keyword">super</span>(a,b);</span><br><span class="line">    <span class="keyword">this</span>.c =c;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> derived = <span class="keyword">new</span> Derived(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(derived);<span class="comment">// Derived &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>new 연산자와 함께 Derived 클래스를 호출하면서 전달한 인수 1, 2, 3은 Derived 클래스의 constructor에게 전달되고 super 호출을 통해 Base클래스의 constructor에게 일부가 전달된다.</p>
<p>이처럼 인스턴스 초기화를 위해 전달한 인수는 수퍼 클래스와 서브 클래스에 배분되고 되고 상속 관계의 두 클래스는 서로 협력하여 인스턴스를 생성한다.</p>
<p><strong>1. 서브 클래스에서 constructor를 생략하지 않는 경우, 서브 클래스의 constructor에서는 반드시 super를 호출해야 한다.</strong></p>
<p><strong>2. 서브 클래스의 constructor에서 super를 호출하기 전에는 this를 참조할 수 없다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>()&#123;</span><br><span class="line">     <span class="comment">// ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor</span></span><br><span class="line">     <span class="keyword">this</span>.a = <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">super</span>();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">const</span> derived = <span class="keyword">new</span> Derived(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p><strong>3. super는 반드시 서브 클래스의 constructor에서만 호출한다. 서브 클래스가 아닌 클래스 또는 함수에서 호출하면 에러를 발생시킨다.</strong></p>
<p><u>메서드 내에서 super를 참조하면 수퍼 클래스의 메서드를 호출할 수 있다.</u></p>
<p><strong>1. 서브 클래스의 프로토타입 메서드 내에서 super.prop는 수퍼 클래스의 프로토타입 메서드 prop를 가리킨다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//수퍼 클래스 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hi <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//서브 클래스 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">  sayHi()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.sayHi()&#125;</span>. how r u doing?`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> derived = <span class="keyword">new</span> Derived(<span class="string">'kim'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(derived.sayHi()); <span class="comment">// Hi! kim. how r u doing?</span></span><br></pre></td></tr></table></figure>

<p>super 참조를 통해 수퍼 클래스의 메서드를 참조하려면 super가 수퍼 클래스의 메서드가 바인딩된 객체, 즉 수퍼 클래스의 prototype 프로퍼티에 바인딩된 프로토타입을 참조할 수 있어야 한다. 위 예제는 아래 예제와 동일하게 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//슈퍼 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayHi()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hi <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">  sayHi()&#123;</span><br><span class="line">    <span class="comment">// __super는 Derived의 sayHi가 바인딩된 객체의 프로퍼티 프로토타입을 가리킨다.</span></span><br><span class="line">    <span class="comment">//sayHi는 Derived.prototype에 바인딩 되었으므로 __super는 Base.prototype을 가리킨다.</span></span><br><span class="line">    <span class="keyword">const</span> __super = <span class="built_in">Object</span>.getPrototypeOf(Derived.prototype);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;__super.sayHi.call(<span class="keyword">this</span>)&#125;</span> how r u doging`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>super는 자신이 바인딩되어 있는 객체의 프로토타입을 가리킨다. 위 예제에서 Derived 클래스의 sayHi는 Derived.prototype에 바인딩되어 있고 super는 Derived.prototype의 프로토타입인 Base.prototype을 가리킨다. 따라서 super.sayHi는 Base.prototype.sayHi를 가리킨다. 단, super.sayHi, 즉 Base.prototype.sayHi를 호출할 때 call 메서드를 사용해 this를 전달하여야 한다.</p>
<p>call 메서드를 사용해 this를 전달하지 않고 Base.prototype.sayHi를 그대로 호출하면 Base.prototype.sayHi 메서드 내부의 this는 Base.prototype를 가리킨다. Base.prototype.sayHi 메서드는 프로토타입 메서드이기 때문에 내부의 this는 Base.prototype이 아닌 인스턴스를 가리켜야 한다. name 프로퍼티는 인스턴스에 존재하기 때문이다.</p>
<p>이처럼 super 참조가 동작하기 위해서는 메서드가 자신을 바인딩하고 있는 객체의 프로토타입(위 예제의 경우, Base.prototype)을 찾을 수 있어야 한다. 이를 위해 메서드는 내부 슬롯 [[HomeObject]]를 갖으며 자신을 바인딩한 객체를 가리킨다.</p>
<p>super 참조를 의사 코드로 표현하면 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[[HomeObject]]는 메서드 자신을 바인딩한 객체를 가리킨다.</span></span><br><span class="line"><span class="comment">이를 통해 메서드가 자신을 바인딩하고 있는 객체의 프로토타입을 찾을 수 있다.</span></span><br><span class="line"><span class="comment">예를 들어, Derived 클래스의 sayHi 메서드는 Derived.prototype에 바인딩된다.</span></span><br><span class="line"><span class="comment">따라서 Derived 클래스의 sayHi 메서드의 [[HomeObject]]는 Derived.prototype이고</span></span><br><span class="line"><span class="comment">이를 통해 Derived 클래스의 sayHi 메서드 내부의 super 참조가 Base.prototype으로 결정된다.</span></span><br><span class="line"><span class="comment">따라서 super.sayHi는 Base.prototype.sayHi를 가리키게 된다.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">super</span> = <span class="built_in">Object</span>.getPrototypeOf([[HomeObject]])</span><br></pre></td></tr></table></figure>

<p>주의 해야할 것은 es6 사양에서 새롭게 정의한 메서드, 즉 es6의 메서드 축양 표현으로 정의된  함수만이 [[HomeObject]]를 갖는다는 것이다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="comment">// ES6 메서드 축약 표현으로 정의한 메서드이다. [[HomeObject]]를 갖는다.</span></span><br><span class="line">  foo() &#123;&#125;,</span><br><span class="line">  <span class="comment">// ES6 메서드 축약 표현으로 정의한 메서드가 아니라 일반 함수이다.</span></span><br><span class="line">  <span class="comment">// 따라서 [[HomeObject]]를 갖지 않는다.</span></span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>super의 참조는 클래스의 전유물이 아니다. 객체 리터럴에서도 super 참조를 사용 할 수 있다. 단 ES6의 메서드 축약 표현으로 정의된 함수만 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> base =&#123;</span><br><span class="line">  name:<span class="string">'kim'</span>,</span><br><span class="line">  sayHi()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`Hi <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> derived = &#123;</span><br><span class="line">  --proto__:base,</span><br><span class="line">  sayHi()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.sayHi()&#125;</span> how r u doing`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(derived.sayHi());</span><br></pre></td></tr></table></figure>

<p><strong>2. 서브 클래스의 정적 메서드 내에서 super.prop는 수퍼 클래스의 정적 메서드 prop를 가리킨다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//슈퍼 클래스 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> sayHi()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//서브 클래스</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">   <span class="keyword">static</span> sayHi()&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">super</span>.sayHi()&#125;</span> how r u doing`</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(Derived.sayHi());</span><br></pre></td></tr></table></figure>

<h2 id="7-6-상속-클래스의-인스턴스-생성과정"><a href="#7-6-상속-클래스의-인스턴스-생성과정" class="headerlink" title="7.6. 상속 클래스의 인스턴스 생성과정"></a>7.6. 상속 클래스의 인스턴스 생성과정</h2><p>클래스가 단독으로 인스턴스를 생성하는 것 보다 상속 관계에 있는 두 클래스가 협력하여 인스턴스를 생성하는 과정은 좀 더 복잡하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reactangle</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width,height)&#123;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">    <span class="keyword">this</span>.height = height;</span><br><span class="line">  &#125;</span><br><span class="line">  getArea()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.width * <span class="keyword">this</span>.height;</span><br><span class="line">  &#125;</span><br><span class="line">  toString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`width = <span class="subst">$&#123;<span class="keyword">this</span>.width&#125;</span> height = <span class="subst">$&#123;<span class="keyword">this</span>.height&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorRectangle</span> <span class="keyword">extends</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width,height,color)&#123;</span><br><span class="line">    <span class="keyword">super</span>(width.height);</span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//메소드 오버라이딩</span></span><br><span class="line">  toString()&#123;</span><br><span class="line">    reutrn <span class="keyword">super</span>.toString() + <span class="string">`, color = <span class="subst">$&#123;<span class="keyword">this</span>.color&#125;</span>`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> colorRectangle = <span class="keyword">new</span> ColorRectangle(<span class="number">2</span>,<span class="number">4</span>,<span class="string">'red'</span>);</span><br><span class="line">ColorRectangle &#123;<span class="attr">width</span>: <span class="number">2</span>, <span class="attr">height</span>: <span class="number">4</span>, <span class="attr">color</span>: <span class="string">"red"</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 상속을 통해 getArea 메서드를 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(colorRectangle.getArea()); <span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 오버라이딩된 toString 메서드를 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(colorRectangle.toString());</span><br><span class="line"><span class="comment">// width = 2, height = 4, color = red</span></span><br></pre></td></tr></table></figure>

<p>서브 클래스가 new 연산자와 함께 호출되면 아래의 과정을 통해 인스턴스를 생성한다.</p>
<ol>
<li><strong>서브 클래스이 super 호출</strong></li>
</ol>
<p>자바스크립트 엔진은 클래스를 평가할때 , 수퍼 클래스와 서브 클래스를 구분하기 위해 ‘base’ 또는 ‘derived’를  값으로 갖는 내부 슬롯 [[ConstructorKind]]를 갖는다. 다른 클래스를 상속받지 않는 클래스는 내부 슬롯 [[ConstructorKind]]의 값이 ‘base’그대로 설정되지만 다른 클래스를 상속받은 서브클래스는 내부슬롯 [[ConstructorKind]]의 값이 ‘derived’로 설정이 된다. 이를 통해 수퍼 클래스와 서브클래스는 new연산자와 함께 호출되었을때 동작이 구분이 된다. </p>
<p>다른 클래스를 상속받지 않은 클래스(혹은 생성자 함수)는 new연산자와 함께 호출되었을때 암묵적으로 빈 객체, 즉 인스턴스를 생성하고 이를 this에 바인딩한다.</p>
<p>서브클래스가 new 연산자와 함게 호툴되면 서브 크래스 construcotr내부의 super 키워드가 함수처럼 호출된다. supe를 호출하면 수퍼 클래스의 constructor다 호출된다. 좀 더 정확히 말하자면 수퍼클래스가 평가 되어 생성된 함수의 객체의 코드가 실행되기 시작하낟. </p>
<p>만약 서브 클래스 constructor 내부에 super 호출이 없으면 에러가 발생한다. 실제로 인스턴스를 생성하는 주체는 수퍼 클래스 이므로 수퍼클래스의 constructor를 호출하는 super가 호출되지않으면 인스턴스를 생성 할 수 없기 때문이다.</p>
<ol start="2">
<li><strong>수퍼 클래스의 인스턴스 생성과 this 바인딩</strong></li>
</ol>
<p>수퍼클래스의 constructor 내부의 코드가 실행되기 이전에 암묵적으로 빈 객체를 생성한다. 이 빈 객체가 바로 (아직 완성은 되지 않았지만 ) 클래스가 생성한 인스턴이다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩 된다 .따라서 수퍼 클래스의 constructor 내부의 this는 생성된 인스턴스를 가리킨다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//수퍼 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width,height)&#123;</span><br><span class="line"><span class="comment">// 암묵적으로 빈 객체 , 즉 인스턴스가 생성되고 this에 바인딩 된다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//ColorRectangle &#123;&#125;</span></span><br><span class="line">    <span class="comment">//new 연산자와 함께 호출된 함수,즉 new.target은 ColorRectangle이다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target) <span class="comment">//ColorRectangle;</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이때 인스턴스는 수퍼 클래스가 생성한 것이다. 하지만 new 연산자와 함께 호출되 서브 클래스라는 것이 중요하다. 즉 new 연산자와 함께 호출된 함수를 가리키는 new.target은 서브 객체를 가리킨다. 따라서 인스턴스는 new.target이 가리키는 서브클래스가 생성한 것으로 처리된다. </p>
<p>따라서 생성된 인스턴스의 프로토타입은 수퍼클래스의 prototype프로퍼티가 가리키는 객체(Rectangle)이 아니라 new.target, 즉 서브 클래스의 prototype 프로퍼티가 가르키는 객체 ColorRectangle이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//수퍼 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width,height)&#123;</span><br><span class="line">     <span class="comment">// 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 this에 바인딩된다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// ColorRectangle &#123;&#125;</span></span><br><span class="line">    <span class="comment">// new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다.</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="keyword">new</span>.target); <span class="comment">// ColorRectangle</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 생성된 인스턴스의 프로토타입으로 ColorRectangle.prototype가 설정된다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>) === ColorRectangle.prototype); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> ColorRectangle); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>수퍼클래스의 인스턴스 초기화</strong></li>
</ol>
<p>수퍼클래스의 constructor가 실행되어 this 에 바인딩되어있는 인스턴스를 초기화한다. 즉 , this가 바인딩 되어있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달 받은 초기값으로 인스턴스의 프로퍼티를 초기화한다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//슈퍼 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width,height)&#123;</span><br><span class="line">    / 암묵적으로 빈 객체, 즉 인스턴스가 생성되고 <span class="keyword">this</span>에 바인딩된다.</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// ColorRectangle &#123;&#125;</span></span><br><span class="line">    <span class="comment">// new 연산자와 함께 호출된 함수, 즉 new.target은 ColorRectangle이다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target); <span class="comment">// ColorRectangle</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 생성된 인스턴스의 프로토타입으로 ColorRectangle.prototype가 설정된다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(<span class="keyword">this</span>) === ColorRectangle.prototype); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> ColorRectangle); <span class="comment">// true</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//인스턴스 초기화</span></span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">    thisd.height = height;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">//ColorRectangle &#123;width: 2, height: 4&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>서브 클래스 constructor로의 복귀와 this바인딩</li>
</ol>
<p>super의 호출이 종료 되고 컨트롤이 서브클래스 constroctor로의 복귀한다. 이때 super가 반환한 인스턴스가 this에 바인딩 된다. 이처럼 서브 클래스는 별도의 인스턴스를 생성하지 않고 super가 반환한 인스턴스를 this에 바인딩 하여 그대로 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//서브클래스 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colorrectangle</span> <span class="keyword">extends</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width,height,color)&#123;</span><br><span class="line">    <span class="keyword">super</span>(width,height);</span><br><span class="line">   <span class="comment">//super가 반환한 인스턴스가 this에 바인딩 된다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">// ColorRectangle &#123;width: 2, height: 4&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이처럼 super가 호출되지 않으면 인스턴스가 생성되징나흥면 this 도 바인딩 되지않는다. 서브클래스의 constructor에서  super을 호출하기 전에는 this를 참조할 수 없는 이유는 바로 이것 빼문이다. 따라서 서브 클래스의 constructor 내부의 인스턴스 초기화는 반드시 super 호출이후에 처리되어야한다.</p>
<ol start="5">
<li><strong>서브 클래스의 인스턴스 초기화</strong></li>
</ol>
<p>super호출이후 ,서브클래스의  constructor에 기술되어 있는 인스턴스 초기화가 실행된다.  this에 바인딩 되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티를 초기화한다. </p>
<ol start="6">
<li><strong>인스턴스 반환</strong></li>
</ol>
<p>클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 서브 클래스</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorRectangle</span> <span class="keyword">extends</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(width, height, color) &#123;</span><br><span class="line">    <span class="keyword">super</span>(width, height);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// super가 반환한 인스턴스가 this에 바인딩된다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// ColorRectangle &#123;width: 2, height: 4&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 인스턴스 초기화</span></span><br><span class="line">    <span class="keyword">this</span>.color = color;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다.</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// ColorRectangle &#123;width: 2, height: 4, color: "red"&#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="8-7-표준-빌트인-생성자-함수-확장"><a href="#8-7-표준-빌트인-생성자-함수-확장" class="headerlink" title="8.7 표준 빌트인 생성자 함수 확장"></a>8.7 표준 빌트인 생성자 함수 확장</h2><p> extends 키워드 다음에는 클래스뿐만이 아니라 [[Construct]] 내부 메서드를 갖는 함수 객체를 반환하는 모든 표현식을 사용할 수 있다. String, Number, Array와 같은 표준 빌트인 객체도 [[Construct]] 내부 메서드를 갖는 생성자 함수이므로 extends 키워드를 사용하여 확장할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Array 생성자 함수를 상속받아 확장한 MyArray</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123;</span><br><span class="line">  <span class="comment">//중족 배열요소를 제거하고 반환</span></span><br><span class="line">  uniq()&#123;</span><br><span class="line">    retutn <span class="keyword">this</span>.filter(<span class="function">(<span class="params">arr,i,self</span>)=&gt;</span>self.indexOf(arr) === i);</span><br><span class="line">  &#125;</span><br><span class="line">  average()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function">(<span class="params">pre,cur</span>)=&gt;</span>pre+cur,<span class="number">0</span>)/<span class="keyword">this</span>.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myArray = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(myArray); <span class="comment">// MyArray(4) [1, 1, 2, 3]</span></span><br><span class="line"><span class="comment">//MyArray.prototype.uniq 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(myArray.uniq()); <span class="comment">// MyArray(3) [1, 2, 3]</span></span><br><span class="line"><span class="comment">// MyArray.prototype.average 호출</span></span><br><span class="line"><span class="built_in">console</span>.log(myArray.average()); <span class="comment">// 1.75</span></span><br></pre></td></tr></table></figure>

<p>Array 생성자 함수를 상속받아 확장한 MyArray 클래스가 생성한 인스턴스는 Array.prototype와 MyArray.prototype의 모든 메서드를 사용할 수 있다.</p>
<p>이때 주의할 것은 Array.prototype의 메서드 중에서 map, filter와 같이 새로운 배열을 반환하는 메서드가 MyArray 클래스의 인스턴스를 반환한다는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(myArray.filter(<span class="function"><span class="params">v</span>=&gt;</span> v%<span class="number">2</span>) <span class="keyword">instanceof</span> MyArray) <span class="comment">//true;</span></span><br></pre></td></tr></table></figure>

<p>만약 새로운 배열을 반환하는 메서드가 MyArray 클래스의 인스턴스를 반환하지 않고 Array의 인스턴스를 반환하면 MyArray 클래스의 메서드와 메서드 체이닝(method chaining)이 불가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 메서드 체이닝</span></span><br><span class="line"><span class="comment">// [1, 1, 2, 3] =&gt; [ 1, 1, 3 ] =&gt; [ 1, 3 ] =&gt; 2</span></span><br><span class="line"><span class="built_in">console</span>.log(myArray.filter(<span class="function"><span class="params">v</span> =&gt;</span> v % <span class="number">2</span>).uniq().average()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<p>myArray.filter가 반환하는 인스턴스는 MyArray 클래스가 생성한 인스턴스, 즉 MyArray 타입이다. 따라서 myArray.filter가 반환하는 인스턴스로 uniq 메서드를 연이어 호출(메서드 체이닝)할 수 있다. uniq 메서드가 반환하는 인스턴스는 Array.prototype.filter에 의해 생성되었기 때문에 Array 생성자 함수가 생성한 인스턴스로 생각할 수도 있겠다. 하지만 uniq 메서드가 반환하는 인스턴스도 MyArray 타입이다. 따라서 uniq 메서드가 반환하는 인스턴스로 average 메서드를 연이어 호출(메서드 체이닝)할 수 있다.</p>
<p>만약 MyArray 클래스의 uniq 메서드가 MyArray 클래스가 생성한 인스턴스가 아닌 Array가 생성한 인스턴스를 반환하도록 하려면 아래와 같이 Symbol.species를 사용하여 정적 접근자 프로퍼티를 추가한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Array생성자 함수 를 상속받아 확장한 MyArray</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123;</span><br><span class="line">  <span class="comment">//모든 메서드가 Array 타입의 인스턴스을 반환하도록 한다. </span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> [Symbol.species]()&#123;<span class="keyword">return</span> <span class="built_in">Array</span>&#125;;</span><br><span class="line">  <span class="comment">// 중복된 배열 요소를 제거하고 반환한다: [1, 1, 2, 3] =&gt; [1, 2, 3]</span></span><br><span class="line">  uniq() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function">(<span class="params">v, i, self</span>) =&gt;</span> self.indexOf(v) === i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 모든 배열 요소의 평균을 구한다: [1, 2, 3] =&gt; 2</span></span><br><span class="line">  average() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur, <span class="number">0</span>) / <span class="keyword">this</span>.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myArray = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myArray.uniq() <span class="keyword">instanceof</span> MyArray); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(myArray.uniq() <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 메서드 체이닝</span></span><br><span class="line"><span class="comment">// uniq 메서드는 Array 인스턴스를 반환하므로 average 메서드를 호출할 수 없다.</span></span><br><span class="line"><span class="built_in">console</span>.log(myArray.uniq().average());</span><br><span class="line"><span class="comment">// TypeError: myArray.uniq(...).average is not a function</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>클래스에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>스코프란?</title>
    <url>/2020/06/02/scope-md/</url>
    <content><![CDATA[<h1 id="1-스코프란"><a href="#1-스코프란" class="headerlink" title="1. 스코프란?"></a>1. 스코프란?</h1><p>스코프(유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이면 중요한 개념이다. 스코프의 이해가 부족하면 다른 개념을 이해하는데 어려울 수 있다. 더욱 자바스크립트의 스코프는 다른언어의 스코프와 구별되는 특징있다. 그리고 var 키워드로 선언한 변수와 let const로 선언한 변수의 스코프 또한 다르게 동작한다. </p>
<p>함수의  매개변수는 함수 몸체 내부에서만 참조 할숭 있고 함수 몸체 외부에서는 참조 할 수  없다고 했다 이것은 애개변수를 참조 할 수 있는유효 범위, 즉 매개 변수릐 스코프가 함수 몸체 내부로 한정되기 때문이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//매개변수는 함수 몸체 내부에서만 참조 할 수 있다.</span></span><br><span class="line">  <span class="comment">// 즉, 매개변수의 스코프(유효범위)는 함수 몸체 내부이다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(x,y); <span class="comment">//2 5</span></span><br><span class="line">  <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">2</span>,<span class="number">5</span>);</span><br><span class="line"><span class="comment">//매개변수는 함수 몸체 내무에서만 참조 할 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log(x,y) <span class="comment">// Reference Error: x isnot defined</span></span><br></pre></td></tr></table></figure>

<p>변수의 코드의 가장 바깥 영역 뿐 아니라 코드 블록이나 함수 몸체에서도 선언 할 수 있다. 이때 코들 블록이나 함수는 중첩될 수있다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> var1  =<span class="number">1</span>; <span class="comment">//코드의 가자 바깥 영역에서 선언된 변수</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> var2 = <span class="number">2</span> <span class="comment">//코드 블록 내에서 선언된 변수</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> var3 = <span class="number">3</span>; <span class="comment">//중첩된 코드 내에서 선언된 변수</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> var4 = <span class="number">4</span><span class="comment">//함수 내에서 선언된 변수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> var5 = <span class="number">5</span> <span class="comment">//중첩된 함수 내에서 선언된 함수</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(var1); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(var2); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(var3); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(var4); <span class="comment">// ReferenceError: var4 is not defined</span></span><br><span class="line"><span class="built_in">console</span>.log(var5); <span class="comment">// ReferenceError: var5 is not defined</span></span><br></pre></td></tr></table></figure>

<p>변수는 자신이 선언된 우치에 의해 자신이 유효한 범위, 즉 다른코드가 참조 할 수 있는 범위가 결정된다. 변수 뿐아니라 모든 식별자가 그렇다. 다시 말해 , <strong>모든 식별자(변수이름, 함수이름,클래스 이름 등) 는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조 할 수 있는 유효범위가 결정 된다. 이를 스코프라한다. 즉 스코프는 식별자가 유효한 범위를 말한다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'global'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x =<span class="string">'local'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">//x= 'local' -1</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">//'global' -2</span></span><br></pre></td></tr></table></figure>

<p>코드의 가장 바깥 영역과 foo 함수내에는 같은 이름을 갖는 변수x를 선언했고 1,2에서 변수 x을 참조한다. 이때 자바스크립트엔진은 이름이 같은 두개의 변수중에서 어떤 변수응 참조해야 할 것인지 결정(식별자 결정)해야한다. 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조 해야 할 것인지 결정한다. 따라서 스코프란 자바스크립트 엔진이 <strong>식별자를 검색할 때 사용하는 규칙</strong>이라고 할수 있다.</p>
<p>위의 예제에서 코드의 가장 바깥에 영역에 선언된 x변수는 어디서든 참조가 가능하다. 하지만foo함수 내부에서 선언된 x변수는 내부에서만 참조 가능하고 바깥에서 참조할 수 없다. 이때 두 식별자 이름은 동일 하지만 자신이 가진 유효한 범위 , 즉 스코프가 다른 변수이다. </p>
<hr>
코드의 문맥과 환경 - "코드가 어디서 실행되면 어떤 코드가 있는지"를 환경이라 부른다. 즉 코드의 문맥은 환경으로 이뤄진다. 이를 구현한 것이 "실행 컨텍스트"이며, 모든 코드는 실행컨택스트에서 평가 되고 실행된다. 스코프는 실행 컨택스트와 깊은 관련이있다.

<hr>

<p>만역 스코프라는 개념이 없으면 같은 이름을 갖는 변수는 충돌을 일으키므로 프로그램 전체에서 하나 밖에 사용 할 수 없다.</p>
<p>변수나 함수의 이름과 같은 식별자는 어떤값을 구별해서 식별해 낼 수있는 고유한 이름을 말한다. 사람을 고유한 이름으로 구별 하듯이 갑도 사람이 이해할 수 있는 언어로 지정한 고유한 식별자인 변수이름에 의해 구별해서 참조 할 수있다.</p>
<p>식별자는 어떤 값을 구별 할 수있어야 하므로 유일해야 한다. 따라서 식별자인 변수 이름은 중복될수 없다. 즉 하나의 유일한 식별자에 연결해야한다.<br>예를 들어 파일이름은 하나의 파일응ㄹ 구별해서 식별 할 수있는 식별자다.  식별자인 파일은 이름은 유일해야한다. 하지만 우리는 컴퓨터를 사용할때 하나의파일 이름만 사용하지 않는다. 식별자인 파일이름을 중복해야 한다면 파일이름을 만드는 것이 무척 번거로울 것이다.<br>이와 마찬가지로 프로그래밍 언어에서는 스코프를 통해 식별자인 변수의 이름의 충돌을 방지해서 같은 이름의 변수를 사용할수있게 한다. 스코프 내에서 식별자는 유일해야 하지만 다른 스코프에는 같은 이름의 식별자를 사용할 수 있다. </p>
<hr>
**var 키워드로 선언한 변수는 같은 스코프 내에서 중목선어이 가능하다. 이는 의도치 않게 변수값이 재할당되어 변경되는 부작용을 일으킨다.**

<hr>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x =<span class="number">1</span>;</span><br><span class="line">  <span class="comment">//var 키워드로 선언한 변수는 같은 스코프 내에서 중복선어이 허용된다.</span></span><br><span class="line">  <span class="comment">// 아래의 변수 선언문은 자바스크립트 엔진에 의해ㅓ var 키워드가 없는것 처럼 동작한다</span></span><br><span class="line">  <span class="keyword">var</span> x =<span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x) <span class="comment">//2</span></span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>

<p><strong>하지만 let이나  const 키워드는 선언되 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x =<span class="number">1</span>;</span><br><span class="line">   <span class="comment">//let 이나 const로 선언한 변수는 같은 스코프 내에서 중복이 불가하다.</span></span><br><span class="line">  <span class="keyword">let</span> x =<span class="number">2</span>;</span><br><span class="line">  <span class="comment">//SyntaxError: Identifier 'x' has already been declared</span></span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<h1 id="2-스코프의-종류"><a href="#2-스코프의-종류" class="headerlink" title="2. 스코프의 종류"></a>2. 스코프의 종류</h1><p>코드는 전역과 지역으로 구분 할 수 있다. </p>
<table>
<thead>
<tr>
<th>구분</th>
<th>설명</th>
<th>스코프</th>
<th>변수</th>
</tr>
</thead>
<tbody><tr>
<td>전역</td>
<td>코드의 가장 바깥 영역</td>
<td>전역 스코프</td>
<td>전역변수</td>
</tr>
<tr>
<td>지역</td>
<td>함수 몸체의 내부</td>
<td>지역 스코프</td>
<td>지역 변수</td>
</tr>
</tbody></table>
<p>이때  변수는 자신이 선언된 위치(전역 똔느 지역)에 의해 자신이 유효한 범위인 스코프가 결정 된다. 즉 전역에서 선언된 변수는 전역 스코프를 갖는 전역변수가 되고 , 지역에선 지역 스코프를 갖는 지역 변수다.</p>
<h2 id="2-1-전역과-전역-스코프"><a href="#2-1-전역과-전역-스코프" class="headerlink" title="2.1. 전역과 전역 스코프"></a>2.1. 전역과 전역 스코프</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="string">'globalx'</span>;</span><br><span class="line"><span class="keyword">var</span> y =<span class="string">'globaly'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> z = <span class="string">"outer's local z"</span> </span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">//'globalx'; -1</span></span><br><span class="line">  <span class="built_in">console</span>.log(y); <span class="comment">//'globaly';  -2</span></span><br><span class="line">  <span class="built_in">console</span>.log(z); <span class="comment">//"outer's local z" -3</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="string">"inner's local x"</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="built_in">console</span>.log(x); <span class="comment">//"inner's local x"; -4</span></span><br><span class="line">  <span class="built_in">console</span>.log(y); <span class="comment">//'globaly'; -5</span></span><br><span class="line">  <span class="built_in">console</span>.log(z); <span class="comment">//"outer's local z" -6</span></span><br><span class="line">  &#125;</span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x); <span class="comment">//'globalx'; -7</span></span><br><span class="line"><span class="built_in">console</span>.log(z); <span class="comment">// Reference Error -8</span></span><br></pre></td></tr></table></figure>

<p>전역이란 코드의 가장 바깥 영역을 말한다.  전역은 전역 스코프를 만든다. 저역에 젼수를 선언하면 스코프를 갖는 전역 변수가 된다. <strong>전역 변수는 언디서든 참조가 가능하다.</strong> </p>
<p>위 에제에서 코드의 가장 바깥 영역인 전역에서 선언된 변수 x  와 y변수는 전역변수이다. 전역변수는 어디서든 참조 할 수있으므로 함수 내부에서도 참조할 수 있다.</p>
<h2 id="2-2-지역과-지역-스코드"><a href="#2-2-지역과-지역-스코드" class="headerlink" title="2.2. 지역과 지역 스코드"></a>2.2. 지역과 지역 스코드</h2><p>지역이란 함수 몸체 내부를 말한다. 지역은 지역 스코프를 만든다. 지역에 젼수를 선언하면 지역스코프를 작는 지역변수가 된다. 지역변수는 자신이 선언되 지역과 하위 지역(중첩 함수)에서만 참조 할 수있다. 다시말해 <strong>지역변수는 자신의 지역스코프와 하위지역 스코프에서 유효하다.</strong><br>위 예제에서 oute함수 내부에서 선언된 변수z는 지역변수이다. 지역변수 z는 자신의 지역 스코프인 outer함수 내부와 하위 지역 스코프린 inner함수 내부에서 참조할 수 있다. 하지만 지역 변수z를 전역에서 ㅍ참조하면 에러가 발생한다.<br>inner함수 내부에서 선언된 x면수도 지역 변수이다. 지역변수 x는 자신의 지역 스코프인 함수inner 내부에서만 참조가 가능하다. 하지만 지역 변수x 을 전역 또는 innerㅎ마수 내부 이외의 지역에서 참조하면 참조 에러가 발생한다.<br>그런데 inner함수 내부에서 선언된 x변수 이외에 이름이 같은 전역변수가 존재한다. 이때 inner 함수 내부에서 x변수를 참조하면 전역변수x을 참조하는 것이 아니라 inner함수 내부에서 선언된 x변수를  참조한다. 이는 자바스크립트 엔진이 스코프 체인을 통해 참조할 변수를 검색했기 때문이다.  </p>
<h1 id="3-스코프-체인"><a href="#3-스코프-체인" class="headerlink" title="3. 스코프 체인"></a>3. 스코프 체인</h1><p>함수는 전역에서 정의할 수도 있고 함수 내부에서 정의할 수 도 있다 . 함수 몸체에서 함수가 정의된 것을 “함수의 중첩”이라 한다. 그리고 함수 몸체 내부에서 정의한 함수를 ‘중첩함수’, 중첩 함수를  포함하는 ‘외부함수’라 한다.<br>함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩 될 수 있다. 이는 스코프가 함수의 중첩에의핸 곚층적 구조를 갖는다는 것을 의미한다. 다시 말해 중첩함수의 지역 스코프는 중첩 함수를 포함하는 외부함수의 지역 스코프와 계층적 구조를 갖는다. 이때 외부의 지역 스코프를 중첩함수의 상위 스코프라 한다. </p>
<p>위 예제에서 지역은 outer 함수의 지역과 inner함수의 지역이있다. inner함수는 outer함수의 중첩함수이다. 이때 outer함수가 만든 outer함수의 지역 스코프는 inner 함수가 만든 inner 함수의 지역 스코프의 사우이 스코프이다. 그리고outer 함수의 지역 스코프의 샹위 스코프는 전역 스코프이다. 이러한 계층 구조를 그림으로 표현하면 다음과 같다. </p>
<p><img src="https://poiemaweb.com/assets/fs-images/13-3.png" alt="13-3"></p>
<p>이 처럼 모든 스코프는 하나의 계층적 구조로 연결이 되며, 모든 지역 스코프 최상위 스코프는 전역스코프이다. 이렇게 스코프가 계층적으로 연결된것을 스코프 체인이라고 한다. 위 그림에서 스코프 체인은 최상위 스코프인 전역 스코프 , 전역에서 선언된  outer 함수의 지역 스코프 ,outer 함수 내부에서 선언된 inner 함수의 지역 스코프로 이뤄진다.</p>
<p>변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 빙향으로 이동하며 선언된 변수를 검색한다. 이를 통해 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조 할 수 있다.</p>
<p>스코프 체인은 물리적인 실체로 존재한다. 자바스크립트엔진은 코드(전역 코드와 함수코드)를 실행하기에 앞서 위 그림과 유사한 자료구조인 레시컬 환경을 실제로 생성한다. 변수 선언이 실행되면 변수 식별자가 이 자료구조(렉시커 환경)에 등록 되고 , 변수 할당이 일어나면 이 자료구조의 변수 식별자에 해당하는 값을 변경한다. 변수의 검색도 이 자료구조 상에서 이뤄진다. </p>
<hr>

<p><strong>렉시컬 환경</strong>- 스코프 체인은 실행 컨택스트의 렉시컬 환경을 단방향으로 열결한 것이다. 전역 렉시컬 환경은 ㄷ코드가 로드되면 곧바로 생성되고 함수의 렉시컬 환경은 함수가 호출되면 곧바로 생성된다. </p>
<hr>

<h2 id="3-1-스코프-체인에-의한-변수-검색"><a href="#3-1-스코프-체인에-의한-변수-검색" class="headerlink" title="3.1. 스코프 체인에 의한 변수 검색"></a>3.1. 스코프 체인에 의한 변수 검색</h2><p>위 예제 의 4,5,6을 살펴 보자 . 이를 통해 자바스크립으 엔진이 스코프 체인을 통해 어떻게 변수를 찾아 내는지 이해 할 수 있다.<br> 4 x변수를 참조하는 코드의 스코프인 inner 함수 의 지역 스코프에서 선언됐는지 검색한다. inner 함수 내에는 선언된 x변수가 존재한다. 따라서 검색된 변수를 참조하고 검색을 종료한다. </p>
<p>5  y변수를 참조하는 코드의 스코프인 inner함수의 지역 스코프에서 y변수가 선언됐는지 검색한다. inner 함수 내에는 y변수가 선언이 존해하지 않으므로 상위 스코프인 outer함수릐 지역 스코프로 이동한다. outer 함수 내에도 y 젼수 선언이 존재 하지않으므로 또 다시 상위 스코프인 전역 스코프로 이동한다. 전역 스코프에는 y변수의 선언이 존재한다. 따라서 검색된 변수를 참조하고 검색을 종료한다. </p>
<p>6 z변수를 참조하는 코드의 스코프인 inner함수의 지역스코프에서 z변수가 선언 됐는지 검ㅅ개한다. inner함수 내에 z변수 선언이 존재 하지 않으므로 상위 스코프인 outer함수의 지역 스코프로 이동한다. outer함수 내에는 z변수 선언이  존재한다. 따라서 검색된 변수를 참조하고 검색을 종료한다.<br>이처럼 자바스크립트엔진은 스코프체인을 따라 변수를 참조하는 코드의 스코프에서 시작해서 상위 스코프 방향으로 이동하면 선언된 변수를 검색한다. 절대 하위 스코프로 내려가면 식졀자를 검색하는 일은 없다. 이는 <strong>상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조 할 수있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조 할 수 없다는 것을 의미한다.</strong></p>
<h2 id="3-2-스코프-체인에-의한-함수-검색"><a href="#3-2-스코프-체인에-의한-함수-검색" class="headerlink" title="3.2. 스코프 체인에 의한 함수 검색"></a>3.2. 스코프 체인에 의한 함수 검색</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//전역함수 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'global fucntion foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//중첩함수 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'local functino foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line">  foo(); <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>

<p>함수선언문으로 함수를 정의하면 자바스크립트 엔진에 의해 다른 코드가 실행되기 이전에 함수 객체가 먼저 생성이 된다. 그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.<br>따라서 위 에제의 모든 함수는 <strong>자바스크립트 엔진에 의해 암묵적으로 생성된 함수 이름과 동일한 이름의 식별자에 할당된다.</strong> </p>
<p>1에서 함수를 호출하면 자바스크립트 엔진은 함수를 호출하기 위해 먼저 함수를 가리키는 식별자 foo를 검색한다.<br>이처럼 함수도 식별자에 할당되기 때문에 스코프르 갖는다. 사실 함수는 식별자에 함수 객체가 할당된 것 외에는 일반 변수와 다를바 없다. 따라서 스코프를 “변수를 검색할 때 사용되는 규칙”이라고 표횬하기 보다는 “ <strong>식별자를 검색하는 규칙</strong>“이라고 표현하는 편이 좀더 적합하다.</p>
<h1 id="4-함수-레벨-스코프"><a href="#4-함수-레벨-스코프" class="headerlink" title="4. 함수 레벨 스코프"></a>4. 함수 레벨 스코프</h1><p>지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다고 했다. 이는 모드 블록이 아닌 함수에 의해서만 지역스코프가 생성된다는 의미이다.</p>
<p>C나 자바 등 대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 모드블록(if,for,while,try/catch)등 이 지역 스코프를 만든다. 이러한 특성을 <strong>블록레벨 스코프라</strong> 한다. 하지만 <strong>var 키워드로 선언된 변수는 오로지 함수의 코드블록만을 지역 스코프로 인정한다</strong>. 이러한 특성을 <strong>함수레벨 스코프라한다</strong>. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">   <span class="comment">//var 키워드로 선언된 변수는 함수의 코드 블록만을 지역스코프로 인정한다. </span></span><br><span class="line">   <span class="comment">//함수밖에서 var키워드로 선언된 변수는 코드블록 내에서 선언됐다 할지라도 모두 전역 변수이ㅏㄷ. </span></span><br><span class="line">   <span class="comment">//따라서 x는 전역변수이다. 이미 선언한 전역변수x 가 있으므로 x면수는 중복선언된다. </span></span><br><span class="line">   <span class="comment">//이는 의도치않게 변수값이 변경되는 부작용을 발생시킨다. </span></span><br><span class="line">   <span class="keyword">var</span> x =<span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(x) <span class="comment">//10;</span></span><br></pre></td></tr></table></figure>

<p>전역변수 x가 선언되었고 if문의 코드 블록내에도 x변수가 선언되었다. 이때 if문의 코들블록 내에서 선언된 x변수는 전역 변수이다. var키워드로 선언된 변수는 블록레벨 스코프를 인정하기 땨ㅐ문에 함수 밖에서 var키워드로 선언된 변수는 코드블록 내에서 선언되었다 할지라도 모두 전역변수이다. 따라서 전역변수 x 는 중복 선언되고 그 결과 의도치 않은 전역 변수의 값이 재할당된다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for 문에서 선언한 i는 전역변수이다. 이미 선언한 전역변수 i가 있으므로 중복선언된다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> ui =<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2 3 4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//의도치 않게 변수의값이 변경되었다. </span></span><br><span class="line"><span class="built_in">console</span>.log(i) <span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p>블록 레벨 스코프를 지원하는 프로그래밍 언어에서는 for 문에서 반복을 위해 선언된 i 변수가 for문의 코드블록 내에서만 유효한 지역변수다.이 변수를 for문 외부에서 사용할 일은 없기 때문이다. 하지만 var키워드로 선언도니 변수를 블록 레벨 스코프를 인정하지않기 때문에 i 변수는 전역변수가 된다. 따라서 전역 변수 i 는 중복 선언되고 그 결과 의도치 않은 전역 변수의 값이 재할당된다. </p>
<p>var키워드로 선언된 변수는 오로지 함수의 코드블록 만을 지역 스코프로 인정하지만 ,eS6에서 도입된 let, const키워드는 블록레벨 스코프를 지원한다. </p>
<p>(<strong>var 함수레벨 스코프,let,const 블록레벨 스코프)</strong></p>
<h1 id="5-렉시컬-스코프"><a href="#5-렉시컬-스코프" class="headerlink" title="5. 렉시컬 스코프"></a>5. 렉시컬 스코프</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">fucntion foo()&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">  bar();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line">fucntion bar()&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// 1</span></span><br><span class="line">bar(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p> 위 에제의 실행결과 bar함수의 상위 스코프가 부엇인지에 따라 결정된다. 두가지 패펀을 예측할수있다. </p>
<ol>
<li>함수를 어디에서 호출했는지에 따라 함수의 상위 스코프를 결정한다. </li>
<li>함수를 어디에서 정의했는지에 따다 함수의 사우이 스코프를 결정한다. </li>
</ol>
<p>첫번째 방식으로 함수의 상위 스코프를 결정한다면 bar 함수의  상위 스코프는 foo함수와 전역 일것이다. 두번째 방식으로 함수의 상위 스코프를 결정한다면 bar함수의 상위 스코프는 전역일 것이다.</p>
<p>프로그래밍언어는 일반적으로 이 두가지 방식 중 한가지 방식의 상위 스코프를 결정한다. </p>
<p>첫번째 방식을 종적 스코프라 한다. 함수를 정의하는 시점에서 함수가 어디에서 호출 될지 알 수 없다. 따라서 함수가 호출 되는 시점에 동적으로 상위 스코프를 결정해야하기 때문에 동적 스코프라 부른다.<br>두번째 방식을 렉시컬 스코프 또는 정적 스코프 라한다. 동적 스코프 방식처럼 스코프가 동저긍로 변하지않고 함수 정의가 평가 되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프라고 부른다.<br>자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다. </p>
<p>자바스크립트는 렉시컬 스코프를 따르므로 <strong>함수를 어디에서 호출했는지가 아니라 함수를 어디에서 정의 했는지에 따라 상위 스코프를 결정한다</strong> 즉, 모든 함수 정의(함수 선언문 또는 함수 표현식)는 평가 되어 함수 객체를 생성할때 , 자신이 정의된 스코프를 상위 스코프로서 기억한다. 그리고 함수가 호출되면 언제나 자신이 기억하고 있는 정의된 스코프를 상위 스코프로 사용한다. 함수가 호출되 위치는 함수 자신이 기억하고 있는 스코프, 즉 상위 스코프 결정에 어떠한 영향도 주지않느낟. </p>
<p>위의 졔제의 bar는 함수는 전역에서 정의된 함수이다. 함수 선언문으로 정의된 bar 함수는 전역 코드가 실행되기 전에 먼저 평가되어 함수 객체를 생성한다. 이때 생성된 bar함수 객체는 자신이 정의된 스코프. 즉 전역 스코프를 기억한다. 그리고  bar함수가 호출되면 호출된 곳이 어디인지 관계없이 언제나 자신이 기억하고 있는 전역 스코프를 상위 스코프로 사용한다 .따라서 위 에제를 실행하면 전역 변수 x 의 값의 값 1을 두번 출력한다. </p>
<p>레시컬 스코프는 클로저와 깊은 관계가 있다.</p>
]]></content>
      <tags>
        <tag>스코프란?</tag>
      </tags>
  </entry>
  <entry>
    <title>Set 과 Map</title>
    <url>/2020/05/04/setandmap-md/</url>
    <content><![CDATA[<h1 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h1><p>Set 객체는 중복되지 않는 유일한 값들의 집합(set)이다. Set 객체는 배열과 유사하지만 아래와 같은 점에서 차이가 있다.</p>
<table>
<thead>
<tr>
<th align="left">구분</th>
<th align="center">배열</th>
<th align="center">Set 객체</th>
</tr>
</thead>
<tbody><tr>
<td align="left">동일한 값을 중복하여 포함</td>
<td align="center">○</td>
<td align="center">✕</td>
</tr>
<tr>
<td align="left">요소 순서의 의미</td>
<td align="center">○</td>
<td align="center">✕</td>
</tr>
<tr>
<td align="left">인덱스로 요소에 접근</td>
<td align="center">○</td>
<td align="center">✕</td>
</tr>
</tbody></table>
<p>이러한 Set 객체의 특성은 <a href="https://ko.wikipedia.org/wiki/집합" target="_blank" rel="noopener">수학적 집합</a>의 특성과 일치한다. Set은 수학적 집합을 구현하기 위한 자료 구조이다. Set을 통해 교집합, 합집합, 차집합, 여집합 등을 구현할 수 있다.</p>
<h2 id="1-1-Set-객체의-생성"><a href="#1-1-Set-객체의-생성" class="headerlink" title="1.1. Set 객체의 생성"></a>1.1. Set 객체의 생성</h2><p>Set 객체는 Set 생성자 함수로 생성한다. Set 생성자 함수에 인수를 전달하지 않으면 빈 Set 객체가 생성된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(0) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이때 이터러블의 중복된 값은 Set 객체에 요소로 저장되지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(set1); <span class="comment">// Set(3) &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set2); <span class="comment">// Set(4) &#123;"h", "e", "l", "o"&#125;</span></span><br></pre></td></tr></table></figure>

<p>중복을 허용하지 않는 Set 객체의 특성을 활용하여 배열에서 중복된 요소를 제거할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 배열의 중복 요소 제거</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.filter(<span class="function">(<span class="params">v, i, self</span>) =&gt;</span> self.indexOf(v) === i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniq([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [2, 1, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set을 사용한 배열의 중복 요소 제거</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(array)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniq([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [2, 1, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-요소-개수-확인"><a href="#1-2-요소-개수-확인" class="headerlink" title="1.2. 요소 개수 확인"></a>1.2. 요소 개수 확인</h2><p>Set 객체의 요소 개수를 확인할 때는 Set.prototype.size 프로퍼티를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(3) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.size); // 3</span><br></pre></td></tr></table></figure>

<p>Set.prototype.size 프로퍼티는 setter 함수없이 getter 함수만 존재하는 접근자 프로퍼티이다. 따라서 Set.prototype.size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(Set.prototype, 'size'));</span><br><span class="line">// &#123;<span class="keyword">set</span>: undefined, enumerable: false, configurable: true, <span class="keyword">get</span>: ƒ&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.size = 10; // 무시된다.</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 3</span><br></pre></td></tr></table></figure>

<h2 id="1-3-요소-추가"><a href="#1-3-요소-추가" class="headerlink" title="1.3. 요소 추가"></a>1.3. 요소 추가</h2><p>Set 객체에 요소를 추가할 때는 Set.prototype.add 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(0) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(1) &#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set.prototype.add 메소드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 연속적으로 Set.prototype.add 메소드를 호출할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1).add(2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set 객체에 중복된 요소의 추가는 허용되지 않는다. 단, 이때 에러가 발생하지는 않고 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1).add(2).add(2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>일치 비교 연산자 <code>===</code>을 사용하면 NaN과 NaN을 다르다고 평가한다.(“7.3.1. 동등/일치 비교 연산자” 참고) 하지만 Set 객체는 NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다. 또한 일치 비교 연산자 <code>===</code>와 마찬가지로 +0과 -0도 같다고 평가하여 중복 추가를 허용하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line">console.log(NaN === NaN); // false</span><br><span class="line">console.log(0 === -0); // true</span><br><span class="line"></span><br><span class="line">// NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다.</span><br><span class="line"><span class="keyword">set</span>.add(NaN).add(NaN);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(1) &#123;<span class="literal">NaN</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +0과 -0을 같다고 평가하여 중복 추가를 허용하지 않는다.</span></span><br><span class="line"><span class="keyword">set</span>.add(0).add(-0);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="literal">NaN</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set 객체는 자바스크립트의 모든 값을 요소로 저장할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">  .add(1)</span><br><span class="line">  .add('a')</span><br><span class="line">  .add(true)</span><br><span class="line">  .add(undefined)</span><br><span class="line">  .add(null)</span><br><span class="line">  .add(&#123;&#125;)</span><br><span class="line">  .add([]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>); // Set(7) &#123;<span class="number">1</span>, <span class="string">"a"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, &#123;&#125;, []&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-요소-존재-여부-확인"><a href="#1-4-요소-존재-여부-확인" class="headerlink" title="1.4. 요소 존재 여부 확인"></a>1.4. 요소 존재 여부 확인</h2><p>Set 객체에 특정 요소가 존재하는지 확인하려면 Set.prototype.has 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(2)); // true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(4)); // false</span><br></pre></td></tr></table></figure>

<h2 id="1-5-요소-삭제"><a href="#1-5-요소-삭제" class="headerlink" title="1.5. 요소 삭제"></a>1.5. 요소 삭제</h2><p>Set 객체의 요소를 삭제할 때는 Set.prototype.delete 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 요소 2를 삭제한다.</span><br><span class="line"><span class="keyword">set</span>.delete(2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 요소 1을 삭제한다.</span></span><br><span class="line"><span class="keyword">set</span>.delete(1);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(1) &#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set.prototype.delete 메소드에는 인덱스가 아니라 삭제하려는 요소값을 전달하여야 한다. Set 객체는 순서에 의미가 없다. 다시 말해 배열과 같이 인덱스를 갖지 않는다.</p>
<p>만약 존재하지 않는 Set 객체의 요소를 삭제하려하면 에러없이 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 존재하지 않는 요소 0를 삭제한다.</span><br><span class="line"><span class="keyword">set</span>.delete(0); // 무시된다</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(3) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set.prototype.delete 메소드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다. 따라서 Set.prototype.add 메소드와 같이 연속적으로 호출할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// delete는 불리언 값을 반환한다.</span><br><span class="line"><span class="keyword">set</span>.delete(1).delete(2); // TypeError: <span class="keyword">set</span>.delete(...).delete is not a function</span><br></pre></td></tr></table></figure>

<h2 id="1-6-요소-일괄-삭제"><a href="#1-6-요소-일괄-삭제" class="headerlink" title="1.6. 요소 일괄 삭제"></a>1.6. 요소 일괄 삭제</h2><p>Set 객체의 요소를 일괄 삭제할 때는 Set.prototype.clear 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.clear();</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(0) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-요소-순회"><a href="#1-7-요소-순회" class="headerlink" title="1.7. 요소 순회"></a>1.7. 요소 순회</h2><p>Set 객체의 요소를 순회할 때는 Set.prototype.forEach 메소드를 사용한다. Set.prototype.forEach 메소드는 Array.prototype.forEach 메소드와 유사하게 콜백함수와 forEach 메소드 내부에서 this로 사용될 객체(옵션)를 전달한다. 이때 콜백함수는 아래와 같이 3개의 인수를 전달받는디.</p>
<ul>
<li>첫번재 인수 : 현재 순회중인 요소값</li>
<li>두번재 인수 : 현재 순회중인 요소값</li>
<li>세번재 인수 : 현재 순회중인 Set 객체(this)</li>
</ul>
<p>첫번재 인수와 두번재 인수는 같은 값이다. 이처럼 동작하는 이유는 Array.prototype.forEach 메소드와 인터페이스를 통일하기 위함으로 다른 의미는 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.forEach((v, v2, <span class="keyword">set</span>) =&gt; console.log(v, v2, <span class="keyword">set</span>));</span><br><span class="line">/*</span><br><span class="line">1 1 Set(3) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="built_in">Set</span>(<span class="number">3</span>) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="built_in">Set</span>(<span class="number">3</span>) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<p><strong>Set 객체는 이터러블이다</strong>. 따라서 for…of문으로 순회할 수 있으며 스프레드 문법의 대상이 될 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// Set 객체는 Set.prototype의 Symbol.iterator 메소드를 상속받는 이터러블이다.</span><br><span class="line">console.log(Symbol.iterator in <span class="keyword">set</span>); // true</span><br><span class="line"></span><br><span class="line">// 이터러블인 Set 객체는 for...of 문으로 순회할 수 있다.</span><br><span class="line">for (const value of <span class="keyword">set</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이터러블인 Set 객체는 스프레드 문법의 대상이 될 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log([...set]); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>Set 객체는 요소의 순서에 의미를 갖지 않지만 Set 객체를 순회하는 순서는 요소가 추가된 순서를 따른다. 이는 ECMAScript 사양에 규정되어 있지는 않지만 다른 이터러블의 순회와 호환성을 유지하기 위함이다.</p>
<h2 id="1-8-집합-연산"><a href="#1-8-집합-연산" class="headerlink" title="1.8. 집합 연산"></a>1.8. 집합 연산</h2><p>Set은 수학적 집합을 구현하기 위한 자료 구조이다. Set을 통해 교집합, 합집합, 차집합 등을 구현할 수 있다. 이들 프로토타입 메소드를 구현하면 아래와 같다.</p>
<h3 id="1-8-1-교집합"><a href="#1-8-1-교집합" class="headerlink" title="1.8.1. 교집합"></a>1.8.1. 교집합</h3><p>교집합(A∩B)은 집합 A와 집합 B의 공통 요소로 구성된다</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.intersection = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="comment">// 2개의 set의 요소가 공통되는 요소이면 교집합의 대상이다.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(value)) result.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA와 setB의 교집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.intersection(setB)); <span class="comment">// Set(2) &#123;2, 4&#125;</span></span><br><span class="line"><span class="comment">// setB와 setA의 교집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.intersection(setA)); <span class="comment">// Set(2) &#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.intersection = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...this].filter(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">set</span>.has(v)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const setA = new Set([1, 2, 3, 4]);</span><br><span class="line">const setB = new Set([2, 4]);</span><br><span class="line"></span><br><span class="line">// setA와 setB의 교집합</span><br><span class="line">console.log(setA.intersection(setB)); // Set(2) &#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// setB와 setA의 교집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.intersection(setA)); <span class="comment">// Set(2) &#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-2-합집합"><a href="#1-8-2-합집합" class="headerlink" title="1.8.2. 합집합"></a>1.8.2. 합집합</h3><p>합집합(A∪B)은 집합 A와 집합 B의 중복없는 모든 요소로 구성된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.union = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this(Set 객체)를 복사</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="comment">// 합집합은 2개의 Set 객체의 모든 요소로 구성된 집합이다. 중복된 요소는 포함되지 않는다.</span></span><br><span class="line">    result.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA와 setB의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.union(setB)); <span class="comment">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// setB와 setA의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.union(setA)); <span class="comment">// Set(4) &#123;2, 4, 1, 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.union = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...this, ...set]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA와 setB의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.union(setB)); <span class="comment">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// setB와 setA의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.union(setA)); <span class="comment">// Set(4) &#123;2, 4, 1, 3&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-3-차집합"><a href="#1-8-3-차집합" class="headerlink" title="1.8.3. 차집합"></a>1.8.3. 차집합</h3><p>차집합(A-B)은 집합 A에는 존재하지만 집합 B에는 존재하지 않는 요소들의 집합이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.difference = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this(Set 객체)를 복사</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="comment">// 차집합은 어느 한쪽 집합에는 존재하지만 다른 한쪽 집합에는 존재하지 않는 요소로 구성된 집합이다.</span></span><br><span class="line">    result.delete(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA에 대한 setB의 차집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.difference(setB)); <span class="comment">// Set(2) &#123;1, 3&#125;</span></span><br><span class="line"><span class="comment">// setB에 대한 setA의 차집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.difference(setA)); <span class="comment">// Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.difference = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...this].filter(<span class="function"><span class="params">v</span> =&gt;</span> !<span class="keyword">set</span>.has(v)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const setA = new Set([1, 2, 3, 4]);</span><br><span class="line">const setB = new Set([2, 4]);</span><br><span class="line"></span><br><span class="line">// setA에 대한 setB의 차집합</span><br><span class="line">console.log(setA.difference(setB)); // Set(2) &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// setB에 대한 setA의 차집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.difference(setA)); <span class="comment">// Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-4-부분-집합과-상위-집합"><a href="#1-8-4-부분-집합과-상위-집합" class="headerlink" title="1.8.4. 부분 집합과 상위 집합"></a>1.8.4. 부분 집합과 상위 집합</h3><p>집합 A가 집합 B에 포함되는 경우(A⊆B), 집합 A는 집합 B의 부분 집합이며 집합 B는 집합 A의 상위 집합이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this가 subset의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.isSuperset = <span class="function"><span class="keyword">function</span> (<span class="params">subset</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> subset) &#123;</span><br><span class="line">    <span class="comment">// superset의 모든 요소가 subset의 모든 요소를 포함하는지 확인</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA가 setB의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.isSuperset(setB)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// setB가 setA의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.isSuperset(setA)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this가 subset의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.isSuperset = <span class="function"><span class="keyword">function</span> (<span class="params">subset</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> supersetArr = [...this];</span><br><span class="line">  <span class="keyword">return</span> [...subset].every(<span class="function"><span class="params">v</span> =&gt;</span> supersetArr.includes(v));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA가 setB의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.isSuperset(setB)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// setB가 setA의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.isSuperset(setA)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h1><p>Map 객체는 키와 쌍으로 이루어진 컬렉션이다.   Map객체는 객체와 유사하지만 다음과같은 차이점이 있다.</p>
<table>
<thead>
<tr>
<th align="center">구분</th>
<th align="center">객체</th>
<th align="center">Map객체</th>
</tr>
</thead>
<tbody><tr>
<td align="center">키로 사용할수있는 값</td>
<td align="center">문자열 또는 심볼 값</td>
<td align="center">객체를 포함하는 모든 값</td>
</tr>
<tr>
<td align="center">이터러블</td>
<td align="center">X</td>
<td align="center">O</td>
</tr>
<tr>
<td align="center">크기확인</td>
<td align="center">Object.keys(obj).length</td>
<td align="center">map.size</td>
</tr>
</tbody></table>
<h3 id="2-1-Map-객체의-생성"><a href="#2-1-Map-객체의-생성" class="headerlink" title="2.1 Map 객체의 생성"></a>2.1 Map 객체의 생성</h3><p>Map 객체는 Map 생성자 함수로 생성한다. Map 생성자 함수에 인수를 전달하지않으면 빈 Map객체가 생성된다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>Map 생성자 함수는 이터러블을 인수로 전달 받아 Map객체를 생성한다. 이때 인수로 전달 되는 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성이 되어야한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>,<span class="string">'value1'</span>],[<span class="string">'key1'</span>,<span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map1) <span class="comment">//Map(2) &#123;'lkey1=&gt;'value'm'key2'=&gt;'value2'&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// TypeError: Iterator value 1 is not an entry object</span></span><br></pre></td></tr></table></figure>

<p>중복된 키는 Map 객체의 요소로 저장되지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>,<span class="string">'value2'</span>],[<span class="string">'key1'</span>,<span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(1) &#123;"key1" =&gt; "value1"&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-요소의-개수확인"><a href="#2-2-요소의-개수확인" class="headerlink" title="2.2 요소의 개수확인"></a>2.2 요소의 개수확인</h2><p> Map 객체의 요소의 개수 확인 할때에는 Map.prototype.size 프로퍼티를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>,<span class="string">'value1'</span>],[<span class="string">'key2'</span>,<span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(2) &#123;"key1" =&gt; "value1", "key2" =&gt; "value2"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>Map.prototype.size 프로퍼티는 setter함수 없이 getter함수만 존재하는 접그자 프로퍼티 이다. 따라서 Map.prototype.size 프로퍼티에 숫자를 할당하여 Map 객체의 요소개수를 변경 할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>, <span class="string">'value1'</span>], [<span class="string">'key2'</span>, <span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Map</span>.prototype,<span class="string">'size'</span>));</span><br><span class="line"><span class="comment">//&#123;set:undefined, enumberable:false,configurable:true,get:function&#125;</span></span><br><span class="line"></span><br><span class="line">map.size =<span class="number">10</span>; <span class="comment">//무시된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-요소-추가"><a href="#2-3-요소-추가" class="headerlink" title="2.3 요소 추가"></a>2.3 요소 추가</h2><p>Map 객체의 요소를 추가할 때는 Map.prototype.set메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">//Map(0) &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'key1'</span>,<span class="string">'value1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">//Map(1) &#123;'key1'=&gt;'value1'&#125;;</span></span><br></pre></td></tr></table></figure>

<p>Map.prototype.set메소드는 새로운 요소가 추가된 Map객체를 반환한다. 따라서 연속적으로 Map.prototype.set 메소드를 호출할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'key1'</span>,<span class="string">'value1'</span>)</span><br><span class="line">.set(<span class="string">'key2'</span>,<span class="string">'value2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(2) &#123;'key1'=&gt;'value1','key2'=&gt;'value2'&#125;;</span></span><br></pre></td></tr></table></figure>

<p>Map객체에 중복된 키를 갖는 요소의 추가는 허용되지않는다. 단 이때 에러가 발생하지는 않고 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map</span><br><span class="line">  .set(<span class="string">'key1'</span>, <span class="string">'value1'</span>)</span><br><span class="line">  .set(<span class="string">'key1'</span>, <span class="string">'value2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(1) &#123;"key1" =&gt; "value1"&#125;</span></span><br></pre></td></tr></table></figure>

<p>객체는 문자열 또는 심볼 값만을 키로 사용할수 있지만 Map객체의 키 타입에는 제한이 없다. 따라서 객체는 포함한 모든 값을 키로 사용할 수 있다. 이는 Map 객체와 일반 객체의 가장 두드러지는 차이이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> lee  = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim = &#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line">map.set(lee,<span class="string">'developer'</span>)</span><br><span class="line">.set(kim,<span class="string">'developer'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(2) &#123; &#123;name:'lee'&#125;=&gt; 'developer',&#123;name:'kim'&#125;=&gt;'developer' &#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-요소-취득"><a href="#2-4-요소-취득" class="headerlink" title="2.4 요소 취득"></a>2.4 요소 취득</h2><p>Map객체의 요소를 취득 할때 는 Map.prototype.get메소드를 사용한다. Map객체에 해당하는 ㅣ를 갖는 요소가 존재하지 않으면 undefined을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line">map.set(lee,<span class="string">'deveoper'</span>).set(kim,<span class="string">'developer'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(lee)); <span class="comment">///developer;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'key'</span>)) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-요소-존재-여부-확인"><a href="#2-5-요소-존재-여부-확인" class="headerlink" title="2.5 요소 존재 여부 확인"></a>2.5 요소 존재 여부 확인</h2><p> Map객체에 특정 요소가 존재하는지 확인 하려면  Map.prototype.has메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(lee)) <span class="comment">//true;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'key'</span>)) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-요소의-삭제"><a href="#2-6-요소의-삭제" class="headerlink" title="2.6 요소의 삭제"></a>2.6 요소의 삭제</h2><p>Map객체의 요소를 삭제할때에는 Map.prototype.delete메소드를 사용한다. 만약 존재하지 않는 Map객체의 요소를 삭제 하려면 에러없이 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line">map.delete(kim);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(1) &#123;&#123;name:'lee'&#125;=&gt;'developer'&#125;;</span></span><br></pre></td></tr></table></figure>

<p>Map.prototype.delete 메소드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다. 따라서 Map.prototype.set 메소드와 같이 연속적으로 호출 할수없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim=&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]);</span><br><span class="line"></span><br><span class="line">map.delete(lee).delete(kim) <span class="comment">//TypeError: map.delete(...).delete is not a function</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7-요소의-일괄-삭제"><a href="#2-7-요소의-일괄-삭제" class="headerlink" title="2.7 요소의 일괄 삭제"></a>2.7 요소의 일괄 삭제</h2><p>Map 객체의 요소를 일괄 삭제 할때는 Map.prototype.clear 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim=&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line">map.clear();</span><br><span class="line">consoleg.log(map) <span class="comment">//Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-요소의-순회"><a href="#2-8-요소의-순회" class="headerlink" title="2.8 요소의 순회"></a>2.8 요소의 순회</h2><p>Map 객체의 요서를 순회할 때는 Map.prototype.forEach메소드를 사용한다. Map.prototype.forEach메소드는 Array.prototype.forEach메소드와 유사하게 콜백함수와 forEach 메소드 내부에서 this로 사용 될 객체(옵션)를 전달한다. 이때 콜백 함수는 다음과 다팅 3개의 인수를 받는다.</p>
<ul>
<li>첫번째 인수 : 현재 순회중인 요소 값</li>
<li>두번째 인수 : 현재 순회중인 요소 키</li>
<li>세번째 인수 : 현재 순회중인 Map객체(this)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function">(<span class="params">v,k,map</span>)=&gt;</span>consoel.log(v,k,map));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">developer &#123;name: "Lee"&#125; Map(2) &#123;</span></span><br><span class="line"><span class="comment">  &#123;name: "Lee"&#125; =&gt; "developer",</span></span><br><span class="line"><span class="comment">  &#123;name: "Kim"&#125; =&gt; "designer"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">designer &#123;name: "Kim"&#125; Map(2) &#123;</span></span><br><span class="line"><span class="comment">  &#123;name: "Lee"&#125; =&gt; "developer",</span></span><br><span class="line"><span class="comment">  &#123;name: "Kim"&#125; =&gt; "designer"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Map객체는 이터러블이다 .따라서 for …of문으로  순회할수있으며 스프레드 문법의 대상이 될 수 도있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map rorcpsms Map.prototype의 Symbol.iterator 메소드를 상속받는 이터러블 이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> map) <span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//이터러블인 Map객체는 for...of문으로 순회할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> entry <span class="keyword">of</span> map)&#125;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry) <span class="comment">//[&#123;name:'lee'&#125;=&gt;'developer'][&#123;name:'kim'&#125;=&gt;'designer']</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//이터러블인  Map객체는 스프레드 문법의 대상이 될수있다.</span></span><br><span class="line"><span class="built_in">console</span>.log([...map]);</span><br><span class="line"><span class="comment">//[[&#123;name:'lee'&#125;,'developer'],[&#123;name:'kim'&#125;,'designer']];</span></span><br></pre></td></tr></table></figure>

<p>Map은 이터러블이면서 동시에 이터레이터인 객체를 반환하는 메소드를 제공한다.</p>
<ul>
<li>Map.prototype.keys 메소드는 Map객체에서 요소 키를 값으로 갖는 이터레이터를 반환한다.</li>
<li>Map.prototype.values메소드는 Map객체에서 요소값을 값으로 갖는 이터레이터를 반환한다.</li>
<li>Map.prototype.entries메소드는  Map객체에서 요소 키와 요소 값을 값으로 갖는 이터레이터를 반환한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">of</span> map.keys())&#123;</span><br><span class="line">  consoel.log(key) <span class="comment">//&#123;name:'lee'&#125;&#123;name:'kim'&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> value <span class="keyword">of</span> map.values())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//developer designer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> entry <span class="keyword">of</span> map.entries())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry) <span class="comment">//[&#123;name:'lee'&#125;,'developer'] [&#123;name:'kim'&#125;,''designer];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map객체는 요소의 순서에 의미를 갖지 않지만 Map객체를 순회하는 순서는 요소가 추가된 순서를 따른다.<br>이는 ECMAScript 사양에 규정되어 있지는 않지만 다른 이터러블의 순회와 호환성을 유지하기 위함이다.</p>
]]></content>
      <tags>
        <tag>Set  과  Map에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>tabindex을 이용한 키보드 접근성</title>
    <url>/2019/09/22/tabindex%EC%9D%84%EC%9D%B4%EC%9A%A9%ED%95%9C%ED%82%A4%EB%B3%B4%EB%93%9C%EC%A0%91%EA%B7%BC%EC%84%B1/</url>
    <content><![CDATA[<p>키보드의 접근성을 고려한 tabindex의 사용.</p>
<p>tabindex는 기본적으로  키보드의 tab키를 눌렀을 때 이동순서를 임의로 조정 할 수 있는 html의 속성 입니다. tabindex의 포커스의 순서를 부여하는 방식을 tabintdex 값에 양의정수를 넣어주면 됩니다. 예를 들어 어떤 html요소에 taindex=”1”을 주었다면 해당 웹 페이지 상에서 tab키를 눌렀을때 tabindex=”1”이 부여하는 요소가 가장 먼저 포커스 됩니다. 그러나 taindex는 신중하게 사용해야 할 필 요가 있습니다. 일반적으로 키보드의  tab키를 눌렀을때 포커스는 html의 마크업 순서를 따르며 링크요소 또는 폼 요소등 tab키로 포커스를 가질 수  있는 요소에 마크업 순서에 따라 자연스럽게 이동합니다. 기본적으로 마크업이 논리적으로 이루어져 있다면 굳이 tabindex을 사용할 이유가 없습니다. 오히려 잘못된 tabindex를 사용함으로써 스크린 리더 사용자가 웹 페이지의 구조를 이해하는데 어려움으로 작용하게 될 수 있습니다.</p>
<p>tabindex는 위에서 설명한것 같이 마크업 순서가 논리적으로 잘 구성되어있다면 대체로 사용할 필요가 없습니다. 임의의 페이지에 처음  접속하는 필수 회원 로그인을 행하는 경우 폼 요소에 tabindex를 부여하여 먼저 회원 로그인을 유도하는등의 이유로 사용할 수는 있습니다. 그러나 이러한 경우에도 페이지 로딩 시autofocus기능을 사용하여 회원 로그인을 유도하는 것이 바람직하다고 생각합니다. 그럼 tabindex는 언제 사용할까요?</p>
<p>웹페이지를 구성하다 보면 페이지 탐색에 논리적 순서를 부여하는 사용자가 자연스럽게 페이지를 탐색할 수 있도록합니다.</p>
<p>tabindex속성은 양의정수값 이외에 0과 -1의 값을 가질 수도 있습니다. 먼저 tabindex=”0”은 tab키를 눌렀을때 포커스를 받을 수없는 요소 이를테면 <span>등의 요소에 포커스를 받게 할 수 있습니다.  반면 -1은 기본적으로 tab키를 눌렀을때 포커스받을 수있는 폼 요소나 링크 요소를 강제로  포커스 받지 못하도록 하는 값입니다. </span></p>
]]></content>
      <tags>
        <tag>tabindex을 이용한 키보드 접근성 및 간단한 내용 정리</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbol 타입</title>
    <url>/2020/05/06/symbol-md/</url>
    <content><![CDATA[<h1 id="1-Symbol-이란"><a href="#1-Symbol-이란" class="headerlink" title="1.Symbol 이란?"></a>1.Symbol 이란?</h1><p>1997년 자바스크립트의 ECAMScript로 처음 표준화된 이래로 자바스크립트에는 6개의 타입 즉 String,Number,boolean,undefined,null,Object가 있었다. </p>
<p>심볼은(symbol)은 es6에서 새롭게 추가된 7번째 타입으로 변경이 불가능한 원시타입이다. <strong>다른 값과 중복되지 않는 유일무이한 값이다.</strong> 따라서 주로 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용된다.</p>
<p>객체의 프로퍼티 키로 사용할 수 있는 값은 빈 문자열을 포함한 모든 문자열 또는 심볼값이다.</p>
<h1 id="2-Symbol의-생성"><a href="#2-Symbol의-생성" class="headerlink" title="2.Symbol의 생성"></a>2.Symbol의 생성</h1><p>##2.1. Symbol 함수</p>
<p>심볼 값은 Symbol 함수를 호출하여 생성한다. 다른 원시 값은, 즉 문자열,숫자,불리언 ,undefined,null은 타입의 값은 리터럴 표기법을 통해 값을 생성할 수 있지만 심볼값은 심볼을 함수를 호출해야 생성해야한다. 이<u>때 생성된 심볼 값은 노출 되지 않으며 다른 값과 절대 중복 되지 않는 유일무이한 값이다.</u></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Symbol 함수를 호출하여 유일무이한 심볼값을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//심볼 값은 노출되지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(mySymbol) <span class="comment">// Symbol();</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> mySymbol) <span class="comment">//symbol</span></span><br></pre></td></tr></table></figure>

<p> 언뜻 보면 생성자 함수로 객체를 생성하는 것 처럼 보이지만 Symbol함수는 String, number, Boolean 생성자 함수와는 달리 new 연산자를 사용하지 않는다. new연산자와 함께 생성자 함수 또는 클래스를 호출하면 객체 (인스턴스)가 생성되지만 심볼 값은 변경이 불가능한 원시 값 이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>();  <span class="comment">//TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>Symbol 함수에는 선택적으로 문자열을 인수로 전달 할 수 있다. 이 문자열은 생성된 심볼 값에 대한 설명으로 디버깅 용도로만 사용되며 심볼 값 생성에 어떠한 영향을 주지 않는다. 즉 심볼 값에 대한 설명이 같더라도 생성되 값은 <u>유일무이한 값이다.</u></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//심볼 값에 대한 설명이 같더라도 유일무이한 심볼 값을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> mySymbol1 = <span class="built_in">Symbol</span>(<span class="string">'mySymbol'</span>);</span><br><span class="line"><span class="keyword">const</span> mySymbol2 = <span class="built_in">Symbol</span>(<span class="string">'mySymbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mySymbol1 === mySymbol2); <span class="comment">//false;</span></span><br></pre></td></tr></table></figure>

<p>심볼 값도 문자열,숫자,불리언과 같이 객체처럼 접근하면 암묵적으로 래퍼 객체를 생성한다. 아래 예제는 description  프로퍼티와 toString  메소드는 Symbol.prototype의 프로퍼티 이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 심볼도 래퍼 객체를 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>(<span class="string">'mySymbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mySymbol.description) <span class="comment">//mySymbol</span></span><br><span class="line"><span class="built_in">console</span>.log(mySymbol.toString()) <span class="comment">//Symbol(mySymbol)</span></span><br></pre></td></tr></table></figure>

<u>

<p><strong>심볼 값은 암묵적으로 문자열이나 숫자 타입으로 변화되지 않는다.</strong></p></u><p></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//심볼 값은 암묵적인 타입 변환이 되지않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(mySymbol +<span class="string">''</span>) <span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line"><span class="built_in">console</span>.log(+mySymbol);  <span class="comment">/// TypeError: Cannot convert a Symbol value to a string</span></span><br></pre></td></tr></table></figure>

<p>단 불리언 타입으로는 암묵적으로 타입 변환이 된다. 이를 통해 if문 등에서 존재 확인이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//불리언 타입으로는 암묵적으로 타입 변환이 된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(!!mySymbol)<span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if문 등에서 존재 확인을 위해 사용할 수 있다.</span></span><br><span class="line"><span class="keyword">if</span>(mysymbol)<span class="built_in">console</span>.log(<span class="string">'mysymbol is not empty'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Symbol-for-메소드"><a href="#2-2-Symbol-for-메소드" class="headerlink" title="2.2. Symbol.for 메소드"></a>2.2. Symbol.for 메소드</h2><p>Symbol.for 메소드는 인수로 전달받은 문자열을 키로 사용히여 키와 심볼의 값의 쌍들이 저장되어 있는 전역 심볼 레지스트리에 해당하는 키와 일치하는 심볼값을 검색한다.</p>
<li>검색에 성공하면 새로운 심볼 값을 생성하지않고 검색된 심볼 값을 반환한다.</li>

<li>검색 실패하면 새로운 심볼값을 생성하여 Symbol.for 메소드의 인수로 전달되는 전역 Symbol 레지스트리에 저장한 후, 생성된 심볼을 반환한다.</li>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//전역 심볼 레지스트리에 mySymbol이라는 키로 저장된 심볼 값이 없으면 새로운 심볼 값을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'mySymbol'</span>);</span><br><span class="line"><span class="comment">//전역 심볼 레지스트리에 mySymbol이라는 키로 저장된 심볼 값이 있으면 해당 심볼 값을 반환</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">''</span>mySymbol);</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>Symbol함수는 호출될때 마다 유일무이한 심볼 값을 생성한다. 이때 자바 스크립트 엔진이 관리하는 심볼 값 저장소인 전역 심볼 레지스트리에서 심볼 값을 검색 할 수 있는 키를 지정 할 수 없으므로 전역 심볼 레지스트리에 등록되어 관리되지않는다.<br>하지만 Symbol.for메소드를 사용하면 애플리케이션 전역에서 중복되지않는 유일무이한 상수인 심볼 값을  단 하나만 생성하여 전역 심볼의 레지스크리를 통해 공유 할 수 있다.<br>Symbol.keyFor 메소드를 사용하면 전역 심볼 레지스트리에 저장된 심볼 값의 키를 추출할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//전역 심볼을 레지슽크리에 mySymbol이라는 키로 심볼 값이 없으면 새로운 심볼 값을 생성</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>.for(<span class="string">'mySymbol'</span>);</span><br><span class="line"><span class="comment">//전역 심볼 레지스트리에 저장된 심볼 값의 키를 추출</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s)) <span class="comment">//mySymbol</span></span><br></pre></td></tr></table></figure>

<h1 id="3-Symbol과-상수"><a href="#3-Symbol과-상수" class="headerlink" title="3. Symbol과 상수"></a>3. Symbol과 상수</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//위,아래,오른쪽,왼쪽을 나타내는 상수</span></span><br><span class="line"><span class="comment">//값 1,2,3,4에는 특별한 의미가 없고 상수 이름에 의미가 있다.</span></span><br><span class="line"><span class="keyword">const</span> Direction =&#123;</span><br><span class="line">  UP:<span class="number">1</span>,</span><br><span class="line">  DOWN:<span class="number">2</span>,</span><br><span class="line">  LEFT:<span class="number">3</span>,</span><br><span class="line">  RIGHT:<span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//변숭에 상수를 할당</span></span><br><span class="line"><span class="keyword">const</span> myDirection = Direction.UP;</span><br><span class="line"><span class="keyword">if</span>(myDirection === Diretion.UP)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'You are going up'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제와 같이 값에는 특별한 의미가 없고 상수이름 자체에 의미가 있는 경우가 있다. 이때 문제는 상수 1,2,3,4가 다른 변수 값과 중복 될 수 있다는 것이다. 이러한 경우 중복될 가능성이 있는 무의미한 상수 대신 중복될 가능성이 없는 유일 무이한 심볼값을 사용 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//위,알래,오른쪽,왼쪽을 나태내는 상수.</span></span><br><span class="line"><span class="comment">//중복될 기능성이 없는 심볼 값으로 상수값을 생성</span></span><br><span class="line"><span class="keyword">const</span> Direction =&#123;</span><br><span class="line">  UP:<span class="built_in">Symbol</span>(<span class="string">'up'</span>),</span><br><span class="line">  DOWN:<span class="built_in">Symbol</span>(<span class="string">'down'</span>),</span><br><span class="line">  LEFT:<span class="built_in">Symbol</span>(<span class="string">'left'</span>),</span><br><span class="line">  RIGHT:<span class="built_in">Symbol</span>(<span class="string">'right'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//변수에 상수를 할당</span></span><br><span class="line"><span class="keyword">const</span> Direction = Direction.UP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(myDirection === Direction.UP)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'you are going up'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>enum</strong><br><strong>enum은</strong> 명명된 숫자 상수의 집합으로 열거형이라고 부른다. 자바스크립트는 enum을 지원하지는 않지만 C,Java,Python 등 많은 프로그래밍 언어와 자바 스크립트으 Superset(상위 확장)인 TYpeScript에서  enum을 지원하고 있다. 자바스크립트세서 enum을 흉내내어 사용하려면 아래와 같이 객체의 변경을 방지 하기 위해 객체를 동결  하는 Object.freeze 메소드와 심볼 값을 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Javascript enum</span></span><br><span class="line"><span class="comment">//Direction 객체는 불변객체이며 프로퍼티는 유일무이한 값이다.</span></span><br><span class="line"><span class="keyword">const</span> Direction = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">   UP: <span class="built_in">Symbol</span>(<span class="string">'up'</span>),</span><br><span class="line">   DOWN: <span class="built_in">Symbol</span>(<span class="string">'down'</span>),</span><br><span class="line">   LEFT: <span class="built_in">Symbol</span>(<span class="string">'left'</span>),</span><br><span class="line">   RIGHT: <span class="built_in">Symbol</span>(<span class="string">'right'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//변수에 상수를 할당</span></span><br><span class="line"><span class="keyword">const</span> myDirection = Diection.UP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(myDirection === Direction.UP)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'You are going up'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Symbol과-프로퍼티-키"><a href="#4-Symbol과-프로퍼티-키" class="headerlink" title="4. Symbol과 프로퍼티 키"></a>4. Symbol과 프로퍼티 키</h1><p>객체의 프로퍼티키는 빈 문자열을 포함하는 모든 문자열 또는 심볼 값으로 만들수 있느며 동적으로 생성 할 수 도 있다.</p>
<p>심볼 값으로 프로퍼티 키를 동적으로 생성하여 만들어 보자. 심볼 값을 프로퍼티 키로 사용하려면 프로퍼티 키를 사용할 심볼 값에 대괄호를 사용해야한다. 프로퍼티에 접근 할때도 마찬가지로 대괄호를 사용해야한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">  <span class="comment">//심볼 값으로 프로퍼티 키를 동적 생성</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.for(<span class="string">'mySymbol'</span>)]:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>.for(<span class="string">'mySymbol'</span>)]) <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p><strong>심볼 값은 유일무이한 값이므로 심볼 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지않는다.</strong> 기존 프로퍼티 키와 충돌하지않는 것은 물론,미래에 추가될 어떤 프로퍼티 키와도 충돌할 위험이 없다.</p>
<h1 id="5-Symbol과-프로퍼티-은닉"><a href="#5-Symbol과-프로퍼티-은닉" class="headerlink" title="5. Symbol과 프로퍼티 은닉"></a>5. Symbol과 프로퍼티 은닉</h1><p>심볼 값으로 동적으로 프로퍼티 키로 만든 프로퍼티는 for ..in 문이나 Object.keys,Object.getOwnPropertyNames 메소드로 찾을 수 없다. 이처럼 심볼 값을 동적으로 생성한  프로퍼티 키로 프로퍼티를 만들면 프로퍼티를 숨길 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">  <span class="comment">//심볼 값으로 프로퍼티 키를 동적 생성</span></span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'mySymbol'</span>)]:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key) <span class="comment">//아무것도 출력되지않는다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ObJect.keys(obj)) <span class="comment">//[];</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj)); <span class="comment">//[]</span></span><br></pre></td></tr></table></figure>

<p>하지만 프로퍼티를 완전히 숨길 수 있는 것은 아니다. Es6에서 도입된  Object.getOwnPropertySymbols 메소드를 사용하면 심볼값으로 동적 생성한 프로퍼티 키로 만든 프로퍼티를 찾을 수있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">  <span class="comment">//심볼 값으로 프로퍼티 키 동적 생성</span></span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'mySymbol'</span>)]:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj)) <span class="comment">//[Symbol(mySymbol)];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//심볼 값을 찾을 수 있다.</span></span><br><span class="line"><span class="keyword">const</span> symbolKey1 = <span class="built_in">Object</span>.getOwnpropertySymbols(obj)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(obj[symbolKey1]); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h1 id="6-Symbol-과-표준-빌트인-객체-확장"><a href="#6-Symbol-과-표준-빌트인-객체-확장" class="headerlink" title="6. Symbol 과 표준 빌트인 객체 확장"></a>6. Symbol 과 표준 빌트인 객체 확장</h1><p>일반적으로 표준 빌트인 객체에 사용자 정의 메소드를 직접 추가하여 확장하는 것은 권장 하지않는다  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 표준 빌트인 객체를 확장하는 것은 권장하지않는다.</span></span><br><span class="line"><span class="comment">//즉 ,Array.prototype은 읽기 전용으로 사용하는 것의 좋다.</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p+c,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>].sum()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>그 이유는 개발자가 직접 추가한 메소드는 미래에 표준 사양으로 추가될 메소드가 이름이 중복 될 수있기 때문이다. 예를 들어 Array.prototype.find메소드가 Es6의 새롭게 도입되기 이전에 Array.prototype에 find을 집겁 추가 했다면 새롭게 도입된Es6.find 메소드와 이름이 중복되어 Es6의 Array.prototype.find 와 이름이 중복 되어 Es6의 Array.prototype.find 메소드를 이전에 추가했던 사용자 정의 find 메서드가 덮어 쓴다. 표준 빌트인 메소드를 사용자 정의 메소드가 된다면 문제가 된다. </p>
<p>하지만 중복될 가능성이 없는 심볼 값으로 프로퍼티 키를 생성하여 표준 빌트린 객체를 확장하면 표준 빌트인 객체의 기존 프로퍼티 키와 충돌 되지 않는  것은 물론 , 버전이 올라감에 따라 추가 될지도 모르는 어떤 프로퍼티 키와도 충돌 될 위험없이 안전하게 표준 빌트인 객체를 확장 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//심볼 값으로 프로퍼티 키를 동적 생성하면 다른 프로퍼티 키와 절대 충돌하지않는다.</span></span><br><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.for(<span class="string">'sum'</span>)] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p+c,<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>][<span class="built_in">Symbol</span>.for(<span class="string">'sum'</span>)]()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h1 id="7-Well-known-Symbol"><a href="#7-Well-known-Symbol" class="headerlink" title="7. Well known Symbol"></a>7. Well known Symbol</h1><p>자바스크립트가 기본 제공하는 빌트인 심볼 값이 있다. 빌트인 심볼 값은 Symbol 함수의 프로퍼티에 할당되어있다. 브라우저 콘솔에서 Symbol 함수를 참조하여 보자.<br> <img src="https://poiemaweb.com/assets/fs-images/33-1.png" alt="33-1"></p>
<p>자바스크립트가 기본 제공하는 빌트인 심볼 값을 Well-Known-Symbol이라 부른다. Well-Known-Symbol은 자바스크립트 엔진의 내부 알고리즘에 사용된다.</p>
<p>예를 들어 배열, String객체, arguments 객체와 같이 for..of 문으로 순회가 가능한 빌트인 이터러블은 Well-Known-Symbol인 Symbol.iterator를 키로 갖는 메소드를 가지며, Symbol.iterator메소드를 호출하면 이터레이터를 반환하도록 ECAMAScript 사양에 규정되어 있다. 빌트인 이터러블은 이 규정을 준수하고 있다.</p>
<p>만약에 빌트인 이터러블이 아닌 일반객체를 이터러블 처럼 동작하도록 구현하고 싶다면 이 규정(이터레이션 프로토콜)을 따르면 된다. 즉 ECMAScript 사양에 규정 되어 있는 대로  Well-Known-Symbol인 Symbol.iterator을 키로  깆는 메소드를 객체에 추가하고 이터레이터를 반환하도록 구현하면 그 객체는 이터러블이 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 - 5 사이의 정수로 이루어진 이터러블</span></span><br><span class="line"><span class="keyword">const</span> iterable =&#123;</span><br><span class="line">  <span class="comment">//Symbol.iterator 메소드를 구형하여 이터러블 프로토콜을 준수</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">    <span class="keyword">let</span> cur =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> max = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//Symbol.iterator 메소드는 next메소드를 소유한 이터레이터를 반환</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next();</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">      value:cur++,</span><br><span class="line">      done:cur&gt;max+<span class="number">1</span></span><br><span class="line">    	&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> iterable)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num); <span class="comment">//1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>빌트인 이터러블</strong><br>이터러블은 for…of문으로 순회할 수 있고 스프레드 문법의 피연산자가 될 수 도 있는 객체를 말한다. 자바스크립트가 기본 제공하는 빌트인 이터러블은 아래와 같다.</p>
<table>
<thead>
<tr>
<th align="center">빌트인 이터러블</th>
<th align="center">프로퍼티 키가 Symbol.iterator인 메소드</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Array</td>
<td align="center">Array.prototype[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">String.prototype[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">Map</td>
<td align="center">Map.prototype[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">Set</td>
<td align="center">Set.prototype[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">TypedArray</td>
<td align="center">TypedArray.prototype[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">arguments</td>
<td align="center">arguments[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">DOM 컬렉션</td>
<td align="center">NodeList.prototype[Symbol.iterator], HTMLCollection.prototype[Symbol.iterator]</td>
</tr>
</tbody></table>
<p>이때 일반 객체에 추가해야하는 메소드의 키 Symbol.iterator은 기존 프로퍼티 키 또는 미래에 추가될 프로퍼티 키와 절대로 중복되지 않을 것이다.</p>
<p>이처럼 심볼은 중복되지 않는 상수값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지않고 새로운 프로퍼티를 추가하기 위해 ,즉 하위 호환성을 보장하기 위해 도입되었다.</p>
]]></content>
      <tags>
        <tag>Symbol 타입에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>타입 엘리어스(타입별칭)</title>
    <url>/2020/06/14/type-alias-md/</url>
    <content><![CDATA[<p>타입 엘리어스는 새로운 타입을 정의한다. 타입으로 사용할 수 다는 점에서 타입 엘리어스는 인터페이스와 유사하다.  인터페이스는 다음과 같이 타입으로 사용할 수 있다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  age?:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//빈객체를 Person타입으로 지정</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;&#125; <span class="keyword">as</span> Person;</span><br><span class="line">person.name = <span class="string">'kim'</span>;</span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line">person.address = <span class="string">'Seoul'</span> <span class="comment">//Error;</span></span><br></pre></td></tr></table></figure>

<p>타입 엘리어스도 인터페이스와 마찬가지로 타입으로 사용할 수있다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//타입 엘리어스</span></span><br><span class="line"><span class="keyword">type</span> Person&#123;</span><br><span class="line">name:<span class="built_in">string</span>,</span><br><span class="line">age?:<span class="built_in">number</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//빈 객체를 Person타입으로 지정</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;&#125; <span class="keyword">as</span> Person;</span><br><span class="line">person.name = <span class="string">'kim'</span>;</span><br><span class="line">person.age = <span class="number">20</span>;</span><br><span class="line">person.address = <span class="string">'Seoul'</span> <span class="comment">//Error;</span></span><br></pre></td></tr></table></figure>

<p>하지만 타입 엘리어스는  원시값, 유니온 타입 ,튜플 등도 타입으로 지정 할 수 있다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//문자열 리터럴로 타입 지정</span></span><br><span class="line"><span class="keyword">type</span> Str = <span class="string">'kim'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//유니온 타입으로 타입 지정</span></span><br><span class="line"><span class="keyword">type</span> Union = <span class="built_in">string</span> | <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//문자열 유니온 타입으로 타입 지정</span></span><br><span class="line">typ Name = <span class="string">'kim'</span>| <span class="string">'lee'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//숫자 리터럴로 유니온 타입으로 타입 지정</span></span><br><span class="line"><span class="keyword">type</span> Num = <span class="number">1</span>| <span class="number">2</span> | <span class="number">3</span> | <span class="number">4</span> | <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//객체 리터럴 유니온 타닙으로 타입 지정</span></span><br><span class="line">typs Obj = &#123;a:<span class="number">1</span>&#125; | &#123;b:<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//함수 유니온 타입으로 타입지정</span></span><br><span class="line"><span class="keyword">type</span> Fuc = <span class="function">(<span class="params">(<span class="params"></span>)=&gt;<span class="built_in">string</span></span>) | (<span class="params">(<span class="params"></span>)=&gt; <span class="built_in">void</span></span>);</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">                           </span></span><br><span class="line"><span class="function">//인터페이스 유니온 타입으로 타입 지정</span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">Shape</span> = <span class="params">Square</span> | <span class="params">Rectangle</span> | <span class="params">Circle</span>;</span></span><br><span class="line"><span class="function">                           </span></span><br><span class="line"><span class="function">//튜플로 타입지정</span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">Tuple</span> = [<span class="params">string</span> ,<span class="params">boolean</span>];</span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">t</span>:<span class="params">Tuple</span> = ['',1]</span></span><br><span class="line"><span class="function"><span class="params">const</span> <span class="params">f</span>:<span class="params">Tuple</span> = ['',''] //<span class="params">Error</span> 지정한 타입만 가능하다.</span></span><br></pre></td></tr></table></figure>

<p>인터페이스는 extends 또는 implements 될 수 있지만 타입 엘리어스는 extends , implements 될 수 없다. 즉 상속을 통해 확장이 필요하다면 타입 엘리어스보다는 인터페이스가 유리하다. 하지만 인터 페이스로 표현 할 수없거나 유니온 타입 또는튜플을 사용해야한다면 타입 엘리어스를 사용하는 것이 유리하다. </p>
<p><strong><u>그러나 현시점에서는 type도 extends , implements 모두 사용 가능하도록 변경 되었다.</u></strong> </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> test = &#123;</span><br><span class="line">  a:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> inter <span class="keyword">extends</span> test&#123; <span class="comment">//ok</span></span><br><span class="line">  b:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Test <span class="keyword">implements</span> inter&#123;<span class="comment">// ok</span></span><br><span class="line"> <span class="keyword">public</span> a = <span class="number">1</span>;</span><br><span class="line"> <span class="keyword">public</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Test2 <span class="keyword">implements</span> test&#123; <span class="comment">//ok</span></span><br><span class="line">  <span class="keyword">public</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>타입 엘리어스(타입별칭)에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>타입 스크립트 정적 타이핑</title>
    <url>/2020/06/17/type-declaration/</url>
    <content><![CDATA[<h1 id="1-타입-선언"><a href="#1-타입-선언" class="headerlink" title="1. 타입 선언"></a>1. 타입 선언</h1><p>TypeScript는 다음 같이 변수 명 뒤에 타이븡ㄹ 명시하는 것으로 타입을 선언 할 수 있다. </p>
 <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//변수 foo는 string 타입이다.</span></span><br><span class="line"><span class="keyword">let</span> foo;<span class="built_in">string</span> = <span class="string">'hihi'</span>;</span><br></pre></td></tr></table></figure>

<p>선언한 타입에 맞지않는 값을 할당하면 컴파일 시점에서 에러가 발생한다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bar:<span class="built_in">number</span> = <span class="literal">true</span>; <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<p> 이러한 타입선언을 개발자가 코드를 에측할 수 있도록 돕는다. 또한 타입 선언은 강력한 타입체크를 가능하게 하여 문법 에러나 타입고 일치 하지않는 할당 증 기본적인 오류는 런타임 이전에 검출한다.</p>
<p>함수의 매개변수와 반환값에 대한 타입 선언 방법은 다음과 같다. 일반 변수와 마찬가지로 선언된 타입에 일치 하지 않는 값이 주어지면 에러가 발생한다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//함수 선언식</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply1</span>(<span class="params">x:<span class="built_in">number</span> ,y:<span class="built_in">number</span></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//함수 표현식</span></span><br><span class="line"><span class="keyword">const</span> multiply2 = (x:<span class="built_in">number</span>,y:<span class="built_in">number</span>):<span class="function"><span class="params">number</span> =&gt;</span> x * y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multiply1(<span class="number">10</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">console</span>.log(multiply2(<span class="number">10</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(multiply1(<span class="literal">true</span>, <span class="number">1</span>)); <span class="comment">// error</span></span><br></pre></td></tr></table></figure>

<p>TypeScript는 ES5, ES6의 상위확장이므로 자바스크립트의 타입을 그대로 사용할 수 있다. 자바스크립트 타입 이외에도 TypeScript 고유의 타입이 추가로 제공된다. </p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="center">JS</th>
<th align="center">TS</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="center">◯</td>
<td align="center">◯</td>
<td align="left">true와 false</td>
</tr>
<tr>
<td align="left">null</td>
<td align="center">◯</td>
<td align="center">◯</td>
<td align="left">값이 없다는 것을 명시</td>
</tr>
<tr>
<td align="left">undefined</td>
<td align="center">◯</td>
<td align="center">◯</td>
<td align="left">값을 할당하지 않은 변수의 초기값</td>
</tr>
<tr>
<td align="left">number</td>
<td align="center">◯</td>
<td align="center">◯</td>
<td align="left">숫자(정수와 실수, Infinity, NaN)</td>
</tr>
<tr>
<td align="left">string</td>
<td align="center">◯</td>
<td align="center">◯</td>
<td align="left">문자열</td>
</tr>
<tr>
<td align="left">symbol</td>
<td align="center">◯</td>
<td align="center">◯</td>
<td align="left">고유하고 수정 불가능한 데이터 타입이며 주로 객체 프로퍼티들의 식별자로 사용(ES6에서 추가)</td>
</tr>
<tr>
<td align="left">object</td>
<td align="center">◯</td>
<td align="center">◯</td>
<td align="left">객체형(참조형)</td>
</tr>
<tr>
<td align="left">array</td>
<td align="center"></td>
<td align="center">◯</td>
<td align="left">배열</td>
</tr>
<tr>
<td align="left">tuple</td>
<td align="center"></td>
<td align="center">◯</td>
<td align="left">고정된 요소수 만큼의 타입을 미리 선언후 배열을 표현</td>
</tr>
<tr>
<td align="left">enum</td>
<td align="center"></td>
<td align="center">◯</td>
<td align="left">열거형. 숫자값 집합에 이름을 지정한 것이다.</td>
</tr>
<tr>
<td align="left">any</td>
<td align="center"></td>
<td align="center">◯</td>
<td align="left">타입 추론(type inference)할 수 없거나 타입 체크가 필요없는 변수에 사용. var 키워드로 선언한 변수와 같이 어떤 타입의 값이라도 할당 가능.</td>
</tr>
<tr>
<td align="left">void</td>
<td align="center"></td>
<td align="center">◯</td>
<td align="left">일반적으로 함수에서 반환값이 없을 경우 사용한다.</td>
</tr>
<tr>
<td align="left">never</td>
<td align="center"></td>
<td align="center">◯</td>
<td align="left">결코 발생하지 않는 값</td>
</tr>
</tbody></table>
<p> 다양한 타입을 사전 선언하는 방법은 다음과 같다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//boolean</span></span><br><span class="line"><span class="keyword">let</span> isDone :boolena = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//null</span></span><br><span class="line"><span class="keyword">let</span> n:<span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//undefined </span></span><br><span class="line"><span class="keyword">let</span> u:<span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//number</span></span><br><span class="line"><span class="keyword">let</span> decimal :<span class="built_in">number</span>  = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">let</span> hex:<span class="built_in">number</span> = <span class="number">0xf00d</span>; <span class="comment">//16진법</span></span><br><span class="line"><span class="keyword">let</span> bunary:<span class="built_in">number</span> = <span class="number">0b1010</span>; <span class="comment">//2진법</span></span><br><span class="line"><span class="keyword">let</span> octal:<span class="built_in">number</span> = <span class="number">0o744</span>; <span class="comment">//8진법</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string</span></span><br><span class="line"><span class="keyword">let</span> color :<span class="built_in">string</span> = <span class="string">"blue"</span>;</span><br><span class="line">color = <span class="string">'red'</span>;</span><br><span class="line"><span class="keyword">let</span> myName :<span class="built_in">string</span> = <span class="string">`Kim`</span>; <span class="comment">//템플릿 문자열</span></span><br><span class="line"><span class="keyword">let</span> greeting :<span class="built_in">string</span> = <span class="string">`Hello my name is <span class="subst">$&#123;myName&#125;</span>`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//object</span></span><br><span class="line"><span class="keyword">const</span> obj :object = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//array</span></span><br><span class="line"><span class="keyword">let</span> list1:<span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">'two'</span>,<span class="number">2</span>];</span><br><span class="line"><span class="keyword">let</span> list2 :<span class="built_in">number</span>[] =[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> list2 :<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="comment">//제네릭 배열</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//tuple:고정된 요수의수 만큼 타입을 미리 선언후 배열을 표현</span></span><br><span class="line"><span class="keyword">let</span> tuple :[<span class="built_in">string</span>,<span class="built_in">number</span>];</span><br><span class="line">tuple = [<span class="string">'hello'</span>,<span class="number">10</span>];</span><br><span class="line">tuple = [<span class="number">10</span>,<span class="string">'hello'</span>]<span class="comment">// Error;</span></span><br><span class="line">tuple = [<span class="string">'hello'</span>, <span class="number">10</span>, <span class="string">'world'</span>, <span class="number">100</span>]; <span class="comment">// Error</span></span><br><span class="line">tuple.push(<span class="literal">true</span>); <span class="comment">// Error</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//enum :열거형은 숫자값 집합에 이름을 지정한 것이다.</span></span><br><span class="line">emum Color1 &#123;Red,Green,Blue&#125;;</span><br><span class="line"><span class="keyword">let</span> c1:Color1 = Color1.Green;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c1) <span class="comment">//1;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color2 &#123;Red = <span class="number">1</span>,Green,Blue&#125;;</span><br><span class="line"><span class="keyword">let</span> c2:Color2 = Color2.Green;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c2); <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Color3 &#123;Red = <span class="number">1</span>, Green = <span class="number">2</span>, Blue = <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c3:Color3 = Color3.Blue;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c3) <span class="comment">//4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//any:타입 추론 할 수 없거나 타입체크가 필요 없는 변수에 사용한다.</span></span><br><span class="line"><span class="comment">//var티워드로 선언한 변수와 같이 어떤타입의 값이라도 할당할 수 있다. </span></span><br><span class="line"><span class="keyword">let</span> notSure:<span class="built_in">any</span> = <span class="number">4</span>;</span><br><span class="line">notSure = <span class="string">'maybe a string instead'</span>;</span><br><span class="line">notSure = <span class="literal">false</span> <span class="comment">//okay </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void : 일반적으로 함수에서 반환값이 없을 경우 사용한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">warnUser</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"this is my warning message');</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//never :결코 발생하지 않는 값</span></span><br><span class="line"><span class="string">function infiniteLoop():never&#123;</span></span><br><span class="line"><span class="string">    while(true)&#123;&#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">function error(message:string):never&#123;</span></span><br><span class="line"><span class="string">  throw new Error(message);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>타입은 소문자, 대문자를 구별하므로 주의가 필요하다. 위에서 살펴본 바와 같이 TypeScript가 기본 제공하느 타입은 모두 소문다 이다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//string:원시 타입 문자열</span></span><br><span class="line"><span class="keyword">let</span> primitiveStr :<span class="built_in">string</span>;</span><br><span class="line">primitiveStr = <span class="string">'hello'</span>; <span class="comment">//ok</span></span><br><span class="line"><span class="comment">//원시 타입 문자열 타입에 객체를 할당하였다.</span></span><br><span class="line">primitiveStr = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'Hello'</span>) <span class="comment">//Error</span></span><br><span class="line"><span class="comment">//Type 'String' is not assignable to type 'string'.</span></span><br><span class="line"><span class="string">'string'</span> is a primitive, but <span class="string">'String'</span> is a wrapper object. Prefer using <span class="string">'string'</span> when possible.</span><br><span class="line">*<span class="regexp">/</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/String :String 생성자 함수로 생성된 String 래퍼 객체 타입</span></span><br><span class="line"><span class="regexp">let objectStr :String;</span></span><br><span class="line"><span class="regexp">objectStr = 'Hello';/</span><span class="regexp">/ok</span></span><br><span class="line"><span class="regexp">objectStr = new String('Hello') /</span><span class="comment">//ok;</span></span><br></pre></td></tr></table></figure>

<p>string타입은 Ty[eScript가 기본으로 제공하는 원시 타입인 문자열 타입을 의미한다. 하지만 대문자로 시작하는 String 타입은 String 생성자 함수로 생성된 String 레퍼 객체 타입을 의미한다.  따라서 string 타입에 String 타입을 할당하면 에러가 발생한다. 하지만 String 타입에는string타입을 할당할 수 있다. 이처첨 객체의 유형도 타입이 될 수 있다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Date타입 </span></span><br><span class="line"><span class="keyword">const</span> today :<span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//HTMLElement 타입</span></span><br><span class="line"><span class="keyword">const</span> elem:HTMLElement = <span class="built_in">document</span>.getElementById(<span class="string">'myId'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person&#123;&#125;</span><br><span class="line"><span class="comment">//Person 타입</span></span><br><span class="line"><span class="keyword">const</span> person :Person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<h1 id="2-정적-타이핑"><a href="#2-정적-타이핑" class="headerlink" title="2. 정적 타이핑"></a>2. 정적 타이핑</h1><p>C나 Java같은 언어는 변수를 선언할 때 변수에 할당할 값의 타입에 따라 사전에 타입을 명시적으로 선언하여야 하며 선언한 타입에 맞는 값을 할당해야한다. 이를 정적 타이핑이라한다. </p>
<p> 자바스크립트는 동적 타입 언어 혹은 느슨한 타입 언어이다. 이것은 변수의 타입 선언없이 값이 할당되는 과정에서 동적으로 타입을 추론 한다는 의미이다. 동적 타입 언어는 타입 추론에 의해 변수의 타입이 결정된 후에도 같은 변수에 여러 타입의 값을 교차하여 할당할 수 있다. 이를 동적 타이핑 이라한다. </p>
<p>동적 타이핑은 사용하기 간편하지만 코드를 예측하ㄱ디 힘들어 예상치 못한 오류를 만들 가능성이 높다. 또한  IDE와 같은 도구가 변수나 매개변수,함수의 반환값의 타입을 알 수 없어 코드 어스크트 드으이 기능을 지원 할 수 없게 한다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo) <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line">foo = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo) <span class="comment">// object;</span></span><br><span class="line"></span><br><span class="line">foo = &#123;&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo) <span class="comment">//object</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo) <span class="comment">//number;</span></span><br><span class="line"></span><br><span class="line">foo = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo) <span class="comment">//number;</span></span><br><span class="line"></span><br><span class="line">foo = <span class="string">"Hi "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo) <span class="comment">///string;</span></span><br><span class="line"></span><br><span class="line">foo = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo) <span class="comment">//boolean;</span></span><br></pre></td></tr></table></figure>

<p>TypeScript의 가장 독특한 특징인 정적 타이핑을 지원한다는 것이다. 정적 타입 언어는 타입을 명시적으로 선언하며,  타입이 결정된 후에는 타입을 변경할 수 없다. 잘못된 타입의 값이 할당 또는 반환되면 컴파일러는 이를 감지해 에러를 발생 시킨다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo:<span class="built_in">string</span>,<span class="comment">//문자열 타입</span></span><br><span class="line">    bar:<span class="built_in">number</span>, <span class="comment">//숫자 타입 </span></span><br><span class="line">    baz:<span class="built_in">boolean</span> <span class="comment">//불리언 타입</span></span><br><span class="line"></span><br><span class="line">foo = <span class="string">"Hello"</span>;</span><br><span class="line">bar = <span class="number">123</span>;</span><br><span class="line">baz = <span class="string">'true'</span><span class="comment">// error Type '"true"' is not assignable to type 'boolean'.</span></span><br></pre></td></tr></table></figure>

<p>정적 타이핑은 변수는 물론 함수의 매개 변수와 반환값에도 사용할 수 있다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x:<span class="built_in">number</span> , y:<span class="built_in">number</span></span>):<span class="title">number</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>,<span class="number">10</span>)) <span class="comment">//20;</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">'10'</span>,<span class="string">'10'</span>)); <span class="comment">// error TS2345: Argument of type '"10"' is not assignable to parameter of type 'number'.</span></span><br></pre></td></tr></table></figure>

<p>정적 타이핑과 동적 타이핑의 가장 큰 차이를 컴파일 시의 에러 검출고 런타임 시의 에러 검출로 볼 수 있는데 ,Java 와 같은 정적 타이핑 언어도 런타임에만 검출되는 에러가 존재하기 때문이다. </p>
<p>정적 타이핑의 장점은 코드 가독성,예측성,안정성의 향상 이라고 볼 수 있는데 이는 대규모 프로젝트에 적합하다. </p>
<h1 id="3-타입-추론"><a href="#3-타입-추론" class="headerlink" title="3. 타입 추론"></a>3. 타입 추론</h1><p>만약 타입 선언을 생력하면 값이 할당 도는 과정에서 동적으로 타입이 결정된다. 이를 타입 추론이라고 한다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span> <span class="comment">// foo는 number 타입</span></span><br></pre></td></tr></table></figure>

<p>위 코드를 보면 변수 foo에 타입을 선언하지 않았으나 타입 추론에 의해 변수의 타입이 결정 된다. 동적타입 언어는 타입 추론에 의해 변수의 타입이 결정된 후에도 같은 변수에 여러 타입 값으 교차하여 할당 할 수 있다. 하지만 정적 타입 언어는 결정된 후에 타입을 변경 할 수 없다. TypeScript는 정적 타입 언어이므로 타입 추론으로 타입이 결정된 이후, 다른 타입의 값을 할당 하면 에러가 발생한다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="number">123</span> <span class="comment">//foo는 number 타입</span></span><br><span class="line">foo = <span class="string">'hihi'</span>  <span class="comment">// error: Type '"hi"' is not assignable to type 'number'.</span></span><br></pre></td></tr></table></figure>

<p>타입 선언을 생략하고 값을 할당하지 않아서 추론할 수 없으면 any 타입이 된다. any 타입의 변수는 자바스크립트의avr 키워드로 선언된 변수처럼 어떤 타입의 값도 재할당이 가능하다.  이는 TypeScript를 사용하는 장점을 없애기 때문에 사용하지 않는 편이 좋다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> foo ;<span class="comment">// let foo: any와 동치</span></span><br><span class="line">foo = <span class="string">'Hello'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo) <span class="comment">//string;</span></span><br><span class="line"></span><br><span class="line">foo = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> foo) <span class="comment">//booelan</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>타입 스크립트 정적 타입핑에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>타입 가드</title>
    <url>/2020/06/17/type-gtuard/</url>
    <content><![CDATA[<p>#타입 가드란?<br>일부 스코프에서 타입을 보장하는 런타임 검사를 수행하는 표현식. 타입 가드를 정의하여면 반환 타입이 타입 명제(type predicate)인 함수를 정의 하기만 하면 된다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  fly();</span><br><span class="line">  eat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Fish&#123;</span><br><span class="line">  swim();</span><br><span class="line">  eat();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>: <span class="title">Fish</span> | <span class="title">Bird</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"> <span class="comment">//타입 가드</span></span><br><span class="line"> <span class="comment">//타입 명제는 argName is Type형태</span></span><br><span class="line"> <span class="comment">//argName은 현재 함수에서 사용한 매개변수의 이름을 사용해야한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet:Fish | Bird</span>):<span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isFish(pet))&#123; <span class="comment">//isFish(pet)이 true이면 pet은 Fish이다.</span></span><br><span class="line">  pet.swim();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="typeof-타입-가드"><a href="#typeof-타입-가드" class="headerlink" title="typeof 타입 가드"></a>typeof 타입 가드</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x:<span class="built_in">any</span></span>):<span class="title">x</span> <span class="title">is</span> <span class="title">number</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">"number"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">x:<span class="built_in">any</span></span>):<span class="title">x</span> <span class="title">is</span> <span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">"string"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value:<span class="built_in">string</span>,padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(isNumber(padding))&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(padding+<span class="number">1</span>).join(<span class="string">" "</span>).value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(isString(padding))&#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음과 같은 순반복 작업을 피하기 위해 , 타입 스크립트에서 인라인 검사를 통해 타입가드를 통해 지원한다.</p>
<p>인라인은 함수의 내용만을 그대로 옮겨 놓은 듯이 작성하는 것을 의미</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value:<span class="built_in">string</span>,padding:<span class="built_in">string</span> | <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> padding === <span class="string">"number"</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(paddding+<span class="number">1</span>).join(<span class="string">" "</span>).value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> padding === <span class="string">"string"</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> padding + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>typeof을 사용한 타입가드느 typeof === “typename” 또는 typeif !== “typename”두가지 형태를 지원하고 ,typename은 [number ,string , boolean,symbol]중 하나이어야한다.</p>
<h2 id="instanceof-타입-가드"><a href="#instanceof-타입-가드" class="headerlink" title="instanceof 타입 가드"></a>instanceof 타입 가드</h2><p>클래스를 사용할 때는 instanceof을 사용한다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder&#123;</span><br><span class="line">  getPaddingString():<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SpacePadder <span class="keyword">implements</span> Padder&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces:<span class="built_in">number</span></span>)&#123;&#125;</span><br><span class="line">  getPaddingString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.numSpaces +<span class="number">1</span>).join(<span class="string">' '</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> StringPadder <span class="keyword">implements</span> Padder&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> value:<span class="built_in">string</span></span>)&#123;&#125;</span><br><span class="line">  getPaddingString()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ?</span><br><span class="line">    <span class="keyword">new</span> SpacePadder(<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">new</span> StringPadder(<span class="string">" "</span>)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> padder:Padder = getRandomPadder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(padder <span class="keyword">instanceof</span> SpacePadder)&#123;</span><br><span class="line">  padder;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span>(padder <span class="keyword">instanceof</span> StringPadder)&#123;</span><br><span class="line">  padder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>작성방식은<code>variableName instanceof constructorName</code>.</p>
<ol>
<li>타입이 any가 아닌 경우 함수의prototype 프로퍼티 타입    </li>
<li>해당 타입의 생성자 스그니처에 의해 반환된 타입의 결합</li>
</ol>
<h2 id="선택적-매개변수와-프로퍼티"><a href="#선택적-매개변수와-프로퍼티" class="headerlink" title="선택적 매개변수와 프로퍼티"></a>선택적 매개변수와 프로퍼티</h2><p>–strictNulCheck 를 선택적 매개 변수와 함께 쓰면 자동으로 | undefined를 추가 합니다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x:<span class="built_in">number</span>,y?:<span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x +(y || <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">f(<span class="number">1</span>);</span><br><span class="line">f(<span class="number">1</span>,undefiend);</span><br><span class="line">f(<span class="number">1</span>,<span class="literal">null</span>) <span class="comment">// 오류 , 'null'은 'number | undefined'에 할당할 수 없습니다.</span></span><br></pre></td></tr></table></figure>

<p>선택적 프로퍼티도 동일합니다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C&#123;</span><br><span class="line">  a:<span class="built_in">number</span>;</span><br><span class="line">  b?:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.a = <span class="number">12</span>;</span><br><span class="line">c.a = <span class="literal">undefined</span>; <span class="comment">//오류 undefined는 'number'에 할당 할 수 없다.</span></span><br><span class="line">c.b = <span class="number">13</span>;</span><br><span class="line">c.b = <span class="literal">undefined</span> <span class="comment">//ok;</span></span><br><span class="line">c.b = <span class="literal">null</span> <span class="comment">//오류 'null'은 'number | undefined'에 할당 할 수 없다.</span></span><br></pre></td></tr></table></figure>

<h2 id="타입-가드와-타입-단언"><a href="#타입-가드와-타입-단언" class="headerlink" title="타입 가드와 타입 단언"></a>타입 가드와 타입 단언</h2><p>Nullable 타입은 유니온 타입으로 구현 되기 때문에 타입가드를 사용하여 null을 제거해야합니다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">sn:<span class="built_in">string</span> | <span class="literal">null</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="comment">//case 1</span></span><br><span class="line">  <span class="keyword">if</span>(sn === <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'result'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sn;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//case 2</span></span><br><span class="line">  <span class="keyword">return</span> sn || <span class="string">'default'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>컴파일러가 null 또는 undefined를 제거할 수 업슨 경우에 타입 단언 연산자를 사용하여 수동으로 제거해야합니다. 연산자는 ! 입니다. v!은 v!의 null과 undefined을 제거합니다 </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broken</span>(<span class="params">name:<span class="built_in">string</span> | <span class="literal">null</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="comment">//namedl null일 수도 있다는 에러가 발생</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.chartAt(<span class="number">0</span>)+<span class="string">'. the '</span>+ epithet; <span class="comment">//오류 'name'이 null일 수 있다.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//name이 null이어도 여기서 "Bob"으로 바뀝니다.</span></span><br><span class="line">  name = name || <span class="string">'Bob'</span>;</span><br><span class="line">  <span class="keyword">return</span> prostfix(<span class="string">"graet"</span>)<span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixed</span>(<span class="params">name:<span class="built_in">string</span> | <span class="literal">null</span> </span>):<span class="title">string</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name!.charAt(<span class="number">0</span>)+ <span class="string">'. the '</span>+ epithet;</span><br><span class="line">  &#125;</span><br><span class="line">  name = name || <span class="string">"Bob"</span>;</span><br><span class="line">  <span class="keyword">return</span> postfix(<span class="string">"great"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>컴파일러가 name이 null 일수 있다고 판단하는 이유는 , 외부 함수에서 호출한 경우 중첩된 함수에 대한 모든 호출을 추적하는 것이 불가능하기 때문입니다. (즉시 실행함수 IIFE의 경우 가능)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broken</span>(<span class="params">name:<span class="built_in">string</span> | <span class="literal">null</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">  name = name || <span class="string">"Bob"</span>;</span><br><span class="line">  <span class="keyword">return</span>(<span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//즉시 실행 함수이기 때문에 name이 null이 아니라는 것을 알고 있다.</span></span><br><span class="line">    <span class="keyword">return</span> name.chatAt(<span class="number">0</span>)+ <span class="string">'. the'</span> + epithet;</span><br><span class="line">  &#125;)(<span class="string">"great"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="타입-단언-type-Assertion"><a href="#타입-단언-type-Assertion" class="headerlink" title="타입 단언( type Assertion)"></a>타입 단언( type Assertion)</h2><p>타입 스크립트가 컴파일러 타입을 실제 런타입에 존재 할  변수의 타입과 다르게 추론하거나 너무 보수적이 ㄴ추론을 하는 경우에 프로그래머가 수동으로 컴파일러한테 특정 변수에 대해 타입 힌트를 주는것이다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Character&#123;</span><br><span class="line">  hp:<span class="built_in">number</span>;</span><br><span class="line">  runAway()&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  isWizard()&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  isWarrior()&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Wizrd <span class="keyword">extends</span> Character&#123;</span><br><span class="line">  fireBall()&#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Warrior <span class="keyword">extends</span> Character&#123;</span><br><span class="line">  attack()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">battle</span>(<span class="params">character: Character</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (character.isWizard()) &#123;</span><br><span class="line">    character.fireBall(); <span class="comment">// Property 'fireBall' does not exist on type 'Character'.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (character.isWarrior()) &#123;</span><br><span class="line">    character.attack(); <span class="comment">// Property 'attack' does not exist on type 'Character'.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    character.runAway();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>다음 코드는 컴파일 에러가 발생한다. Character 클래스에는 fireBall ,attack케소드가 선언되어 있지 ㅇ낳기 때문 isWizard라는 메소드를 통해 그 캐릭터가 Wizard인스턴스라는 것을 보장 할수  있다면 FireBall 메소드를 사용할 수있다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">battle</span>(<span class="params">character:Character</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(character.isWizard())&#123;</span><br><span class="line">    (character <span class="keyword">as</span> Wizard).fireBll(); <span class="comment">//pass;</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(character.isWarrior())&#123;</span><br><span class="line">    (character <span class="keyword">as</span> Warrior).attact(); <span class="comment">//pass</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    character.runAway();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>타입 단언은 크게 두가지 <type>와 as Type 두가지 방법이 존재하는데 </type></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">(&lt;Wizard&gt;character).fireBall();</span><br><span class="line">(character <span class="keyword">as</span> Wizard)/fireBall();</span><br></pre></td></tr></table></figure>

<p>보통 <type> 키워드가 좀더 깔끔해 보이지만 React에서 jsx 문법을 사용할 때 <type>와 문법이 겹칠 수 잇기 때문에 불편한 면이 존재한다.</type></type></p>
<p>타입가드는 타입으 ㄹ좀더 갈끔하게 할 수 잇도록 도와 준다.  앞서 타이 ㅂ단언에서 소개한 예제에서는 isWizard 라는 메소드로 해당 인스턴스가 해당 타입이라는 사실을 확정했다. 하지만 이건 런타임에서만 알 수 있는 사실이고 TypeScript 컴파일러는 알 수 없었다. 타입 가드는 이러한 런타임에서의 타입 체크를 컴파일러에게 알려주는 기능이다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Character&#123;</span><br><span class="line">  isWizard():<span class="keyword">this</span> is Wiazrd&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> Wizard;</span><br><span class="line">  &#125;</span><br><span class="line">  isWarrior():<span class="keyword">this</span> is Warrior&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="keyword">instanceof</span> Warrior;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">battle</span>(<span class="params">character :Character</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(character.isWizard())&#123;</span><br><span class="line">    character.fireBall(); <span class="comment">//ok</span></span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(character.isWarrior())&#123;</span><br><span class="line">    character.attack() <span class="comment">//ok;</span></span><br><span class="line">    </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    character.runAway();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//이제 별도의 타입 단언 문법없이도 if 블록안에서 character가 Wizard나 Warrior로 자 ㄹ추론이 된다. 그리고 사실 instanceof와 typeof같은 오퍼레이터로 일종의 타입 가드이다</span></span><br></pre></td></tr></table></figure>

<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">val:<span class="built_in">string</span> | <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> val === <span class="string">'number'</span>)&#123;</span><br><span class="line">    val.toFixed(); <span class="comment">//pass val은 number로 타입 추론</span></span><br><span class="line">    </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//union타입에서 'number'는 이미 통과 했으므로 자동으로 'string'으로 추론됨</span></span><br><span class="line">    val.toLowerCase(); <span class="comment">//pass, val은 string 타입으로 추론됨</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>타입가드에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>타입변환과 단축평가</title>
    <url>/2020/05/16/typechange/</url>
    <content><![CDATA[<h1 id="1-타입변환이란"><a href="#1-타입변환이란" class="headerlink" title="1. 타입변환이란?"></a>1. 타입변환이란?</h1><p>자바스크립트의 모든 값은 카입이 있다. 값의 타입은 개발자의 의도에 의해 다른 타입으로 변환될 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입변환 또는 타입캐스팅이라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//명시적 타입변환</span></span><br><span class="line"><span class="comment">//숫자를 문자열로 타입 캐스팅을 한다.</span></span><br><span class="line"><span class="keyword">var</span> str = x.toString();</span><br><span class="line"><span class="built_in">console</span>.log(typeif str,str) <span class="comment">//string 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//변수 x의 값이 변경된 것은 아니다. </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x,x) <span class="comment">//number 10;</span></span><br></pre></td></tr></table></figure>

<p>개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환 또는 타입 강제 변환이라고 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//암묵적 타입 변환</span></span><br><span class="line"><span class="comment">// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로새로운 문자열을 생성한다.</span></span><br><span class="line"><span class="keyword">var</span> str = x+<span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str,str) <span class="comment">//string 10</span></span><br><span class="line"><span class="comment">//x의 타입이 변경되는 것은 아니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x,x) <span class="comment">//number 10</span></span><br></pre></td></tr></table></figure>

<p>명시적 타입 변환이나 암묵적 타입변환이 기존 원시값을 직접 변경하는 것은 아니다. 원시값은 변경 불가능한 값이므로 변경 할 숭 없다. 타입 변환이란 기존 원시값을 사용해 다른 타입의 새로운 원시값을 생성하는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//원시값 1이 '1'로 직접 변경되는것은 아니다.</span></span><br><span class="line"><span class="comment">//1을 사용해 타입이 다른 '1'을 새롭게 생성하여 '1'+''을 평가한다.</span></span><br><span class="line"><span class="number">1</span>+ <span class="string">''</span><span class="comment">// -&gt;'1'</span></span><br></pre></td></tr></table></figure>

<p>암묵적 타입 변화은 변수의 값을 재할당해서 변경하는 것이 아니라 자바스크립트 엔진이 표현식을  에러없이 평가하기 위해 피연산자의 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다.<br>위 에제의 경우, 자바스크립트의 엔진은 표현식 x+’’ 을 평가하기위해서 변수 x의 숫자 값을 바탕으로 새로운 문자열 값을 ‘10’을 생성하고 이것으로 표현식 ‘10’+’’를 평가한다. 이때 암묵적으로 생성된 문자열 ‘10’은 변수 x에 할당되지않는다. 따라서 암묵적으로 생성된 문자열 ‘10’은 표현ㅅ기의 평가가 끝나면 아무도 참조하지 ㅇ낳으므로 가비지 컬렉션에 의해 메모리에서 해제된다.</p>
<p>명시적 타입변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 강제 변환은 자바스크립트  엔진에 의해 암묵적으로 , 즉 드러나지 않게 타입이 자동변환 되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러나지 않는다.</p>
<p>따라서 자신이 작성한 코드에서 암묵적 타입변환이 발생하는지, 발생한다면 어떤타입의 어떤 값으로 변환되는지, 그리고 타입 변환된 값으로 표현식은 어떻게 평가될 것인지 에측 가능해야한다. 만약 타입 변환결과를 예측 못하거나 예측이 결과와 일치하지않는다면 오류를 발생할 가능성이 높아진다.</p>
<p>그렇다면 명시벅 타입변환 만을 사용하고 암무거적 타입변환은 발생하지 않도록 코드를 작성하면 어떨까? 좋은 생각이지만 이러한 논리는 옳지 않다. 때로는 명시적 타입변환 보다 암묵적 타입 변환이 가독성 측면에서 더 좋을 수도 있다. 예를 들어 자바스크립트 문법을 잘 이해하고 있는 개발자에게는 (10).toString()보다 10 +’’이 더욱 간결하고 이해하기 쉽다.</p>
<p>중요한 것은 코드를 예측할 수 있어야 한다는 것이다. 동료가 작성한 코드를 정확히 이해할 수 있어야 자신의 코드는 타인에 의해 쉽게 이해 될 수 있어야한다. 이를 위해 타입 변환이 어떻게 동작하는지 정확히 알고 사용하는 것이 중요하다.</p>
<h1 id="2-암묵적-타입-변환"><a href="#2-암묵적-타입-변환" class="headerlink" title="2. 암묵적 타입 변환"></a>2. 암묵적 타입 변환</h1><p>자바스크립트 엔진은 표현식을 평가 할 때 개발자의 의도와는 상관없이 코드의 문맥을 고려하여 암묵적으로 데이터 타입 을강제로 변환(암묵적 타입 변환)할 때가 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//피연산자가 모두 문자열 타입이어야 하는 문맥</span></span><br><span class="line"><span class="string">'10'</span> + <span class="number">2</span> <span class="comment">//'102';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//피연산자가 모두 숫자 타입이어야하는 문맥</span></span><br><span class="line"><span class="number">5</span> * <span class="string">'10'</span> <span class="comment">//50;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//피연산자 또는 표현식이 불리언 타입이어야하는 문맥</span></span><br><span class="line">!<span class="number">0</span> <span class="comment">//true;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>이처럼 표현식을 평가 할때 코드의 문맥에 부합하지 않는 상황이 발생 할 수 있다. 디때 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다. 암묵적 타입 변환이 발생하면 문자열,숫자,불리언 같은 원시 타입 중 하나로 타입을 자동 변환한다. 타입 별로 암묵적 타입 변환이 어떻게 발생하는 지 살펴보자.</p>
<h2 id="2-1-문자열-타입으로-변환"><a href="#2-1-문자열-타입으로-변환" class="headerlink" title="2.1. 문자열 타입으로 변환"></a>2.1. 문자열 타입으로 변환</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="string">'2'</span> <span class="comment">//'12';</span></span><br></pre></td></tr></table></figure>

<p>위에제는 +연산자는 피연산자 중 하나의 이상의 문자열이므로 문자열 연결 연산자로 종작한다. 문자열 연견 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모즌 연산자는 코드의 문맥 상 모두 문자열 타입이어야한다. </p>
<p>자바스크립트의 엔진은 문자열 연산자 표현식을 평가하기 위해서 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적으로 타입 변환한다.<br>연산자 표현식의 피연산자(피연산자도 표현식이다)만이 암묵적 타입변환 의 대상이 되는 것은 아니다. 앞서 언급했듯이 자바스크립트 엔진은 표현식을 평가 할때 코드 문맥에 부합하도록 암묵적 타입 변환을 실행한다.</p>
<p>예를 들어 ES6에서 도입된 템플릿 리터럴의 표현식 삽입은 표현식의 평가 결과를 문자열 타입으로 암묵적으로 변환한다</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`1 + 1 = <span class="subst">$&#123;<span class="number">1</span>+<span class="number">1</span>&#125;</span>`</span> <span class="comment">// ' 1 + 1 = 2'</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트의 엔진은 문자열아닌 갓을 문자열 타입으로 변환을 수행할때 아래와 같이 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//숫자 타입</span></span><br><span class="line"></span><br><span class="line"> <span class="number">0</span> +<span class="string">''</span> <span class="comment">//'0'</span></span><br><span class="line"><span class="number">-0</span>+ <span class="string">''</span> <span class="comment">//'0'</span></span><br><span class="line"><span class="number">1</span>+<span class="string">''</span> <span class="comment">//'1'</span></span><br><span class="line"><span class="number">-1</span>+<span class="string">''</span> <span class="comment">//'-1';</span></span><br><span class="line"><span class="literal">NaN</span> + <span class="string">''</span> <span class="comment">// 'NaN'</span></span><br><span class="line"><span class="literal">Infinity</span>+<span class="string">''</span> <span class="comment">// 'Infinity';</span></span><br><span class="line">-Infinitiy + <span class="string">''</span> <span class="comment">// '-Infinity'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//불리언 타입 </span></span><br><span class="line"><span class="literal">true</span> +<span class="string">''</span> <span class="comment">// 'true';</span></span><br><span class="line"><span class="literal">false</span> +<span class="string">''</span> <span class="comment">// 'false';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//null 타입</span></span><br><span class="line"><span class="literal">null</span> + <span class="string">''</span> <span class="comment">// 'null';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//undefined 타입</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="string">''</span> <span class="comment">// 'undefined';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//심볼 타입</span></span><br><span class="line">(<span class="built_in">Symbol</span>())+ <span class="string">''</span>  <span class="comment">// TypeError :cannont convert a Symbol value to a string;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//객체 타입</span></span><br><span class="line">(&#123;&#125;)+<span class="string">''</span>  <span class="comment">// '[object Object]';</span></span><br><span class="line"><span class="built_in">Math</span> + <span class="string">''</span> <span class="comment">// '[object Math]';</span></span><br><span class="line">[]+<span class="string">''</span> <span class="comment">// ''</span></span><br><span class="line">[<span class="number">10</span>,<span class="number">20</span>]+<span class="string">''</span> <span class="comment">//'10,20';</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)+<span class="string">''</span> <span class="comment">// 'function()&#123;&#125;';</span></span><br><span class="line"><span class="built_in">Array</span> +<span class="string">''</span> <span class="comment">// 'function Array()&#123;[native code]&#125;'</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-숫자-타입으로-변환"><a href="#2-2-숫자-타입으로-변환" class="headerlink" title="2.2 숫자 타입으로 변환"></a>2.2 숫자 타입으로 변환</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="string">'1'</span> <span class="comment">//0</span></span><br><span class="line"><span class="number">1</span> * <span class="string">'10'</span> <span class="comment">//10</span></span><br><span class="line"><span class="number">1</span> / <span class="string">'one'</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>위 예제에서 사용한 연산자는 모두 산술 연산자 이다. 산술 연산자의 역할은 숫자 값을 만드는 것이다. 따라서 산술 연산자의 모든 피연자는 코드 문맥 상 모두 숫자 타입이어야한다.</p>
<p>자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서  숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적으로 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환 할 수 없는 경우 산술 연산을 수행 할 수 없으므로 표현식의 평가 결과는 NaN이된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'1'</span> &gt; <span class="number">0</span> <span class="comment">//true;</span></span><br></pre></td></tr></table></figure>

<p>비교 연산자의 역할은 불리언 값을 만드는것이다. &gt;연산자는 피연자의 크기를 비교하므로 피연산자는 코드의 문맥상 모두 숫자 타입이어야한다. 자바스크립트 엔진은 비교 연산자 표현식을 평가 하기 위해 비교 연산자 중에서 숫자 타입이 아닌 피연산자 숫자타입으로 암묵적 타입변환한다.<br>자바스크립트 엔진은 숫자 타입아닌 갓을 숫자 타입으로 암묵적 타입 변환을 수행 할대 아래와 같이 동작한다. +단한 연사자는 피연산자가 숫자 타입의 값이 아니면 숫자 타입 값으로 암묵적으로 타입변환을 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 문자열 타입</span></span><br><span class="line">+<span class="string">''</span>       <span class="comment">// -&gt; 0</span></span><br><span class="line">+<span class="string">'0'</span>      <span class="comment">// -&gt; 0</span></span><br><span class="line">+<span class="string">'1'</span>      <span class="comment">// -&gt; 1</span></span><br><span class="line">+<span class="string">'string'</span> <span class="comment">// -&gt; NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 타입</span></span><br><span class="line">+<span class="literal">true</span>     <span class="comment">// -&gt; 1</span></span><br><span class="line">+<span class="literal">false</span>    <span class="comment">// -&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 타입</span></span><br><span class="line">+<span class="literal">null</span>     <span class="comment">// -&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 타입</span></span><br><span class="line">+<span class="literal">undefined</span> <span class="comment">// -&gt; NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 심볼 타입</span></span><br><span class="line">+<span class="built_in">Symbol</span>() <span class="comment">// -&gt; ypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 타입</span></span><br><span class="line">+&#123;&#125;             <span class="comment">// -&gt; NaN</span></span><br><span class="line">+[]             <span class="comment">// -&gt; 0</span></span><br><span class="line">+[<span class="number">10</span>, <span class="number">20</span>]       <span class="comment">// -&gt; NaN</span></span><br><span class="line">+(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// -&gt; NaN</span></span><br></pre></td></tr></table></figure>

<p>빈 문자열,빈 배열,null,false는 0으로 true는 1로 변환된다.  객체와 빈 배열이 아닌 배열 ,undefined는 변환되지 않아 NaN이 된다는 것에 주의 </p>
<h2 id="2-3-불리언-타입으로-변환"><a href="#2-3-불리언-타입으로-변환" class="headerlink" title="2.3. 불리언 타입으로 변환"></a>2.3. 불리언 타입으로 변환</h2><p>if문이나 for문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값 즉 , 논리적 참,거짓을 반환해야하는 표현식이다. 자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입로 변환한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">''</span>)    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>)     <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">'str'</span>) <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span>)  <span class="built_in">console</span>.log(<span class="string">'5'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure>

<p>이 때 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 또는 Falsy값으로 구분한다. 즉 제어문의 조건식과 같이 불리언 값으로 평가 되어야 할 문맥에서 Truthy 값은 true로 , Falsy 값은 false로 암묵적 타입변환을 한다.</p>
<p>아래 값들은 false로 평가되는 Falsy 값이다.</p>
<ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0, -0</li>
<li>NaN</li>
<li>’’ (빈문자열);</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 아래의 조건문은 모두 코드 블록을 실행한다.</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">false</span>)     <span class="built_in">console</span>.log(<span class="literal">false</span> + <span class="string">' is falsy value'</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) <span class="built_in">console</span>.log(<span class="literal">undefined</span> + <span class="string">' is falsy value'</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>)      <span class="built_in">console</span>.log(<span class="literal">null</span> + <span class="string">' is falsy value'</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="number">0</span>)         <span class="built_in">console</span>.log(<span class="number">0</span> + <span class="string">' is falsy value'</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">NaN</span>)       <span class="built_in">console</span>.log(<span class="literal">NaN</span> + <span class="string">' is falsy value'</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="string">''</span>)        <span class="built_in">console</span>.log(<span class="string">''</span> + <span class="string">' is falsy value'</span>);</span><br></pre></td></tr></table></figure>

<p>Falsy 값 이외의 모든 값은 모두 true로 평가되는 Truthy 값이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 주어진 값이 falsy값이면 true, Truthy 값이면 false을 반환한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFalsy</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//주어진 인자가 truthy 값이면 true, Falsy깂이면 false을 반환한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isTruhty</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 모두 true를 반환한다.</span></span><br><span class="line">isFalsy(<span class="literal">false</span>);</span><br><span class="line">isFalsy(<span class="literal">undefined</span>);</span><br><span class="line">isFalsy(<span class="literal">null</span>);</span><br><span class="line">isFalsy(<span class="number">0</span>);</span><br><span class="line">isFalsy(<span class="literal">NaN</span>);</span><br><span class="line">isFalsy(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모두 true를 반환한다.</span></span><br><span class="line">isTruthy(<span class="literal">true</span>);</span><br><span class="line">isTruthy(<span class="string">'0'</span>); <span class="comment">// 빈 문자열이 아닌 문자열은 Truthy 값이다.</span></span><br><span class="line">isTruthy(&#123;&#125;);</span><br><span class="line">isTruthy([]);</span><br></pre></td></tr></table></figure>

<h1 id="3-명시적-타입-변환"><a href="#3-명시적-타입-변환" class="headerlink" title="3. 명시적 타입 변환"></a>3. 명시적 타입 변환</h1><p>개발자의 의도에 의해 명시적으로 타입을 변환하는 방법은 다양하다. 표준 빌트인 생성자 함수를 new 연산자 호출 없이 호출하는 방법과 빌트인 메소드를 사용하는 방법, 그리고 앞에서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다.</p>
<p>표준빌트인 생성자 함수와 빌트인 메소드<br>표준 빌트인 생성자 함수와 표준 빌트인 메소드는 자바스크립트에서 기본으로 제공하는 함수이다. 표준 빌트인 생성자 함수는 객체를 생성하기 위한 함수이며 new연산자와 함께 호출한다. 표준 빌트인 메소드는 자바스크립트에서 기본 제공하는 빌트인객체릐 메소드이다. </p>
<h2 id="3-1-문자열-타입으로-변환"><a href="#3-1-문자열-타입으로-변환" class="headerlink" title="3.1. 문자열 타입으로 변환"></a>3.1. 문자열 타입으로 변환</h2><p>문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 다음과같다.</p>
<p>1.String 생성자 함수르 new 연산자 없이 호출하는 방법.</p>
<p>2.Object.prototype.toString() 메소드를 사용하느 방법<br>3.문자열 연결 연산자를 사용하는 방법</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. String 생성자 함수를 new호출없이 호출하는 방법</span></span><br><span class="line"><span class="comment">//숫자 타입 =&gt; 문자열</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">1</span>);        <span class="comment">// -&gt; "1"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">NaN</span>);      <span class="comment">// -&gt; "NaN"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">Infinity</span>); <span class="comment">// -&gt; "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>);     <span class="comment">// -&gt; "true"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">false</span>);    <span class="comment">// -&gt; "false"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Object.prototype.toString 메소드를 사용하는 방법</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line">(<span class="number">1</span>).toString();        <span class="comment">// -&gt; "1"</span></span><br><span class="line">(<span class="literal">NaN</span>).toString();      <span class="comment">// -&gt; "NaN"</span></span><br><span class="line">(<span class="literal">Infinity</span>).toString(); <span class="comment">// -&gt; "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line">(<span class="literal">true</span>).toString();     <span class="comment">// -&gt; "true"</span></span><br><span class="line">(<span class="literal">false</span>).toString();    <span class="comment">// -&gt; "false"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 문자열 연결 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="number">1</span> + <span class="string">''</span>;        <span class="comment">// -&gt; "1"</span></span><br><span class="line"><span class="literal">NaN</span> + <span class="string">''</span>;      <span class="comment">// -&gt; "NaN"</span></span><br><span class="line"><span class="literal">Infinity</span> + <span class="string">''</span>; <span class="comment">// -&gt; "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="literal">true</span> + <span class="string">''</span>;     <span class="comment">// -&gt; "true"</span></span><br><span class="line"><span class="literal">false</span> + <span class="string">''</span>;    <span class="comment">// -&gt; "false"</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-숫자-타입으로-변환"><a href="#3-2-숫자-타입으로-변환" class="headerlink" title="3.2  숫자 타입으로 변환"></a>3.2  숫자 타입으로 변환</h2><p>숫자 타입이 아닌 어떤 값을 숫자 타입으로 변환하는 방법은 다음과 같다.</p>
<ol>
<li>Number 생성자 함수르 new 연산자 없이 호출하는 방법</li>
<li>paseInt ,parseFloat 함수를 사용하는 방법(문자열만 숫자 타입로 변환가능);</li>
<li>+단항 산술 연산자를 이용하는 방법</li>
<li>*산술연산자를 사용하는 방법</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'0'</span>);     <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'-1'</span>);    <span class="comment">// -&gt; -1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'10.53'</span>); <span class="comment">// -&gt; 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>);    <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>);   <span class="comment">// -&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0'</span>);       <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'-1'</span>);      <span class="comment">// -&gt; -1</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'10.53'</span>); <span class="comment">// -&gt; 10.53</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. + 단항 산술 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line">+<span class="string">'0'</span>;     <span class="comment">// -&gt; 0</span></span><br><span class="line">+<span class="string">'-1'</span>;    <span class="comment">// -&gt; -1</span></span><br><span class="line">+<span class="string">'10.53'</span>; <span class="comment">// -&gt; 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line">+<span class="literal">true</span>;    <span class="comment">// -&gt; 1</span></span><br><span class="line">+<span class="literal">false</span>;   <span class="comment">// -&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. * 산술 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="string">'0'</span> * <span class="number">1</span>;     <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="string">'-1'</span> * <span class="number">1</span>;    <span class="comment">// -&gt; -1</span></span><br><span class="line"><span class="string">'10.53'</span> * <span class="number">1</span>; <span class="comment">// -&gt; 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="literal">true</span> * <span class="number">1</span>;    <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="literal">false</span> * <span class="number">1</span>;   <span class="comment">// -&gt; 0</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-불리언-타입으로-변환"><a href="#3-3-불리언-타입으로-변환" class="headerlink" title="3.3. 불리언 타입으로 변환"></a>3.3. 불리언 타입으로 변환</h2><p>불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법</p>
<ol>
<li>Boolean 생성자 삼수를 new 연산자 없이 호출하는 방법</li>
<li>!부정 논리 연산자를 두번 사용하는 방법</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'x'</span>);       <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>);        <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'false'</span>);   <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>);         <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>);         <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>);       <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">Infinity</span>);  <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="comment">// null 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>);      <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// undefined 타입 =&gt; 불리언 타 입</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>); <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// 객체 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;);        <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]);        <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ! 부정 논리 연산자를 두번 사용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 불리언 타입</span></span><br><span class="line">!!<span class="string">'x'</span>;       <span class="comment">// -&gt; true</span></span><br><span class="line">!!<span class="string">''</span>;        <span class="comment">// -&gt; false</span></span><br><span class="line">!!<span class="string">'false'</span>;   <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 불리언 타입</span></span><br><span class="line">!!<span class="number">0</span>;         <span class="comment">// -&gt; false</span></span><br><span class="line">!!<span class="number">1</span>;         <span class="comment">// -&gt; true</span></span><br><span class="line">!!<span class="literal">NaN</span>;       <span class="comment">// -&gt; false</span></span><br><span class="line">!!<span class="literal">Infinity</span>;  <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="comment">// null 타입 =&gt; 불리언 타입</span></span><br><span class="line">!!<span class="literal">null</span>;      <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// undefined 타입 =&gt; 불리언 타입</span></span><br><span class="line">!!<span class="literal">undefined</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// 객체 타입 =&gt; 불리언 타입</span></span><br><span class="line">!!&#123;&#125;;        <span class="comment">// -&gt; true</span></span><br><span class="line">!![];        <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<h1 id="4-단축-평가"><a href="#4-단축-평가" class="headerlink" title="4.  단축 평가"></a>4.  단축 평가</h1><p>논리합(||)  연산자와 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수 도 있다. 논리합 ,논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된 다는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'Cat'</span> &amp;&amp; <span class="string">'Dog'</span> <span class="comment">// 'Dog'</span></span><br></pre></td></tr></table></figure>

<p>논리곱 연산자는 두개의 피연산자가 모두 true 일때 모두 true 를 반환한다. 논리곱 연산자는 결합 순서가 좌항에서 우항으로 평가가 진행된다.<br>첫번째 피연산자 ‘Cat’은 truty 값이므로 true로 평가 된다. 하지만 이 시점까지는 위 표현식을 평가 할 수없다. 두번째 피연산자까지 평가해 보아야 위 표현식을 평가 할 수 있다. 다시 말해 두번째 피연산자가 위 논리곱 연산자 표현식의 평가 결과를 결정한다.이때 논리곱 연산자 논리 연산의 결과를 결정한 두번재  피연산자 즉 문자열 ‘Dog’를 그대로 반환한다.</p>
<p>논리합 연산자도 논리곱 연산자와 동일하게 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'Cat'</span> || <span class="string">'Dog'</span> <span class="comment">// -&gt; "Cat"</span></span><br></pre></td></tr></table></figure>

<p>논리함 연산자는 두개의 피연산자 중 하나만 true로 평가 되어도 true를 반환한다. 논리합 연산자도 왼쪽에서 오른쪽으로 진행된다. 찻 반째 피연산자 ‘Cat’은  truthy한 값이므로 true로 평가된다. 이 시점에서 두 번째 피연산자까지 평가 해 보지 않아도 위 표현식을 평가 할수있다. 이때 논리 합 연산자는 논리 연산의 결과를 결정한 첫번째 피연산자 즉 ,문자열 ‘Cat’을 그대로 반환한다.<br>논리곱 연산자와 논리합 연산자는 이와 같이 논리 연산의 결과를 결정한 피연산자를 타입 변환 하지 않고 그대로 반환한다. 이를 단축 평가라 부른다. 단축평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우,나머지 평가 과정을 생략한다. 대부분의 프로그래밍 언어는 단축병가를 통해 논리 연산을 수행한다.</p>
<p>단축 평가는 아래의 규칙을 따른다. </p>
<table>
<thead>
<tr>
<th align="left">단축 평가 표현식</th>
<th align="left">평가 결과</th>
</tr>
</thead>
<tbody><tr>
<td align="left">true || anything</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">false || anything</td>
<td align="left">anything</td>
</tr>
<tr>
<td align="left">true &amp;&amp; anything</td>
<td align="left">anything</td>
</tr>
<tr>
<td align="left">false &amp;&amp; anything</td>
<td align="left">false</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 논리합(||) 연산자</span></span><br><span class="line"><span class="string">'Cat'</span> || <span class="string">'Dog'</span>  <span class="comment">// -&gt; "Cat"</span></span><br><span class="line"><span class="literal">false</span> || <span class="string">'Dog'</span>  <span class="comment">// -&gt; "Dog"</span></span><br><span class="line"><span class="string">'Cat'</span> || <span class="literal">false</span>  <span class="comment">// -&gt; "Cat"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;) 연산자</span></span><br><span class="line"><span class="string">'Cat'</span> &amp;&amp; <span class="string">'Dog'</span>  <span class="comment">// -&gt; "Dog"</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="string">'Dog'</span>  <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="string">'Cat'</span> &amp;&amp; <span class="literal">false</span>  <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>단축 평가를 사용하면 if문을 대체 할 수 있다 . 주어진 조건이 truthy값(참으로 평가되는 값)일 때 무언가를 해야한다면 온리곱 연산자 표현식으로 if문을 대체 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">''</span>;</span><br><span class="line"><span class="comment">//주어진 조건이 true일 때 </span></span><br><span class="line"><span class="keyword">if</span>(done)message = <span class="string">'완료'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if문은 단축 평가로 대체 가능하다.</span></span><br><span class="line"><span class="comment">//done에 true라면 message에 '완료'를 할당</span></span><br><span class="line">message = done &amp;&amp; <span class="string">'완료'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message) <span class="comment">//완료</span></span><br></pre></td></tr></table></figure>

<p>주어진 조건이 truthy값(거짓으로 평가 되는 값) 일 때 무언가를 해야 한다면 논리합 연산자 표현식으로 if문을 대체할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//주어진 조건이 false 일때</span></span><br><span class="line"><span class="keyword">if</span>(!done)mesage = <span class="string">'미완료'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if문은 단축평가로 대체 가능하다.</span></span><br><span class="line"> <span class="comment">//done이 false이면 message에 '미완료'를 할당</span></span><br><span class="line">message = done || <span class="string">'미완료'</span>;</span><br><span class="line">consoel.log(message) <span class="comment">//미완료</span></span><br></pre></td></tr></table></figure>

<p>참고로 삼항 조건 연산자는 if…else문을 대체 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if else문</span></span><br><span class="line"><span class="keyword">if</span>(done)message =<span class="string">'완료'</span>;</span><br><span class="line"><span class="keyword">else</span> message = <span class="string">'미완료'</span>;</span><br><span class="line">consoel.log(message) <span class="comment">// 완료;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if ...else 문은 삼항 조건 연산자로 대체 가능 하다.</span></span><br><span class="line">message = done ? <span class="string">'완료'</span> :<span class="string">'미완료'</span>;</span><br><span class="line">consoel.log(message) <span class="comment">//  완료</span></span><br></pre></td></tr></table></figure>

<p>객체를 가리키는 변수가  null(또는 undefined)인지 확인하고 프로퍼티를 참조 할 때</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = elem.value; <span class="comment">//// TypeError: Cannot read property 'value' of null</span></span><br><span class="line"><span class="keyword">var</span> value = elem &amp;&amp; elem.value <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<p>객체는 키와 값으로 구성된 프로퍼티들의 집합이다. 만약 객체를 가리키는 변수가 null인 경우 , 객체의 프로퍼티를 참조하면 타입에러가 발생한다. 이때 단축 평가를 사용하면 에러가 발생하지않는다.</p>
<p>ES11(ECMAScript2020)에 도입될 것으로 알려진 옵셔널 체이닝(optional chaining, 2020년 5월 현재, stage 4) 문법을 사용하면 논리곱(&amp;&amp;) 연산자 표현식을 대체할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> elem = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// elem이 null 또는 undefined인 경우, 옵셔널 체이닝 문법은 undefined를 반환한다.</span></span><br><span class="line"><span class="keyword">const</span> value = elem ? .value; <span class="comment">//undefined;</span></span><br><span class="line"><span class="comment">//const value = (elem === null || elem === undefined)? undefined :elem.value;</span></span><br></pre></td></tr></table></figure>

<p>함수 매개 변수에 기본값을 설정 할때</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//단축 평가를 사용한 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStringLength() <span class="comment">// 0;</span></span><br><span class="line">setStringLength(<span class="string">'hi'</span>) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6의 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str = <span class="string">''</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line">getStringLength(); <span class="comment">//0;</span></span><br><span class="line">getStringLength(<span class="string">'hi'</span>) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>함수를 호출할 때 인수를 전달하지 않으면 매개 변수를 undefined을 갖는다. 이때 단축평가를 사용하여 매개 변수의 기본값을 설정하면 undefined로인해 발생 할 수 있는 에러를 방지할 수 있다.</p>
]]></content>
      <tags>
        <tag>타입변환과 단축평가에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>타입 스크립트 클래스</title>
    <url>/2020/06/15/typescript-class/</url>
    <content><![CDATA[<h1 id="1-타입-스크립트-클래스의-정의-class-Definition"><a href="#1-타입-스크립트-클래스의-정의-class-Definition" class="headerlink" title="1.  타입 스크립트 클래스의 정의(class Definition)"></a>1.  타입 스크립트 클래스의 정의(class Definition)</h1><p>ES6 클래스는 클래스 몸체에 메소드 만을 포함할 수 있다. 클래스 몸체에 클래스 프로퍼티를 선언 할 수 없고 반드시 생성자 내부에 클래스 프로퍼티를 선언하고 초기화 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//person.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">    <span class="comment">//클래스 프로퍼티의 선언과 포기화</span></span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  walk()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is Walking`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  위 예제의 Es6에서의 문제없이 실행되는 토드이지만 위 파일의 확장자를 ts로 바꿔 TypeScript 파일로 변경항 후 , 컴파일하면 아래와 같이 컴파일 에러가 발생한다. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">person.ts(4,10): error TS2339: Property &apos;name&apos; does not exist on type &apos;Person&apos;.</span><br><span class="line">person.ts(8,25): error TS2339: Property &apos;name&apos; does not exist on type &apos;Person&apos;.</span><br></pre></td></tr></table></figure>

<p> TypeScript 클래스는 클래스 몸체에 클래스 프로퍼티를 사전 선언하여여한다 </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">  <span class="comment">//클래스 프로퍼티를 사전 선언해야 힌다.</span></span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">    <span class="comment">//클래스 프로퍼티수에 값을 할당</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  walk()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is Walking`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">'kim'</span>)</span><br><span class="line">person.walk(); <span class="comment">// kim is Walking</span></span><br></pre></td></tr></table></figure>

<h1 id="2-접근제한자"><a href="#2-접근제한자" class="headerlink" title="2. 접근제한자"></a>2. 접근제한자</h1><p>TypeScript 클래스는 클래스 기반 객체 지향언어가 지원하는 접근제한자 public , private,proteted를 지워하며 의미 또하 기본적으로 동일 하다.</p>
<p>단 , 접근제한자를  명시하지 않았을때 , 다른  클래스 기반의 언어의 경우 , 암묵적으로 protected 로 지정 되어 패키지 레벨로 공개되지만 TypeScript의 경우 , 접근 제한자르르 생략한 클래스 프로퍼티와 메소드는 암묵적으로 public 이 선언 된다. 따라서 public으로 지정 하고자하는 멤버 변수와 메소드는 접근자 제한자를 생략한다 .</p>
<p>접근 제한자를 선언하 프로퍼티와 메소드에 대한 접근 가능성은 다음과 같다.</p>
<table>
<thead>
<tr>
<th align="left">접근 가능성</th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="left">클래스 내부</td>
<td align="center">◯</td>
<td align="center">◯</td>
<td align="center">◯</td>
</tr>
<tr>
<td align="left">자식 클래스 내부</td>
<td align="center">◯</td>
<td align="center">◯</td>
<td align="center">✕</td>
</tr>
<tr>
<td align="left">클래스 인스턴스</td>
<td align="center">◯</td>
<td align="center">✕</td>
<td align="center">✕</td>
</tr>
</tbody></table>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo&#123;</span><br><span class="line">  <span class="keyword">public</span> x:<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">protected</span> y:<span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">private</span> z:<span class="built_in">string</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x:<span class="built_in">string</span>,y:<span class="built_in">string</span>,z:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="comment">// public, protected, private 접근 제한자 모두 클래스 내부에서 참조 가능하다.</span></span><br><span class="line">    <span class="keyword">this</span>.x = x;</span><br><span class="line">    <span class="keyword">this</span>.y = y;</span><br><span class="line">    <span class="keyword">this</span>.z = z;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo(<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// public 접근 제한자는 클래스 인스턴스를 통해 클래스 외부에서 참조 가능하다. </span></span><br><span class="line"><span class="built_in">console</span>.log(foo.x);</span><br><span class="line"></span><br><span class="line"><span class="comment">//protected 접근 제한자는 클래스 인스턴스를 통해 클래스 외부에서 참조 할 수 없다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.y);</span><br><span class="line"></span><br><span class="line"><span class="comment">//private 접근 제한자는 클래스 인스턴스를 통해 클래스 외부에서 참조 할 수 없다.</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bar <span class="keyword">extends</span> Foo&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x:<span class="built_in">string</span>,y:<span class="built_in">string</span>,z:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">    <span class="keyword">super</span>(x,y,z);</span><br><span class="line">    <span class="comment">//public 접근제한자는 자식 클래스 내부에서 참조 가능</span></span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//protected 접근제한자는 자식 클래스 내부에서만 참조 가능</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.y);</span><br><span class="line">    <span class="comment">// private 접근 제한자는 자식 클래스 내부에서도 참조 불가능</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.z);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-생성자-파라미터에-접근-제한자-선언"><a href="#3-생성자-파라미터에-접근-제한자-선언" class="headerlink" title="3. 생성자 파라미터에 접근 제한자 선언"></a>3. 생성자 파라미터에 접근 제한자 선언</h1><p>접근 제한자는 생성자 파라미터에도 선언 할 수 있다. 이때  접근 제한자가 사용된 생성자 파라미터는 암묵적으로 클래스 프로퍼티로 선언되고 생성자 내부에서 별도의 초기화 없어도 암묵적으로 초기화가 수행된다. </p>
<p>이때 private 접근 제한자가 사용되면 클래스 내부에서만 참조 가능하고  public  접근 제한자가 사용되면 클래스 외부에서도 참조가 가능하다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo&#123;</span><br><span class="line">  <span class="comment">//접근 제한자가 선언된 생성자 파라미터 x는 클래스 프로퍼티로 선언되고 자동으로 초기화 된다. </span></span><br><span class="line">  <span class="comment">//public이 선언되었으므로 x는 클래스 외부에서도 참조가 가능하다.</span></span><br><span class="line">   <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> x:<span class="built_in">string</span></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo(<span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo) Foo &#123;x:<span class="string">'hello'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(foo.x) <span class="comment">//hello</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bar&#123;</span><br><span class="line">  <span class="comment">//접근 제한자가 선언된 생성자 파라미터 x는 멤버 변수로 선언되고 자동으로 초기화된다. </span></span><br><span class="line">  <span class="comment">//private이 선언되었으므로 x는 클래스 내부에서만 참조 가능하다. </span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> x: <span class="built_in">string</span></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> Bar(<span class="string">'Hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bar) <span class="comment">// Bar&#123;x:'Hello'&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//private 선언된 bar.x는 클래스 내부에서만 참조가 가능하다. </span></span><br><span class="line"><span class="built_in">console</span>.log(bar.x) ; <span class="comment">// Property 'x' is private and only accessible within class 'Bar'.</span></span><br></pre></td></tr></table></figure>

<p>만일 생성자 파라미터에 접근 제하나자를 선언하지 않았을면 생성자 파라미터는 생성자 내부에서만 유효한 지역 변수가 되어 생ㅅ어자 외부에서 참조가 불가능하게 된다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> Foo &#123;</span><br><span class="line">   <span class="comment">//x는 생성자 내부에서만 유효한 지역 변수이다.</span></span><br><span class="line">   <span class="keyword">constructor</span>(<span class="params">x:<span class="built_in">string</span></span>)&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(x);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo(<span class="string">'Hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(foo) <span class="comment">//Foo &#123;&#125;;</span></span><br></pre></td></tr></table></figure>

<h1 id="4-readonly-키워드"><a href="#4-readonly-키워드" class="headerlink" title="4.readonly 키워드"></a>4.readonly 키워드</h1><p>TypeScript는 readonly키워드를 사용할 수 있다. readonly가 선언된 클래스 프로퍼티는 선언시 또는 생성자 내부에서만 값을 할당 할 수 있다.  그 외의 경우에는 값을 할당할 수 없고 오직 읽기만 가능한 상태가 된다.이를 이용하여 상수의 선언의 선언에 이용한다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  <span class="keyword">private</span> readonly MAX_LEN:<span class="built_in">number</span> = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">private</span> readonly MSG:<span class="built_in">string</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">this</span>.MSG = <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  log()&#123;</span><br><span class="line">    <span class="comment">//readonly가 선언된 프로퍼티는 재할당이 금지된다.</span></span><br><span class="line">     <span class="keyword">this</span>.MAX_LEN =<span class="number">10</span> <span class="comment">// Cannot assign to 'MAX_LEN' because it is a constant or a read-only property.</span></span><br><span class="line">     <span class="keyword">this</span>.MSG = <span class="string">'hi'</span>; <span class="comment">//Cannot assign to 'MSG' because it is a constant or a read-only property.</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`MAX_LEN : <span class="subst">$&#123;<span class="keyword">this</span>.MAX_LEN&#125;</span>`</span>) <span class="comment">// MAX_LEN: 5</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`MSG: <span class="subst">$&#123;<span class="keyword">this</span>.MSG&#125;</span>`</span>) MSG: <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Foo().log();</span><br></pre></td></tr></table></figure>

<h1 id="5-static-키워드"><a href="#5-static-키워드" class="headerlink" title="5. static 키워드"></a>5. static 키워드</h1><p>ES 클래스 에서 static키워드는 클래스의 정적 메소드를 정의한다. 정적 메소드는 클래스의 인스턴스가 아닌 클래스의 이름으로 호출한다. 따라서 클래스의 인스턴스를 생성하지 않아도 호출 할 수 있다. </p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(prop)&#123;</span><br><span class="line">    <span class="keyword">this</span>.prop = prop;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> staticMethod()&#123;</span><br><span class="line">    <span class="comment">//정적 메소드는 this를 사용할 수 없다 </span></span><br><span class="line">    <span class="comment">//정적 메소드 내부에서 this는 클래스이 인스턴스가 아닌 클래스 자신을 가리킨다.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'staticMethod'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  prototyprMethod()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//정적 메소드는 클래스 이름을 호출한다. </span></span><br><span class="line"><span class="built_in">console</span>.log(Foo.staticMethod());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> Foo(<span class="number">123</span>);</span><br><span class="line"><span class="comment">// 정적 메소드는 인스턴스로 호출 할 수 없다. </span></span><br><span class="line"><span class="built_in">console</span>.log(foo.staticMethod); <span class="comment">// Uncaught TypeError: foo.staticMethod is not a function</span></span><br></pre></td></tr></table></figure>

<p>TypeScript에서는 static키워드를 클래스 프로퍼티로 사용 할 수 있다. 정적 메소드와 마찬가지로 정적 클래스 프로퍼티는 인스턴스가 아닌 클래스 이름으로 호출하며 클래스의 인스턴스를 생성하지 않아도 호출할 수 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo&#123;</span><br><span class="line">  <span class="comment">//생성된 인스턴스의 개수 </span></span><br><span class="line">   <span class="keyword">static</span> instanceCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//생성자가 호출될 때 마다 카운터를 1씩 증가 시킨다..</span></span><br><span class="line">    Foo.instanceCounter ++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo1 = <span class="keyword">new</span> Foo();</span><br><span class="line"><span class="keyword">var</span> foo2 = <span class="keyword">new</span> Foo();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(Foo.instanceCounter) <span class="comment">//2;</span></span><br><span class="line"><span class="built_in">console</span>.log(foo2.instanceCounter) <span class="comment">// error TS2339: Property 'instanceCounter' does not exist on type 'Foo'.</span></span><br></pre></td></tr></table></figure>

<h1 id="6-추상-클래스"><a href="#6-추상-클래스" class="headerlink" title="6. 추상 클래스"></a>6. 추상 클래스</h1><p>추상클래스(abstract class)는 하나 이상의 추상 메소드를 포함하며 일반 메소드도 포함 할 수 있다. 추상 메소드는 내용이 없이 메소드 이름과 타입만이 선언된 메소드를 말하며 선언할 때 abstract 키워드를 사용한다. 추상 클래스를 정의할 때는 abstract 키워드를 사용하며, 직접 인스턴스를 생성할 수 없고 상속만을 위해 사용된다. 추상 클래스를 상속한 클래스는 추상 클래스의 추상 메소드를 반드시 구형하여야한다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal&#123;</span><br><span class="line">  <span class="comment">//추상 메소드 </span></span><br><span class="line">  <span class="keyword">abstract</span> makeSound():<span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">//일반 메소드 </span></span><br><span class="line">  move():<span class="built_in">void</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'move move'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//직접 인스턴스를 생성할 수 없다.</span></span><br><span class="line"><span class="comment">//new Animal();</span></span><br><span class="line"><span class="comment">// error TS2511: Cannot create an instance of the abstract class 'Animal'.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">  <span class="comment">//추상 클래스를 상속한 클래스는 추상 클래스의 추상 메소드를 반드시 구현 해야한다.</span></span><br><span class="line">  makeSound()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hihi'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Dog();</span><br><span class="line">dog.makeSound() <span class="comment">// hihi;</span></span><br><span class="line">dog.move() <span class="comment">// move move</span></span><br></pre></td></tr></table></figure>

<p>인터 페이스는 모든 메소드가 추상 메소드이지만 추상클래스는 하나 이상의 추상 메소드와 일반 메소드를 포함 할 수 있다. </p>
]]></content>
      <tags>
        <tag>타입 크립트의 클래스에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>타입 스크립트 제네릭</title>
    <url>/2020/06/15/typescript-generic/</url>
    <content><![CDATA[<p><img src="https://user-images.githubusercontent.com/54792457/84598149-89061180-aea3-11ea-9583-a101f61fb876.png" alt="typescript-generics"></p>
<p>Typescript 는 정적 타입 언어이기 때문이 함수 또는 클래스를 정의하는 시점에 매개변수나 반환값의 타입을 선언 해야한다. 그런데 함수 또는 클래스를 정의하는 시점에 매개변수나 반환값의 타입을 선언하기 어려운 경우가 있다  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Queue&#123;</span><br><span class="line">  <span class="keyword">protected</span> data = []; <span class="comment">// data :any[]</span></span><br><span class="line">  push(item)&#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  pop()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.shift();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> Queue();</span><br><span class="line"></span><br><span class="line">queue.push(<span class="number">0</span>);</span><br><span class="line">queue.push(<span class="string">'0'</span>)<span class="comment">//의도치 않은 실수</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed())<span class="comment">// 0;</span></span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed())<span class="comment">// 런타임 에러</span></span><br></pre></td></tr></table></figure>

<p>Queue 클래스의 data 프로터티는 타입 선언을 생략 하였기 때문에 any[]타입이 된다. any[]타입은 어떤 타입의 요소도 가질 수 있는 배열을 의미한다. any[]타입은 배열의 요소의 타입이 모두 같지 않다는 문제를 가지게 된다. 위 예제의 경우 data 프로퍼티는 number 타입만을 포함하는 배열이라는 기대 하에 각 요소에 대해<br>Number.prototype.toFixed를 사용하였다. 따라서 number 타입이 아닌 요소의 경우 런타입 에러가 발생한다.<br>위와 같은 문제를 해결하기 위해 Queue 클래스를 상속하여  number 타입 전용 NumberQueue 클래스를 정의 해보자</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Queue&#123;</span><br><span class="line">  <span class="keyword">protected</span> data = [];</span><br><span class="line">  </span><br><span class="line">  push(item)&#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  pop()&#123;</span><br><span class="line">    <span class="keyword">this</span>.data.shift();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Queue 클래스를 상속하여 number 타입 전용 NumberQueue 클래스 정의</span></span><br><span class="line"><span class="keyword">class</span> NumberQueue <span class="keyword">extends</span> Queue&#123;</span><br><span class="line">  <span class="comment">//number타입의 요소만을 push한다.</span></span><br><span class="line">  push(item:<span class="built_in">number</span>)&#123;</span><br><span class="line">    <span class="keyword">super</span>.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  pop():<span class="built_in">number</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> NumberQueue();</span><br><span class="line">queue.push(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 의도하지 않은 실수를 사전 검출 가능</span></span><br><span class="line"><span class="comment">// [ts] Argument of type '"1"' is not assignable to parameter of type 'number'.</span></span><br><span class="line"><span class="comment">//quueue.push('0')</span></span><br><span class="line">queue.push(+<span class="string">'0'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(queue.pop().toFixed()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<p>이와 같이 number 타입전용 NumberQueue 클래스를 정의하면  number 타입이외의 요소 추가(push)되었을 때 , 런타임 에러 이전에 에러를 사전에 감지 할 수 있다.</p>
<p>하지만 다양한 타입을 지원해야 한다면 타입 별로 클래스를 상속받아 추가 해야하므로 이 또한 좋은 방법은 아니다.  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Queue&lt;T&gt;&#123;</span><br><span class="line">  <span class="keyword">protected</span> data :<span class="built_in">Array</span>&lt;T&gt; = [];</span><br><span class="line">  push(item:T)&#123;</span><br><span class="line">    <span class="keyword">this</span>.data.push(item);</span><br><span class="line">  &#125;</span><br><span class="line">  pop():T&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data.shift()p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//number 전용 Queue</span></span><br><span class="line"><span class="keyword">const</span> numberQueue = <span class="keyword">new</span> Queue&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">numberQueue.push(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// numberQueue.push('1'); // 의도하지 않은 실수를 사전 검출 가능</span></span><br><span class="line">numberQueue.push(+<span class="string">'1'</span>);   <span class="comment">// 실수를 사전 인지하고 수정할 수 있다</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(numberQueue.pop().toFixed()); <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">console</span>.log(numberQueue.pop().toFixed()); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//string 전용 Queue</span></span><br><span class="line"><span class="keyword">const</span> stringQueue = <span class="keyword">new</span> Queue&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">stringQueue.push(<span class="string">'Hello'</span>);</span><br><span class="line">stringQueue.push(<span class="string">'World'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stringQueue.pop().toUpperCase()); <span class="comment">// HELLO</span></span><br><span class="line"><span class="built_in">console</span>.log(stringQueue.pop().toUpperCase()); <span class="comment">// WORLD</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//커스텀 객체 전용 Queue </span></span><br><span class="line"><span class="keyword">const</span> myQueue = <span class="keyword">new</span> Queue&lt;&#123;name:<span class="built_in">string</span>,age:<span class="built_in">number</span>&#125;&gt;();</span><br><span class="line">myQueue.push(&#123;name:<span class="string">'kim'</span>,age:<span class="number">25</span>&#125;);</span><br><span class="line">myQueue.push(&#123;name:<span class="string">'park'</span>,age:<span class="number">20</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myQueue.pop()); <span class="comment">// &#123;name:'kim',age:25&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(myQueue.pop()); <span class="comment">// &#123;name:'park',age:20&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>제네릭은 선언 시점이 아니라 생성 시점에 타입을 명시하여 하나의 타입이 아닌 다양한 타입을 사용할 수 있도록</strong> <strong>하는 기법이다. 한 번의 선언으로 다양한 타입에 재사용이 가능하다는 장점이 있다.</strong> </p>
<p><strong>T는 제네릭을 선언할 때 관용적으로 사용되는 식별자로 타입 파라미터라 한다.</strong> T는 Type의 약자로 반드시 T을 사용해야하는 것은 아니다. 또한 함수에도 제네릭을 사용할 수 있다. 제네릭을 사용하면 하나의 타입이 아닌 다양한 타입의 매개 변수와 리턴 값을 사용할 수 있다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items:T[]</span>):<span class="title">T</span>[]</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.reverse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><u>reverse함수는 인수의 타입에 의해 타입 매개변수가 결정이 된다 .</u>Reverse함수는 다양한 타입의 요소로 구성된 배열을 인자로 받는다. 예를 들어 number 타입의 요소를 갖는 배열을 전달 받으면 타입 매개변수는 number 가 된다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items:T[]</span>):<span class="title">T</span>[]</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.reverse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arg = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="comment">//인수에 의해 타입 매개변수가 결정된다.</span></span><br><span class="line"><span class="keyword">const</span> reversed = reverse(arg);</span><br><span class="line"><span class="built_in">console</span>.log(reversed) <span class="comment">//[5,4,3,2,1];</span></span><br></pre></td></tr></table></figure>

<p>만약 {name:string }타입의 요소를 갖는 배열을 전달 받으면 타입 매개변수는 {name:string}가 된다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params">items:T[]</span>):<span class="title">T</span>[]</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> items.reverse();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> args = [&#123;name: <span class="string">'kim'</span>&#125;,&#123;name: <span class="string">'park'</span>&#125;];</span><br><span class="line"><span class="comment">//인수에 의해 타입 매개변수가 결정됨</span></span><br><span class="line"><span class="keyword">const</span> reversed = reverse(args);</span><br><span class="line"><span class="built_in">console</span>.log(reversed) <span class="comment">// [&#123;name: 'park'&#125;,&#123;name: 'kim'&#125;];</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>타입스트립트 제네릭에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>메모리,참조,키워드,변수,선언,할당,재할당,호이스팅</title>
    <url>/2019/10/04/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B0%B8%EC%A1%B0%ED%82%A4%EC%9B%8C%EB%93%9C/</url>
    <content><![CDATA[<p><strong>변수</strong>-값을 다룬다.(데이터를 다룬다.)</p>
<p><strong>참조</strong>-변수에 저장된 값을 읽어들이는것을 참조라한다.</p>
<p>함수/객체 (변수를 모르면 못함)</p>
<p>10(리터럴)+(연산자)20(리터럴):좌변과 우변의 값 +연산자를 메모리에 저장한다.</p>
<p><strong>메모리셀</strong>:1byte짜리 방이 존재한다.1byte단위로 저장<br><strong>메모리주소</strong>:각각 셀마다 주소가있다.<br>인간에게 유의미한 데이터는 최소 1byte이상</p>
<p>숫자를 기억하여 메모리에 저장한다. 연산을 cpu에서 한다. cpu에서 연산 한 후 이를 메모리에 저장을 한다.<br>메모리에 저장되는 모든 값은 2진수이다.</p>
<p><strong>1+2 안 쓴다표현식(unuse-expression)? 쓴다는 의미?</strong> 메모리 어딘가에 저장함.(10과20) 30이라는 값을 더한이유는 이 값을 ‘사용하겠다’는 의미이다.곧 재사용을 할 수없다는 것이다.  값이 메모리에 저장이 됐지만 주소를 알아야 접근할 수있는데,<br>위치 안알려줌(잘못 저장하면 문제가 생김)/알려준다고해도 문제가 됨.(같은 곳에 저장될 보장이없다.임의의 공간에 저장이 되기때문이다.) 저장된 데이터를 재사용하기 위해서 프로그래밍 언어는 변수를 제공한다.</p>
<p>따라서 변수는 데이터가 저장되는 곳의 메모리 주소를 기억한다.(반드시 변수에는 하나의 값만 저장할 수 있다.)</p>
<p><strong>변수란</strong> 하나의 값을 저장할 수 있는 메모리공간에 붙인 이름 또는 메모리공간 자체를 말한다.</p>
<p><strong>여기서 값이란(하나의값)?</strong> 메모리에 들어가는 대상.컴퓨터가 인식할 수있는 값의 종류. 7가지 (숫자 문자열 불리언 undefined null symbol 객체-값의 유형)</p>
<p>자료구조-데이터 구조(여러 개의 값이 들어있는,연관된 데이터의 그룹) ex)객체,배열</p>
<hr>
<p>자바스크립트 엔진은 변수이름 result (식별자-고유한 이름,일종의 카드 키)을 안다.<br>키워드-명령어(뒤에 값을 준다.) 자바스크립트에게 내리는 명령<br>변수에 저장된 값을 읽어들이는 것을 참조라한다.</p>
<p><strong>변수의 이름</strong>-&gt;할당값/값을 의미해야함<br>변수의 이름은 저장된 값의 의미를 이해 할 수있는 이름은 가독성을 높여주는 부수효과 .변수이름을 신중하게 정해야한다.</p>
<p>var result=10+20; 각 값10,20 메모리에 저장하고 30이라는 결과를 가져옴(평가)<br>10,20이라는 값은 필요없는 값-가비지컬렉터에의해 쓰지않는 값이기 때문에 다른값이 들어갈수있게 해준다. 가비지 ㅌ컬렉터는 값을 지우는 것이아니다.</p>
<p><strong>var(키워드) result(변수이름/식별자)=10+20(표현식);</strong><br><strong>표현식을 변수에 할당(assign,저장,대입)</strong></p>
<p>code-runner(dom api가 없으면 사용해도 괜찮다.)<br>quokka(command shift p);</p>
<hr>
<p><strong>식별자(변수이름)</strong> -메모리에 있는 값을 구별해서 끄집어낼 수  있는 값./식별자는 어떤 값을 구별하여 식별해낼 수있는 고유한 이름</p>
<p><strong>함수는값이다</strong>.함수덩어리 메모리에 그대로 들어감ex)foo();</p>
<p>클래스-객체를 만들어냄 ex)class Bar(){} new Bar();<br>식별자는 메모리 주소를 알고 있다.<br>변수,함수,클래스 네이밍있다.</p>
<p><strong>변수선언</strong>-변수를 생성한다.<br>변수란 컴퓨터에서 메모리와 관련있다.</p>
<p><strong>변수선언</strong>-변수생성한다(변수이음,메모리공간-매핑된 상황) 자바스크립트 엔진에 변수이름 등록 ,값 저장을 위한 메모리 공간 확보위함</p>
<p>변수선언 var result 변수이름을 자바스크립크 엔진에 등록해 알린다.</p>
<p><strong>변수의 이름은 어디에 저장이 되는 가?</strong>  변수이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록이된다. 또한 자바 스크립트 엔진은 실행 컨텍스트를 통해서 식별자와 스코프를 관리한다. 변수이름과  변수값은 실행 컨텍스트내의 key와  value형식으로 등록되어 관리된다.<br>변수 선언 키워드 사용(var,let,const)</p>
<p>var 키워드를 사용한 변수선언은 선언단계와 초기화 단계가 동시에 일어난다.</p>
<p><strong>변수선언(메모리 공간을 확보하기 위해)=할당1.논리적 선이된후2.할당</strong></p>
<p>기본적 변수는 선언을 하고 할당해야함.</p>
<p>변수를 선언만하고,할당을 하지 않으면 -undefined값이나옴. 값이 정의되지않는다. 변수는 암묵적으로 undefined값을 가진다 .자바스크립트엔진에 부여. 알아서 할당한다 .undefined라는 값으로-우리가 일부로 할당하는 경우는 없다. 자바스크립트엔진이 쓰기위한 값,변수가 선언만되고 할당되지 않았다는것을 알려주기 위함이 크다.-인터프리터 언어는 런타임에 에러가 발생해서 볼 수있기 때문에 최대한 에러가 나지 않게한다.</p>
<p> 할당하지 않고 변수선언마저하지 않음 에러를 일으킨다.</p>
<hr>
<p><strong>변수 호이스팅(중요함)</strong>-변수선언이 위로 끌어올려진것처럼 동작한다.</p>
<p>console.log(score);//원래 에러가 나야함.<br>var score;//변수선언</p>
<p><strong>모든(식별자와 관련있다.)선언문은 먼저 실행한다.</strong><br>인터프리터가 코드를 한줄한줄 해석하기 전에 쭉 일고 선언문만을 골라서 먼저 실행한다. 이는 코드를 실행하기 전에 평가를 한다고 말한다.-이후 실행될 수있는 환경을 만들어냄.<br>변수의 선언이 코드가 순차적으로 실행되는 런타임 이전에 먼저 실행된다는 것에 주목하자.</p>
<p>위 끌어올려서 실행된 실행문은 또 실행되지 않는다.<br>(let,const호이스팅이 되지만 안되는것 처럼 작동한다.이후에 수업할 내용이다.)<br>위의 내용은 변수 호이스팅의 내용이고,함수 호이스팅이 따로 존재한다.<br>**이런식으로 코드를 짜지 말아야하는 예시가 될 수있다.-&gt;최소한 선언을 하고 참조해라.</p>
<p><strong>왜 호이스팅이 발생하는가?-&gt;</strong>선언문은 실행될때 가장먼저 골라져서 실행되기대문에 발생한다.<br>console.log(result);// undefined을 출력한다.<br>var result=100;(var result;<br>                                 result=100;)으로 해석될수있다.</p>
<p>선언문과 할당 ,선언문이전에 참조를 하지 말아라.</p>
<p>console.log(result);//undefined.<br>var result=100;<br>console.log(result)//100출력</p>
<hr>
<p><strong><em>값의 할당-</em></strong>변수 선언은 소스 코드가 순차적으로 실행되기 이전, 즉 런타임 이전에 먼저 실행되지만 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**</p>
<p><strong>값의 재할당-</strong>이미 할당되어있는 면수에 새로운 값을 또ㄱ디시 할당하는 것을 말한다.<br>var 키워드로 선언한 변수는 값을 재할당할 수 있따.</p>
<p>원시값(6가지 타입:undefined,null,불리언,문자열,숫자,symbol,)은 값을 변경할 수 없다.리뮤터블(한번 값을 설정하면 바꿀수없다.)</p>
<p><strong>언매니지드/ 매니지드</strong><br><strong>가비지 컬렉터</strong>는 지우는 역할이 아니라 값이 할당될때 다른 값이 들어가지 못하도록 블락한것을 풀어주어 다른 값이 들어갈 수 있도록하는 역할을 한다고 생각하면 쉽다.</p>
<p><strong>힌트는 :변수를 하나를 더만들어서 사용하라.</strong></p>
<p>var x=1;<br>var y=2;</p>
<hr>
<p>var z=y;</p>
<p>x=z;<br>y=x;<br>console.log(x,y);// 2,1로 출력되도록 값을 바꾸어라.</p>
]]></content>
      <tags>
        <tag>메모리,참조,키워드,변수,선언,할당,재할당,호이스팅,</tag>
      </tags>
  </entry>
  <entry>
    <title>프론트엔드 개발공부를 한 한달의 감상</title>
    <url>/2019/09/29/%EA%B0%9C%EB%B0%9C%EA%B3%B5%EB%B6%80%EA%B0%90%EC%83%81/</url>
    <content><![CDATA[<p>처음에 학원에 들어오게 되었을때,학원의 광고에 이끌려 이제는 쉽게 개발자로서 나의 커리어를 시작할 도약이 되겠구나 생각했다.하지만 처음에 수업을 듣고 난 후, 나의 생각은 정말 오만하고 생각이 없었다는것을 느꼈다.이세상에 쉬운것은 절대 없었다. 내가 알고있던것은 정말 일부에 지나지 않았다. 처음 수업을 들은 후 나는 굉장히 충격과 좌절을 느꼈다. 수업을 따라가는 것 조차 너무나도 버거웠다. 굉장히 불안하고 힘들었다. 내가 그나마 할 수있는 것은 학원 매니져님을 붙잡고 하나하나 질문하는것 뿐이었다. 그래서 첫 수업이 끝난 후 나는 학원 문을 닫을 때 까지 학원을 떠나지 못했다. 집에 가는 중에도 계속생각했다.내가 잘 할 수 있을까?하는 생각을 끊임없이했다.<br>처음에는 어떻게 공부해야 할 지도 너무 막막했다.이게 맞는지 저게 맞는지..몇일 동안을 수업이 끝나고 집으로 돌아가는 내내 기분이 안좋았다. 심지어 학원을 환불받아야하나 하는 생각도 했다.하지만 나에게는 포기했을때 선택할 수 있는 다른 선택지가 없다고 느꼈다. 나에게 프론트엔드 개발자의 길은 너무도 멀리있어서 보이지도 않는 하나의 점처럼 느껴졌다.<br>하지만 조금씩 수업을 듣고 공부를 하면서 조금씩 나아진다는 것을 느꼈다.주말에도 공부를 하고 하다보니까 수업을 듣는것도 이해하는 것도 조금은 수월해 졌다.<br>내가 항상 걱정했던것은 다른사람들은 잘하는데 나만 제일 못하는 것같고 도퇴되면 어쩌지 하는 두려움이었다. 그러다 문득 느낀것이 다른사람들과 나는 출발점이 달랐던 것이었다.컴퓨터 관련 전공자,현업에서 뛰던 경험이 있는 사람들, 비 전공에 혼자서만 공부를 했던 나와는 출발점이 달랐다.그렇기에 다른 사람과 비교하면 차이가 나는것은 당연한 것 이였다.<br>어느날 인터넷에서 개발자와 관련된 글을 읽다가 한가지 글이 굉장히 인상에 남았다.’개발자의 길은 남들과 비교하는 순간 끝이다’라는 글이었다.<br>남들과 비교를 하면서 스스로의 성취에 무뎠었다. 앞으로  나는 나에게만 집중해야겠다 생각했다. 그리고 다른 출발점을 따라 잡기 위해서 더 많은 노력을 할 것이다. 비록 지금은 더디고 느리지만, 나보다 앞선 사람들을 훨씬 추월하고 싶다.그리고 작은 성취를 느끼며 조금씩 조금씩 나아갈 것이다.작은 성취 하나하나가 나를 앞으로 나가게 하는 원동력이 된다. 처음 느꼈던 좌절을 발판삼아 앞으로 나아갈 것이다.앞으로 좌절 보다는 도전하고 극복하겠다.<br>지켜봐라. </p>
]]></content>
      <tags>
        <tag>HTML,CSS 수업을 듣고 난 한 달</tag>
      </tags>
  </entry>
  <entry>
    <title>타입스크립트 인터페이스</title>
    <url>/2020/06/06/typescript-interface-md/</url>
    <content><![CDATA[<p><img src="https://user-images.githubusercontent.com/54792457/83939364-4e530800-a817-11ea-8f88-aba43fda940b.png" alt="1_vK1lTdXqCjv7ob_j0TePLQ"></p>
<h1 id="1-소개"><a href="#1-소개" class="headerlink" title="1. 소개"></a>1. 소개</h1><p>인터페이스는 일반적으로 <strong>타입체크를 위해 사용되며 변수,함수,클래스에 사용할 수 있다</strong>.여러가지 타입을 갖는 프로터피로 이루어진 새로운 타입을 정의하는 것과 유사하다. 인터페이스는 선언된 프로퍼티 또는 메소드의 구현을 강제하여 일관성을 유지할 수 있도록 하는것이다. ES6 인터페이스는 지원을 지원하지 않지만 TypeScript는 인터페이스를 지원한다. </p>
<p>인터페이스는  프로퍼티와 메소드를 가질수 있다는 점에서 클래스와 유사하나 직접 인스턴스를 생성 할 수없고 모든 메소드는 추상 메소드이다. 단 추상 클래스의 추상 메소드와 달리 abstarct 키워드를 사용하지 않는다.  </p>
<h1 id="2-변수와-인터페이스"><a href="#2-변수와-인터페이스" class="headerlink" title="2. 변수와 인터페이스"></a>2. 변수와 인터페이스</h1><p>인터페이스는 변수의 타입으로 사용할 수 있다. 이때 인터페이스를 타입로 선언한 변수는 해당  인터페이스를 준수 하여야한다. 이서은 새로운 타입을 정의하는것과 유사하다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//인터페이스의 정의 </span></span><br><span class="line"><span class="keyword">interface</span> Todo&#123;</span><br><span class="line">  id:<span class="built_in">number</span>;</span><br><span class="line">  content:<span class="built_in">string</span>;</span><br><span class="line">  completed:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//변수의 todo 타입으로 Todo 인터페이스를 선언하였다.</span></span><br><span class="line"><span class="keyword">let</span> todo = Todo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//변수 todo는 Todo 인터페이스를 준수해야한다. </span></span><br><span class="line">todo = &#123;id:<span class="number">1</span>,content:<span class="string">'typescript'</span>,completed:<span class="literal">false</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>인터페이스를 사용하여 함수 파라미터의 타입을 선언할 수있다. 이때 해당 함수에는 파리미터의 타입으로 지정한 인터페이스를 준수하는 인수를 전달하여 야한다. 함수의 객체를 전달할 때 복잡한 매개변수 체크가 필요없어 매우 유용하다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//인터페이스의 정의 </span></span><br><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  id:<span class="built_in">number</span>;</span><br><span class="line">  content:<span class="built_in">string</span>;</span><br><span class="line">  completed:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> todos = Todo:[] =[];</span><br><span class="line"></span><br><span class="line"><span class="comment">//파라미터 todo의 타입으로 Todo 인터페이스를 선언하였다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTodo</span>(<span class="params">todo:Todo</span>)</span>&#123;</span><br><span class="line">  todos = [...todos,todo];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//파라니터 todo는 Todo 인터페이스를 준수해야한다. </span></span><br><span class="line"><span class="keyword">const</span> newTodo = &#123;id:<span class="number">1</span>,content:<span class="string">'typescript'</span>,completed:<span class="literal">false</span>&#125;;</span><br><span class="line">addTodo(newTodo);</span><br><span class="line"><span class="built_in">console</span>.log(todos);</span><br><span class="line"><span class="comment">//// [ &#123; id: 1, content: 'typescript', completed: false &#125; ]</span></span><br></pre></td></tr></table></figure>

<h1 id="3-함수와-인터페이스"><a href="#3-함수와-인터페이스" class="headerlink" title="3.  함수와 인터페이스"></a>3.  함수와 인터페이스</h1><p>인터페이스는 함수의 타입으로 사용할수있다. 이때 함수의 인터페이스에는 타입이 선언된 파라미터 리스트와 리턴 타입으로 정의한다. 함수 인터페이스를 구현하는 함수는 인터페이스를 준수해야한다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//함수 인터페이스의 정의 </span></span><br><span class="line"><span class="keyword">interface</span> SpuareFunc &#123;</span><br><span class="line">  (num:<span class="built_in">number</span>):<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//함수 인터페이스를 구현하는 함수는 인터페이스를 준수해야한다.</span></span><br><span class="line"><span class="keyword">const</span> squareFunc :SquareFunc = <span class="function"><span class="keyword">function</span> (<span class="params">num:<span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(squareFunc(<span class="number">10</span>)) <span class="comment">// 100;</span></span><br></pre></td></tr></table></figure>

<h1 id="4-클래스와-인터페이스"><a href="#4-클래스와-인터페이스" class="headerlink" title="4.  클래스와 인터페이스"></a>4.  클래스와 인터페이스</h1><p>클래스이 선언문의 implements 뒤에 인터페이스를 선언하면 해당 클래스는 인터페이스를 반드시 구현해야한다. 이는 인터페이스를 구현하는 클래스의 일관성을 유지할 수있는 장점을 갖는다.인터페이스는 프로퍼티와 메소드를 가질수 있다는 점에서 클래스와 유사하나 직접 인스턴스를 생성 할 수없다.  </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//인터페이스의 정의</span></span><br><span class="line"><span class="keyword">interface</span> ITodo&#123;</span><br><span class="line">  id:<span class="built_in">number</span>;</span><br><span class="line">  content:<span class="built_in">string</span>;</span><br><span class="line">  compelted:<span class="built_in">boolean</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Todo 클래스의 ITodo 인터페이스를 구현해야한다.</span></span><br><span class="line"><span class="keyword">class</span> Todo <span class="keyword">implements</span> ITodo&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"></span></span><br><span class="line"><span class="params">  <span class="keyword">public</span> id:<span class="built_in">number</span>,</span></span><br><span class="line"><span class="params">  <span class="keyword">public</span> content:<span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  <span class="keyword">public</span> completed:<span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> todo = <span class="keyword">new</span> Todo(<span class="number">1</span>,<span class="string">'Typescript'</span>,<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">console</span>.log(todo);</span><br></pre></td></tr></table></figure>

<p>인터페이스는 프로퍼티 뿐만이 아니라 메소드도 포함 할 수있다. 단 모든 메소드는 추상 메소드이어야한다. 인터페이스는 구현하는 클래스는 인터페이스에서 정의한 프로퍼티와 추상 메소드를 반드시 구현해야한다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//인터페이스의 정의</span></span><br><span class="line"><span class="keyword">interface</span> IPerson&#123;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  sayHello():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//인터페이스를 구현하는 클래스는 인터페이스에서 정의한 프로퍼티와 추상 메소드를 반드시 구현해야한다.</span></span><br><span class="line"><span class="keyword">class</span> Person <span class="keyword">implements</span> IPerson&#123;</span><br><span class="line">  <span class="comment">//인터페이스에서 정의한 프로퍼티 구현</span></span><br><span class="line">  contructor(<span class="keyword">public</span> name:<span class="built_in">string</span>)&#123;&#125;</span><br><span class="line">  <span class="comment">//인터페이스에서 정의한 추상 메소드의 구현</span></span><br><span class="line">  sayHello()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greeter</span>(<span class="params">person:IPerson</span>):<span class="title">void</span></span>&#123;</span><br><span class="line">  person.syaHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">'kim'</span>);</span><br><span class="line">greeter(me) <span class="comment">// Hello kim;</span></span><br></pre></td></tr></table></figure>

<h1 id="5-덕-타이핑-Duck-typing"><a href="#5-덕-타이핑-Duck-typing" class="headerlink" title="5. 덕 타이핑 (Duck typing)"></a>5. 덕 타이핑 (Duck typing)</h1><p>주의 해야 할것은 인터페이스를 구현하였다는 것 만이 카입 체크를 통과하는 유일한 방법은 아니다. 타입체크에서 중요한것은 값을 실제로 가지고 있는 것이다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IDuck&#123;<span class="comment">//1</span></span><br><span class="line">  quack():<span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> MallardDuck <span class="keyword">implements</span> IDuck&#123;<span class="comment">//3</span></span><br><span class="line">  quack()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Quack~'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ReadheadDuck&#123;<span class="comment">//4</span></span><br><span class="line">  quack()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'q~~uak'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeNoise</span>(<span class="params">duck:IDuck</span>):<span class="title">void</span></span>&#123;<span class="comment">//2</span></span><br><span class="line">  duck.quack();</span><br><span class="line">&#125;</span><br><span class="line">makeNoise(<span class="keyword">new</span> MallarDuck()); <span class="comment">//Quack~</span></span><br><span class="line">makeNoise(<span class="keyword">new</span> MallarDuck()); <span class="comment">//q~~uack //5</span></span><br></pre></td></tr></table></figure>

<ol>
<li>인터페이스 IDuck을 quck 메소드로 정의하였다. </li>
<li>makeNoise 함수는 인터페이스 IDuck을 구현한 클래스의 인스턴스 duck을 인자로 전달 받는다.</li>
<li>클래스 MallardDuck은 인터페이스 IDuck을 구현하였다.</li>
<li>클래스 RedheadDuck은 인터페이스 IDuck을 구현하지않았지만 quak메소드를 갖는다. </li>
<li>makeNoise 함수에 인터페이스에서 정의한 프로퍼티나 메소드를 가지고 있다면 그 인터페이스를 구현한 것으로 인정한다. 이것을 덕 타이핑 또는 구조적 타이핑이라고 한다.</li>
</ol>
<p>인터페이스를 변수에 사용할 경우에도 덕 타이핑은 적용된다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson&#123;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person:IPerson</span>):<span class="title">void</span></span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Hello <span class="subst">$&#123;person.name&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> me = &#123;name:<span class="string">'kim'</span>,age:<span class="number">20</span>&#125;;</span><br><span class="line">sayHello(me) <span class="comment">// Hello kim;</span></span><br></pre></td></tr></table></figure>

<p>변수 me 는 인터페이스 IPerson과 일치 하지않는다. 하지만 IPerson의 name 프로퍼티를 가지고 있으면 인터페이스에 부합하는것으로 인정한다. </p>
<p>인터페이스는 개발 단계에서 도움을 주기위해 제공되는 기능으로 자바스크립트의 표준이 아니다. 따라서 위 예제의 TypeScript 파일을 자바스크립트의 파일로 트랜스파일링 하면 다음과 같이 삭제된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params">person</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello'</span>+person.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> me = &#123;<span class="attr">name</span>:<span class="string">'kim'</span>,<span class="attr">age</span>:<span class="number">20</span>&#125;;</span><br><span class="line">sayHello(me); <span class="comment">//Hello kim;</span></span><br></pre></td></tr></table></figure>

<h1 id="6-선택적-프로퍼티"><a href="#6-선택적-프로퍼티" class="headerlink" title="6. 선택적 프로퍼티"></a>6. 선택적 프로퍼티</h1><p>인터페이스의 프로퍼티는 반드시 구현되어야한다. 하지만 인터페이스의 프로퍼티가 선택적으로 필요한 경우가 있을수 있다. 선택적으로 프로퍼티는 프로퍼티명 뒤에 ? 를 붙이며 생략하여도 에러가 발생하지않는다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> UserInfo&#123;</span><br><span class="line">  username:<span class="built_in">string</span>;</span><br><span class="line">  password:<span class="built_in">string</span>;</span><br><span class="line">  age? :<span class="built_in">number</span>;</span><br><span class="line">  address:<span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> userInfo:Userinfo = &#123;</span><br><span class="line">  username:<span class="string">'kim@gmail.com'</span>,</span><br><span class="line">  passowrd:<span class="string">'12345'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(userInfo);</span><br></pre></td></tr></table></figure>

<p>선택적 프로퍼티를 사용하면 사용 가능한 프로퍼티를 파악 할 수있어서 코드를 이해하지 쉬워진다. </p>
<h1 id="7-인터페이스의-상속"><a href="#7-인터페이스의-상속" class="headerlink" title="7. 인터페이스의 상속"></a>7. 인터페이스의 상속</h1><p>인터페이스는 extends 키워드를 사용하여 인터페이스 또는 클래스의 상속을 받을 수있다. </p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  age?:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Student <span class="keyword">extends</span> Person&#123;</span><br><span class="line">  grade:<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> student :Student = &#123;</span><br><span class="line">  name:<span class="string">'kim'</span>,</span><br><span class="line">  age:<span class="number">20</span>,</span><br><span class="line">  age:<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>복수의 인터페이스를 상속받을 수도 있다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Person&#123;</span><br><span class="line">  name:<span class="built_in">string</span>;</span><br><span class="line">  age? :<span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Developer &#123;</span><br><span class="line">  skills:<span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> WebDeveloper <span class="keyword">extends</span> Person,Developer&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webDeveloper :WebDeveloper = &#123;</span><br><span class="line">  name:<span class="string">'kim'</span>,</span><br><span class="line">  age:<span class="number">20</span>,</span><br><span class="line">  skills:[<span class="string">'HTML'</span>,<span class="string">'CSS'</span>,<span class="string">'JAVASCRIPT'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>인터페이스는 인터페이스 뿐만이 아니라 클래스도 상속받을수 있다. 단 클래스의 모든 멤버(public,private,protected)가 상속되지만 구현까지 상속하지는 않는다.</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name:<span class="built_in">string</span>, <span class="keyword">public</span> age:<span class="built_in">number</span></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Developer <span class="keyword">extends</span> Person&#123;</span><br><span class="line">  skills:<span class="built_in">string</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> developer : Developer = &#123;</span><br><span class="line">  name:<span class="string">'kim'</span>,</span><br><span class="line">  age:<span class="number">20</span>,</span><br><span class="line">  skills:[<span class="string">'HTML'</span>,<span class="string">'CSS'</span>,<span class="string">'JavaScript'</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>타입스크립트 -인터페이스에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>반응형웹 수업내용 간단한 정리</title>
    <url>/2019/09/22/%EB%B0%98%EC%9D%91%ED%98%95%EC%9B%B9%EC%88%98%EC%97%85%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/</url>
    <content><![CDATA[<p>반응형 웹 디자인(responsive Web design) 모바일디바이스와 타블렛 같은 다양한 디바이스들이 등장하게 되었고, 그에 환경에 따른 별도의 대응이 필요하게 되었다.</p>
<p> RWD vs AWD(적응형):view port에 따라 증가하다가 특정 크기에서 고정형(데스크탑 +모바일)<br>반응형 웹의 100(width를  특정한 너비를 설정하지 않는다.)</p>
<p>컨텐츠는 물과 같다.용기는 다르더라도 내용물은 물은 그대로다.</p>
<p>미디어 쿼리 배치중요하다. 추천하는 방법은 모바일 환경에 대한 선형 디자인을 처음으로 고려하고 brekpoint를 추가하면서 너비나 상황 변하였을때의 값을 설정해주는 것이 좋은 방법이 된다.(모바일에서 데스크탑으로)<br> mobile first:컨텐츠 전략 선택 선형적인 기본작업을 모바일에서 만들고 그것을 데스크탑 컨텐츠로 순서로 최적화를 한다.</p>
<p>max-width:너비를 자신의 이상으로 안하겠다.너비가 줄수도 있지만 증가하진않는다.<br>height:auto:높이를 너비가 변호하는 것에 따에 자동으로 맞춘다.</p>
<p><picture>&lt;source min-width:40em srcset:big-jpg 1x:big -jpg 2x&gt;최소의 너비에서 다음으로 srcset의 값을 보여주겠다. 배율이 1일때와 2배율일때 각각 상황에 맞게 사용하겠다.<picture>은 재사용과 수정에 용이하다.<br></picture><br></picture></p>
<p>10vh(view height)화면 view port의 1/10을 높이로 정하겠다. 앞에서 이야기했듯이 모바일 first 선형화</p>
<p>display:flex 의 order속성은 기본 값이 :0 기본 값보다 작으면 -1이면 기본 보다 먼저 값은 값이 있으면 순서대로 정의 한다.</p>
<p>flex-flow:row wrap은 축은 바꾸지 않고 wrap 을 사용함으로서 줄을 바꿈.</p>
<p>breakpoint는 쉽게 생각하면 추가될때 바뀌는 구간이라고 생각하면 된다.<br>@media screen and (min-width:801px)::801이 되면서 내용을 덮어씌우겠다.</p>
]]></content>
      <tags>
        <tag>반응형 웹 수업내용</tag>
      </tags>
  </entry>
  <entry>
    <title>스코프</title>
    <url>/2020/05/03/%EC%8A%A4%EC%BD%94%ED%94%84/</url>
    <content><![CDATA[<p><strong>스코프</strong></p>
<p>식별자(변수)가 유효한 범위,식별자와 깊은 관련,함수와 관련<br>어떨때 유효하고 어떨때 유효하지 않은가?<br>함수는 스코프를 만든다.(var키워드로 선언한 경우)</p>
<p>var 키워드는 함수의 코드블록만을 코드 블록으로 인정하는 함수레벨 스코프를 따른다. var 키워드는 함수가 스코프를 만든다.</p>
<p>중첩함수-스코프도 중첩이 된다.(어떤 우선순위를 가지는 가?을 아는 것이 중요)<br>스코프는 간단하게 말하면 자바스크립트엔진이 식별자를 찾는 규칙이다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//선언하고 할당할때 a라는 식별자를 찾는다.</span></span><br></pre></td></tr></table></figure>

<p>즉 스코프는 식별자에 존재한다. 프로퍼티는 prototype체인에 존재한다.</p>
<p>스코프의 생명주기<br>함수에 매개변수가 업ㄱ다면 외부와 단절이 된다. 하지만 매개변수는 없는 것이 가장 좋다.-&gt;외부에 의존하기 때문에</p>
<p>함수는 재사용을 한다. 변수를 왜쓰는가?-어떤 상태를 유지해야할때 사용한다.<br>변수를 공용으로 쓸때는(전역변수와 관련하여)? 고정되어 변하지 않는 값ㅇ르 가지는 경우에 사용한다.<br>상수는 재할당을 금지시킨다. 따라서  전역변수는 상수개념이 아니면 사용하지 않는것이 좋다.</p>
<p>1.순수함수-1언제나 동일 한 반환값(return x+y)<br>x(2,3)=5</p>
<p>2.비순수함수 -외부함수에 영향을 받음</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>스코프 함수</strong></p>
<p>변수가 어디에서 선언이 됐느냐가 즉 선언 위치가 스코프를 만든다.<br>class는 함수이다.<br>자신이 선언된 위치에 의해 다른 식벼자를 참조할 유효범위가 결정된다.</p>
<p>function foo(){}는 식별자가 2개이다. 1.암묵적으로 자바스크립트 엔진이 변수이름으로 만든 식별자.</p>
<p>2.지역함수의 식별자. 그런데 에러를 일으키지않는다. 그리고 foo는 전역 함수이다. 또한 호출하는 foo()에서 foo는 함수이름이 아니고 자바스크립트엔진이 생성한 암묵적인 식별자다.</p>
<p>스코프는 자카스크립트엔진이 식별자는 찾는 규칙이다. 코드와 가장 근접한 곳에있는 스코프를 본다.<br>자바스크립트 코드의 문맥과 환경이있따. 코드를 실행하기 위한 문맥을 기억한다. 자바스크립트는 전역과 지역을 어떻게 구분하는걸까?</p>
<p>식별자는 스코프내에서 유니크하다.<br>전역은 어디근 참조(문맥을 찾는다.)가 가능하다. 코드가 해당하는 스코프부터 식별자를 찾는다. 그후에 상위로 간다.<br>쉐도잉-그림자 처럼 가져려진다.<br>식별자는 자바스크립트엔진에 등록이된다.<br>이때 스코프가 정해진다.<br>식별자는 스코프 체인에서 찾는다. 함수는 변수와 저장되는 매카니즘이 같다. 찾는 매카니즘도 동일하다.</p>
<p><strong>렉시컬 시코프</strong><br>자바스크립트엔진이 함수를 정의할때 어디서 호출될지 알수없다.<br>언제 함수의 상위 스코프가 오는냐? 함수의를 할때 취치에 의해 상위 스코프가정해진다. 어디서 호출되든지 간에 정의위치에 ㄱ따라 사우이스코프가 정해져버린다.<br>동적스코프와 /렉시컬스코프의 차이</p>
<p>매개변수가 값을 할당하는 것은 호출할때, 호출된 직후 매개변수undefined 선언된다. 이후에 할당된다.<br>변수도 어디에서 선언되는지에 따라 스코프가 정해진다.함수도 마찬가지</p>
<p><strong>암묵적 전역변수</strong><br>전역함수에서 선언하지않은 변수는 전역변수가 된다.<br>모듈(자바스크립트 엔진은 파일 스코프를 가지지않는다.)-&gt;한개의 파일로 함ㅍ쳐진다. 같은 이름의 변숙가 있다면 재할다잉 된다.이런 문제 따문에 전역변수를 사용하지않는다.<br>자바스크립트에는 순서가 있다.엄청 여러개의 스크립트파일들을  webpack 번들링 로 하나로 묶고 그 안에서 스코프를 줘서 나눈다.</p>
<p><strong>변수의 생명주기</strong>- 변수 생명주기는 직역변수일때 함수의 생명주기가 짧다.리소스가 빨리 해방이 된다.<br> 반대로 전역변수의 생명주기(스코프가 길다.)는 길기 때문에 재할당 수정등의 여러가지 문제를 야기한다.</p>
<p>짧고 생명주기가 짧은 함수가 가독성이 좋다. 그리고  한가지 일만 을 시킬수있어서 좋다.</p>
<p>전역변수의 생명주기는 스크립트 로드가 되자마자 생성되고 애플리케이션이 종료될때 까지 (브라우저 종료) 전역변수는 리소스 할당이 적다.,암묵적 결함을 하고,네이밍스페이스를 오염시킨다. </p>
<p>모둘패턴 (문법이 아닌 디자인 패턴이다.)<br>즉시실행함수는 코드가 실행되면 바로 실행이 된다. 객체 리터럴이 바로 함수에 할당이 된다. 모듈패턴은 자바스크립트에는 자바에서 public,private,protected같은 접근제한자가 없다. 따라서 이를 상요함으로써 변수에 접근을 하지못하게하는 역할을 하기위해 사용한다.<br>let,const 블록레벨 스코프</p>
<p>var키워드는 전역 변수의 분제점으로 귀결된다. 왜var키워드를 사용할 수없는가?-&gt;함수레벨 스코프,전역변수 문제점,재할당 등의 이유.</p>
<p>변수 호이스팅은 나쁜점이다. 지양해야하는 부분.<br>변수는 선언하고 참조해라</p>
<p>let/const 변수 선언 중복선언애러,변수는 스코프가 분리되있으면 다른 변수이다.</p>
<p>for문()의 소괄호의 부분은 코드블록안에 있다고 생각을 하는 것이 좋다.</p>
<p>const/let은 호이스팅이 안하는 것 처럼 보이지만 한다.-런타임이전에 변수는 선언이 된다. 하지만 런타임에 선언문을 만나야지 값이 할당된다. 그렇기 때문에 선언문이전에 호출을 하면 에러를 발생시킨다. 즉 선언된 것을 자바스크립트엔진이 알지만 이에 접근하지 말라는 의미다.</p>
<p><strong>전역객체</strong></p>
<p>브라우저의 전역객체는 :window이다.<br>node.js의 전역객체는 :gloabal이다.<br>var키워드로 선언한 모든 전역변수는 window객체릐 프로퍼티가 된다.</p>
<p>브라우저의 페이지를 바꾸면 전역객체또한 리셋이 된다.<br>전역객체는 var키워드로 선언한다.<br>function foo(){}와 var foo=funciton(){}모두 window의 객체이다.</p>
<p>let으로 선언한 전역변수는 더이상 읽어들을 전역변수가 없다면 생명주기를 다하고 죽는다.<br>var와 let키워드를 섞어서 사용하지만고 한가지만을 통일해서 사용하자.<br>window객체의프로퍼티는 전역변수와 같게 사용 할 수 있다.</p>
<p><strong>const키워드</strong><br>재할당을 할수없다. 변수 선언과 동시에 값을 할당해 주어야한다.<br>상수도 변수이다. 재할당을 금지시킨다.(스네이크 케이스,대문자로 사용한다.).</p>
<p><strong>const 키워드의 객체</strong><br>재할당을 하는 일은 극히 드물다.<br>대부분 변수 const 사용한다. 변수 재할당 할일 이 없다.<br>객체는 변경가능한 값이다. 객체를 가지는 변수는 let을 사용할 이유가 없다. 객체는 기본적으로 재할당하지 않는다. es6/const ,let을 사용한다. 재할당 필요한 경우에만 let을 사용한다. </p>
<p>전역 코드의 실행이 종료되면 let종료,window는 살아있다. 완료값은 변수에 할당되는 값이 아니다.</p>
]]></content>
      <tags>
        <tag>스코프</tag>
      </tags>
  </entry>
  <entry>
    <title>데이터 타입 연산자</title>
    <url>/2019/10/08/%EB%B3%80%EC%88%98%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85%20%EC%97%B0%EC%82%B0%EC%9E%90/</url>
    <content><![CDATA[<p>var person,$elem,_name,first_name,val1;</p>
<p>,쉼표는 연산자다.<br>자바스크립트는 대소문자를 구분한다.</p>
<p>var FRISTNAME:식별자의 이름을 대문자로 쓰면 개발자들사이에서 ‘상수’라는 것을 암묵적으로 약속한다.</p>
<p>변수는 값의 이름을 나타낼수 있는 의미가 중요하다.<br>주석은 가급적 많이 사용하지 않는것이 좋다-오히려 주석이 이해를 방해/그만큼 네이밍이 중요하다.</p>
<p>카멜케이스- var fristName변수,함수 기본적으로 사용<br>파스칼케이스-var FirstName생성자함수,클래스<br>스테이크케이스-var first_name;<br>헝가리언 케이스-var strFirstName;<br>var $elem=$(‘.myClass’);</p>
<p>var a=10+20; 10.+,20은 각각이 토큰이다.</p>
<p>+는 산술 연산자,<br>식(표현식:10+20)=&gt; 값(value)으로 30;<br>식이 값이 되려면 자바스크립트 엔진이 식을 평가(evaluation)한다.<br>var a=10+20;(전체를 문:statement)</p>
<hr>

<p><strong>데이터 타입</strong>(7가지-숫자,문자열,불리언,undefined,null,symbol,객체 혹은 참조)</p>
<p>-데이터 타입이 필요하다-&gt;할당할때 변수에 확보해야하는 메모리 공간을 확보할 수있다.</p>
<p>1.타입을 알아야-메모리 공간을 확보한다.<br>2.몇 바이트 공간이 필요한가<br>3.가져온 값을 어떻게 해석해야하는가?</p>
<p>숫자값 저장(8byte 사용) 타입마다 확보해야하는 메모리 공간 제각각이다. 타입을 모르면 확보해야할 메모리를 모른다.</p>
<p>score을 선두에 접근한다. 8byte만큼 가져옴-&gt;가져온 데이터 2진수(문자/숫자/불리언 등으로 어떻게 알것이냐?)<br>-&gt;따라서 식별자는 타입을 알아야한다.</p>
<hr>

<p><strong>값</strong>:현재 메모리에 들어있는 데이터<br><strong>값의 특징:</strong>타입을 가지고 있다(7가지 타입중하나)<br><strong>값이란?</strong> 더이산 평가 할 수 없는 하나의 표현식이다.<br>ex)30-리터럴/리터럴 표기법(10진수)/값을 만들어낸느 가장 시초<br><strong>평가란?</strong>식을 하나의 값으로 계산한다.ex)10+20평가의 대상 -평가의 결과물은 <strong>값</strong>이다.<br>표현식은 평가가 되어 값이 되는 것이다.<br>10(피연산자,리터럴)+(산술 연산자)20(피연산자,리터럴)</p>
<p>값을 표기하는 방법 크게 두가지다</p>
<p>1.<strong>리터럴</strong>(ex)30.<br><strong>2.표현식</strong>(ex)10+20-&gt;하나 이상의 리터럴,하나 이상의 표현식 연산자로 만들어진 ‘문(statement)’이다.</p>
<p>10+20:표현식-&gt; 자바스크립트엔진에서 평가-&gt;값 30을 만듦/리터럴 표기법를 평가해야 값을 만들어낸다.(평가 전에는 값이 만들어지지않는다.)</p>
<p>숫자 리터럴/문자열 리터럴/불리언 리터럴/null리터럴/undefined리터럴/객체 리터럴/배열 리터럴/함수 리터럴/정규표현식 리터럴</p>
<p>리터럴은 사람이 이해하기 편하게 하기 위해서 만들었다.</p>
<p><strong>데이터 타입</strong><br><strong>원시타입</strong>(숫자/문자열/불리언/undefined/null/symbol)</p>
<p><strong>객체 타입</strong>(object/reference type):객체,함수,배열</p>
<p>정수/실수-모든숫자를 실수 타입으로 처리를 한다.</p>
<ul>
<li>Infinity : 양의 무한대</li>
<li>-Infinity : 음의 무한대</li>
<li>NaN : 산술 연산 불가(not-a-number)</li>
</ul>
<p>표현식은 평가 되어져서 하나의 값을 만든다.<br>식별자는 결국 표현식이다.<br>(ex)var a=10;var a=b;b=a+10;표현식은 하나의 값으로 표현할 수있다.</p>
<p><strong>문자열</strong><br>작은 따옴표,큰 따옴표-개행하기 위해서는 이스케이프 시퀀스를 사용한다.(개행:\n);</p>
<p>백틱문자는 엔터나 띄어쓰기 같은 것,’’,””을 모두 동시에 사용할 수 있다는 장점이 있다.</p>
<p>console.log(‘My name is’+frist+’’+second+’!’);</p>
<p>+은 문자열 연산자-좌우항에 하나라도 문자열이 있다면 + 연산자로 결합하여 문자열이 된다.<br><code>${문자열}</code> ex)console.log(<code>1+1=${1+1}</code>);</p>
<p>‘2’는 문자열이다. 이는 암묵적인 타입변환이 일어났단는 것을 알수있다. 이러한 암묵적인 변환은 에러의 온상이 된다.</p>
<p><strong>불리언 타입</strong><br>논리적인 참,거짓을 나타내는 true 와 false를 가진다.</p>
<p><strong>undefined타입</strong><br>undefined타입 값은 undefined가 유일 하다.선언 이후에 명시적으로 값을 할당하지 은 변수는 자바스크립트 엔진의 암묵적 초기화에 의해서 undefined값을 가진다. 따라서 선언은 되었지만 아직 값을 할당하지 낳은 변수에 접근하면 undefined가 반환된다.</p>
<p><strong>선언</strong>:변수는 선언이라고 부를 것이다.<br><strong>정의</strong> :무언가를 할당해서 그 변수에 어떤 값을 가지고있는지 명확히 나타냄<br>함수,클래스는 ‘정의’로 부르겠다. 선언과 동시에 객체가 생성됨</p>
<p><strong>null타입</strong></p>
<p>변수에는 값이 없다는 것을 명확히 나타냄.<br>ex)var foo=’lee’; foo=null(가비지 컬렉터가 로 ‘lee ‘를 해제해 주세요)</p>
<p><strong>동적 타이핑(타입이 동적이다.)</strong><br>동적타입언어(자바스크립트)-변수의 타입이 없다(값에 타입이 있다.)-편하지만 신뢰성이 떨어진다(변수의 타입이 암묵적으로 변환이 된다.).</p>
<p>값에 의해서 변수의 타입이 결정이 된다.변수는 선언이 아닌 할당에 의해 타입이 결정된다. 재할당에 의해 변수의 타입은 언제든지 동적으로 바뀔 수 있다.-&gt;하나의 변수에 여러가지 값을 마구마구 집어널을 수있다.</p>
<p><strong>정적타입의 언어</strong>(자바,c)-변수자체가 타입이 있다=엄격하다(정해진타입의 값만이 들어갈수있기 때문에 )그래서 안정성이 있다.</p>
<p>언제나 변수의 타입의 값을 확정할 수있다.</p>
<p>Typescript -&gt;자바스크립트 에 정적 타입을 도입한것.</p>
<p>동적 타입언어는 편리함,but위험이 도사리고 있다.</p>
<p>동적으로 변화하는 데이터타입을 추측하기 어려운데 ,안정적인 프로그램을 만들기 위해서<br>1.변수를 최소화 한다.<br>2.전역변수(라이프 주기가 길다)사용x<br>변수의 생명주기를 짧게 만든다.<br>3.변수보다 상수를 사용해서 값의 변경을 억제 하자.<br>4.변수의 이름을 존재를 파악할 수있도록 명명한다.</p>
<hr>
<p><strong>표현식과 연산자</strong></p>
<p><strong>표현식</strong> :하나의 값을 표현할 수있는 문<br>표현식에 리터럴,식별자,연산자를 사용할 수있다.</p>
<p><strong>리터럴</strong>-사람이 이해할 수있는 값으로 나타냄<br>리럴은 표현식을 만드는 요소중에 하나이다.리터럴은 표현식이 될수있지만, 표현식은 리터럴 일수도 아닐 수도 있다.</p>
<p><strong>문</strong>-표현식일수도 아닐수도 있다.(문&gt;표현식)</p>
<p><strong>표현식인 문</strong>-값으로 표현(변수에 할당)<br><strong>표현식이 아닌 문</strong>-값으로 표현 (변수에 할당x)<br> 표현식인 문과 표현식이 아닌 문을 확인하는 가장 쉬운 방법은 변수에 할당해보는 방법이다.</p>
<p><strong>변수선언문</strong>-표현식이 아닌 문<br><strong>할당문**</strong>-(ex)x=5; 어떤 변수에 할당할 수있다.</p>
<p>문은 세미콜론으로 끝나야한다. 그러나 단 코드 블록 뒤에는 붙이지 않는다. 자동 삽입 기능이있지만 붙이는 것이 권고 된다.</p>
<p><strong>연산자</strong>:표현식을 만드는 연산자.피연산자에는 식이 올수도 있다.</p>
<p><strong>이항 연산자</strong>는 부수효과가 없다.<br>그러나 단항 연산자++,–부수효과가 있다.</p>
<p>+’10’숫자로 암묵적으로 변한이 일어남</p>
<p><strong>비교연산자</strong><br>===타입이 다르면 false이다.==타입이 달라도 같은 결과라고 나오는 경우가 있기에 ===을 사용해야함.<br>!==와 !==도 마찬가지</p>
<p>NaN===NaN은 false을 반황하는대   NaNdㅡㄴ 자신과 일치하지 않은 유일한 값이다. 따라서 NaN인지를 조사하려면 빌트인 함수를 isNaN을 사용해여한다.</p>
<p><strong>대소 연산자</strong>도 true와 false값을 받는다.</p>
<p><strong>3항 조건 연산자</strong><br>조건식? 조건식 이 true일때 반환하는 값 :조건식이 false일때 반환하는 값<br>var x=2;</p>
<p>var result=x%2? ‘홀수’:’짝수’;</p>
<p>console.log(result);</p>
<p>var x=2,result;</p>
<p>if(x%2){<br>result=’홀수’;</p>
<p>}else{</p>
<p>result=’짝수’</p>
<p>}console.log(result);</p>
<p><strong>논리연산자</strong></p>
<p>or(논리합:||)and(논리곱:&amp;&amp;) not(!)</p>
<p><strong>드모르간의 법칙</strong> !(x || y)===(!x &amp;&amp; !y)</p>
<p><strong>단축평가</strong>-피연산자가 불리언이 아닐수도 있다 어느 한쪽을 선택함</p>
<table>
<thead>
<tr>
<th>단축 평가 표현식</th>
<th>평가 결과</th>
</tr>
</thead>
<tbody><tr>
<td>true||anything</td>
<td>true</td>
</tr>
<tr>
<td>false||anything</td>
<td>anything</td>
</tr>
<tr>
<td>true&amp;&amp;anything</td>
<td>anything</td>
</tr>
<tr>
<td>false&amp;&amp;anything</td>
<td>false</td>
</tr>
</tbody></table>
<p><strong>typeof연산자</strong> </p>
<p>typeof funciton(){}-함수 리터럴-&gt;function을 받는다<br>생성자 함수=new 객체와 새로운 함수를 만든다.<br>typeof null은 object를 반환한다.</p>
<p><strong>지수연산자</strong></p>
<p>5 ** 2-&gt;25;</p>
<p>var num=5;<br>num ** =2-&gt;25</p>
<p>1.연산자 ++/–변수 ㄱ밧을 고친 다 부수효과가 존재한다.<br>2.동등연산자의 차이(===/==);<br>3.삼항조건연산자,if문 대신 사용할 수 있다.</p>
]]></content>
      <tags>
        <tag>변수 뒷부분 + 1.데이터타입 2.연산자</tag>
      </tags>
  </entry>
  <entry>
    <title>웹접근성과 WAI-ARIA</title>
    <url>/2019/09/17/%EC%9B%B9%EC%A0%91%EA%B7%BC%EC%84%B1/</url>
    <content><![CDATA[<p> 웹 접근성이란 웹 사이트에서 제공하는 정보를 차별없이 동등하게 이용 할 수 있도록하는 보장하는 것을 말한다. 신제적(고령층 ,장애인,비장애인 ) 환경적 요건(다양한 플랫폼,웹 브라우져,장치)을 모두 포함한다.</p>
<p>WAI ; Web Accessibility InitiativeWAI는 시각·청각 기능 등에 장애를 지닌 사람도 일반인과 동등하게 웹에 접근하여 이용할 수 있도록 관련 지침을 개발하고 웹 접근성 향상을 위한 노력을 기울이는 W3C의 산하 단체를 말한다</p>
<p>ARIA:Accessible Rich Internet Applications’의 약자로 리치 인터넷을 위한 W3C 접근성 명세입니다.</p>
<p>RIA:정적인 HTMl과 단순한 자바스크립트 환경의 웹이 아닌 동적인 자바스크립트와 Ajax와 같은 기술을 사용한 환경에서 수준 높은 UX(User eXperience)를 제공하는 웹 애플리케이션을 의미한다.</p>
<p>WAI-ARIA는 RIA에서 스크린 리더기 및 보조기기 등에서 접근성 및 운용성을 향상시키기 위한 목적으로 탄생했으며 웹 애플리케이션에 역할,속성,상태 정보를 추가하여 이를 개선 할 수 있도록 제공하고 있다.</p>
<p>1)대표적인 역할( role):tablist,button,tab,tooltip,list,</p>
<p>application,abnner,navigation,form,search..</p>
<p>2)Property &amp; State:(상태와 속성):aria-labelledby=”” : 레이블 제공을 위한 aria-속성. 상태 값은 연결시킬 레이블 id를 입력한다.</p>
<p>aria-haspopup=”” : 팝업요소가 하위에 존재하고 있다는걸 인식 시켜주는 aria-속성. 상태 값은 false(default) / true / menu / listbox / tree / gird / dialog</p>
<p>aria-live : 페이지의 어떤 위치에 있든 업데이트된 정보를 사용자에게 알려주는 aria-속성. 상태 값은 assertive / off(default) / polite</p>
<p>aria-labelledby=”” : 레이블 제공을 위한 aria-속성. 상태 값은 연결시킬 레이블 id를 입력한다.</p>
<p>aria-selected=”” : 탭메뉴 선택 유무를 알려준다. 상태 값은 선택되었을 때 true / 선택되지 않았을 때 false 입력</p>
<p>ria-controls=”” : 현재 요소가 제어하는 대상을 명시하는 속성으로 탭메뉴와 본문을 연결시켜준다. 상태 값은 tabpanel의 id명 입력</p>
]]></content>
      <tags>
        <tag>웹 접근성과 WAI-ARIA</tag>
      </tags>
  </entry>
</search>
