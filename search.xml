<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10월 2일 수업내용정리</title>
    <url>/2019/10/03/10%EC%9B%942%EC%9D%BC%EC%88%98%EC%97%85%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/</url>
    <content><![CDATA[<p><strong>자바스크립트의 특징</strong> - 웹브라우저에서 동작하는 유일한 언어/고속으로 동작하는(웹 브라우저로 돌리는 게임) 어플리케이션에선 불리함</p>
<p>기계어 프로그래밍 언어(어셈블리언어)-만국공용어-&gt;어셈블리어 cpu종류마다 실행파일이 다름.그에따라 실질적인 언어 사용</p>
<p>웹 어셈블리어(보통 게임에서 사용) c#,c++뭐로코딩하든 중간으로 떨려서 브라우저를 돌리자.</p>
<p><strong>대부분의 언어 객체지향</strong>-&gt; 클래스로함(<strong>클래스 기반 객체지향언어</strong>)<br><strong>자바스크립트</strong>는-<strong>프로토 타입기반의 객체지향</strong></p>
<p>c(절차지향)/java(객체지향)/<strong>javascript(멀티 패러다임,객체 절차(명령),함수형 언어)</strong></p>
<p><strong>자바스크립트의 함수는 값이다</strong>.(값이란 서로 주고받을 수 있는 특성을 의미한다.why:함수형 프로그래밍을 가능하게 하기 위해)</p>
<p><strong>자바스크립트엔진</strong>-자바스크립트를 실행할 수있는 환경</p>
<p><strong>인터프리터</strong>-컴파일러가 결합해서 처리속도느린것을 해결-but토끼굴 </p>
<p><strong>명령어</strong>-절차지향형,함수,프로토타입기반 객체지향 (프로토 타입기반 객체기반을 중심으로 공부를 한다.)-멀티 프로그래밍/객체기반 언어-클래스기반(c#,java).</p>
<hr>
<p> <strong>web api(web aplication progamming interface)</strong>가 들어있는 환경에서는 웹브라우저에서만 적용한다. node.js에서 실행x</p>
<p>html은 크게 2개의 태그를 가진다.(<head><meta name="generator" content="Hexo 3.9.0">,</head><body>)<br>head-meta date=설정 정보(애플리케이션을 위한 데이터) 기본적으로 시멘틱을 생각했을때 sciprt태그가 head에 들어가야한다고 생각하지만, html은 인터프리터 언어이기때문에 스크립트 태그는 body끝나기 전에 사용한다.이는 DOM을 생성하는 것과 관련이있다. script태그가 앞에나오게 되면 html은 순차적으로 위에서 아래도 일고 해석하는 인터프리터 언어인데 scipt태그에서 DOM과 관련된 내용을 건드리게 되고 아직html의 DOM은 생성되어있는 상태가 아니기 때문에 에러를 발생시킨다.</body></p>
<script>안의 document.querySelecotr와 같은 요소 관련 내용은 html,css와 관련된 web api이다-> 그래서 웹 브라우저에서 실행하고 ,node.js에서는 실행하지 못한다.

 **ECMAScript는 (node/브라우저)모두 포함하는 코어이다.**

### 웹 브라우저는 어떻게 동작하는가?

client(웹브라우저)---server(회사의 서버)
request(client->server)------------response(server->client)

**loading(로딩)**-브라우저가 서버로 부터 다운로드하여 파일을 가져온다. 웹서버는 루트(대문)로 접근하면 index.html(html파일 안에는 javascript와 css등이 링크로 연결이 되어있다.)을 받을 수있다. 

www.naver.com/(index.html주소창에 생략이가능하다).-도메인 주소(서버가 식별 할 수 있는 주소)

------

모든 웹애플리케이션은 **HTTP**(htper text transfer protocol)프로토콜을 규약으로 동작한다.(request/response).서버의 파일은 0,1로 구성되어있는 데이터이다.이를 웹브라우저로  보낼때 서버에있는 정보를 패킷으로 잘게 쪼갠 정보를 보내고 이를 받아서 하나의 파일로 뭉치는 과정을 겪는다.



![3-3](https://poiemaweb.com/assets/fs-images/3-3.png)

load HTML을 한 상태가 (resquest와 response를 해서 index.html을 파일을 받은 상태)---Read(메모리상에 데이터를 올린다.)----Parse(html데이터를 읽어들여서 컴퓨터가 실행할 수있는 형식으로 만든다.)----->(결과물)Dom tree(부자관계 부모와 자식의 구조를 가진다.)

기본 html은 중첩된 구조를 가지고 있다.크게 html의 자식으로 head와 body태그가 있다.(이는 부모와 자식이라는  구조화 할 수있다.)그리고 container라는 div태그를 만들어서 그 안에 자식을 넣고 그 자식의 형제들을 넣는다. 그렇게 하는 것이 부모의 속성을 자식에게 상속시켜서 한번에 무엇인가를 처리하기 좋다. html의 중첩 같이 html의 자료구조를 배열하는것이 DOM tree를 구성하는 것이다. 

**이렇게 트리구조를 만드는 이유는?**-그래야 부모로 올라가고 자식으로 내려가고 왔다 갔다하면서 자료에 접근하기가 용이하다. 조작을 하려면 접근해야하는 메모리상 트리구조에서 조작을 한다. parsing은 rendering engine(html과 css)에서한다. http 1.1. connection은 한번에 자료를 하나씩 가져옴을 의미한다

html의 link에 css가 있으면 다시 서버에 요청을 보내서 그것을 가져와야한다. 그렇게 되면 html에서 parsing되며 만들고있던 Dom만들기를 일시 중단을 한다. css도 Dom tree를 형성하는데 이를 cssom tree라고 한다. 그후 DOM를 생성하는 작업을 계속 수행한다.(pasing 작업) 작업이 진행되면서 내려가다가 자바스크립트 링크를 만나면 다시 parsing를 중단하고  자바스크립트 엔진에서 이를 parsing한다 그러고 javascript DOM(syantax tree)을 만든다. 이런과정을 거치면서 만들어진html Dom 와 CSS DOM를 합쳐서 render tree라고 부른다.

render tree가 만들어지면은 이제 웹 브라우저에 그릴 준비가 끝났다.이후 그림을 그릴때 그림을 그리는것은 부담이 큰작업이기 때문에 변화가 없는 데이터에 대해서는 그리지 말아야한다.

**http특징은 단방향통신이다.**(ex무전기 양쪽에서 동시에 이야기를 할 수 없다.)/양방향통신(휴대전화)
**http특징 단방향 통신이지만 쌍으로 이루어져있다**.(request를 보내면 반드시 response가 있다. 요청을 받아서 그림을 그린다.)
Dom tree와 CSSOM TREE가 합쳐지고 render tree가 생성되는데 javascript의 sytax tree는 render tree의 내용을 지우거나 내용을 갈아낀운다던가 혹은 글자의 속성을 바꾼다 던지의 수행을 한다.



파일로 된 javascript 소스코드
token(더이산 나눌수 없는 원소-으미를 가지고 있는 최소단위인 형태소의 의미를 가진다.)
구문분석=문법들을 추가한다(어셈블리어로 만든다.)
자바스키립트 엔진의 소스코드 실행과정
script태그가 돔 구성보다 먼저 등장해서  cssom tree,dom tree의 돔 트리를 건드리면  DOM이 구성되지 상태이기 때문에 오류를 발생한다. body tag밑으로 와야한다.</script>]]></content>
      <tags>
        <tag>10월 2일 수업내용 정리</tag>
      </tags>
  </entry>
  <entry>
    <title>10월 7일 러버덕(키워드,식별자,변수와 선언,메모리,메모리 주소,할당,호이스팅)</title>
    <url>/2019/10/07/10%EC%9B%947%EC%9D%BC%EB%9F%AC%EB%B2%84%EB%8D%95/</url>
    <content><![CDATA[<h3 id="1-키워드"><a href="#1-키워드" class="headerlink" title="1.키워드:"></a><strong>1.키워드</strong>:</h3><p>명령어(뒤에 값을 준다.)<br><strong>자바스크립트에게 내리는 명령.</strong><br>변수선언하려면 반드시  키워드 사용(var/let,const)</p>
<h3 id="2-식별자-변수이름"><a href="#2-식별자-변수이름" class="headerlink" title="2.식별자(변수이름):"></a><strong>2.식별자(변수이름):</strong></h3><p>고유한이름/일종의 카드키와 같다.<br><strong>식별자(변수이름)-메모리에 있는 값을 구별해서 끄집에 낼 수 있는 값</strong><br>./어떤 값을 구별하여 식별해 낼 수 있는고유한 이름.</p>
<p>또한 <strong>식별자는 메모리 주소를 알고있다.</strong></p>
<p>변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 저장된다.<br>네이밍 규칙-예약어x/특수문자 _ $가능 숫자 처음 에 안나옴.</p>
<h3 id="3-변수와-선언"><a href="#3-변수와-선언" class="headerlink" title="3.변수와 선언:"></a><strong>3.변수와 선언:</strong></h3><p><strong>변수-</strong>데이터를 다룬다. 하나의 값을 저장할 수있는 메모리 공간에 붙은 이름 혹은 메모리 자체를 의미한다.</p>
<p>변수를 사용하려면 반드시 선언을 해줘야한다.</p>
<p><strong>변수의 선언-</strong><br>변수를 생성한다. 변수란 컴퓨터의 메모리 와 관련있다.<br>자바스크립크엔진에 변수이름 등록,값 저장을 위한 메모리 공간을 확보하기위함.</p>
<h3 id="4-메모리와-주소"><a href="#4-메모리와-주소" class="headerlink" title="4.메모리와 주소:"></a><strong>4.메모리와 주소:</strong></h3><p>메모리:데이터를 저장할 수 있는 데이터 셀들의 집합체.<br>메모리주소: 메모리 공간의 위치를 나타내며 0부터 시작하여 메모리의 크기만큼 정수로 표현된다. </p>
<p>값을 입력하면 메모리 임의의 공간에 저장이 된다.하지만 메모리의 주소는 알여주지 않는데 저장된 데이터를 재사용하기 위해서는 변수를 제공해야하고 변수는 저장되는 곳의 메모리 주소를 기억한다.</p>
<p>매니지드:(자바스크립트):<br>언매니지드(c언어):</p>
<h3 id="5-할당"><a href="#5-할당" class="headerlink" title="5.할당:"></a><strong>5.할당</strong>:</h3><p> 변수에 값을 저장한다. 할당한다(저장한다.대입한다.assign한다)<br>논리적으로 기본적으로 변수를 선언하고 할당해야한다. 변수만을 선언하고 할당하지 않으면 값이 정의 되지 않았기 때문에 undefined가 출력이 된다.</p>
<p>변수선언은 소소코드가 순차적으로 실행되기 이전,즉 런타임 이전에 먼저실행되지만,값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.</p>
<h3 id="6-호이스팅"><a href="#6-호이스팅" class="headerlink" title="6.호이스팅-"></a><strong>6.호이스팅-</strong></h3><p>왜 호이스팅이 발생하는가?-&gt;**선언문은 실행될때 가장먼저 골라져서 실행되기대문에 발생한다.위 끌어올려서 실행된 실행문은 또 실행되지 않는다.</p>
]]></content>
      <tags>
        <tag>1키워드,2.식별자.3.변수와 선언 4.메모리와 메모리주소5.할당6.호이스팅</tag>
      </tags>
  </entry>
  <entry>
    <title>CSR(클라이언트 사이드 렌더링)과 SSR(서버 사이드 렌더링) 차이점</title>
    <url>/2020/05/03/CSR%20SSR%20SPA%20/</url>
    <content><![CDATA[<p><strong>1.CSR(클라이언트 사이드 렌더링)</strong><img src="https://s3.amazonaws.com/media-p.slid.es/uploads/640576/images/3943424/CSR.png" alt="CSR"></p>
<p>-1.Server Sending Response to Browser<br>-2.Browser Downloads JS<br>-3.Browser executes React<br>-4.Page Now Viewable and Interatable</p>
<p>서버에서 비어있는 html와  js파일들을 받아오고 , 데이터는 서비스에 필요한 리소스를 다운로드한후 브라우저에서 렌더링한다.그렇기 때문에 초기 View을 보기가지 SSR보다 시간이 더 걸린다. 하지만 사용자에게 보여진 view의 기능은 동시에 동작한다.</p>
<p><strong>2.SSR(서버사이드 렌더링)</strong><img src="https://s3.amazonaws.com/media-p.slid.es/uploads/640576/images/3943426/SSR.png" alt="SSR"></p>
<p>-1.Server Sending Ready tobe redered HTML Response to Browser<br>-2.Browser Renders the page,Now Viewable,andBrowser Downloads JS<br>-3.Browser execute React<br>-4.Page Now interatable</p>
<p>서버에서 렌더링해 가져오기 때문에 ,첫 로딩 매우 짧다.<br>그러나 클라이언트가 js파일을 모두 다운로드하고 적용하기전가지는 각각의 기능은 동작하지않는다는 단점이 있다</p>
<p><strong>3.SPA(Single page application)</strong></p>
<p>서버로 부터 처음에만 페이지를 받아오고 이후에는 동적으로 페이지를 구성해서 새로운 페이지를 받아오지않는 웹 애플리케이션을 의미한다.<br> 페이지가 한번 로딩된 이후 데이터를 수정하거나 조회할때. 페이지가 새로고침이 되지않고 다른 페이지로 넘어가지 않습니다.</p>
<p><strong>4.MPA(Multi Page Application)</strong></p>
<p>서버로 부터 완전한 페이지를 받아오고 이후에 데이터를 수정하거나 조회할때 다른 완전한 페이지로 이동합니다.단 URL이 바뀔수있습니다.</p>
]]></content>
      <tags>
        <tag>CSR(클라이언트 사이드 렌더링)과 SSR(서버 사이드 렌더링) 차이점</tag>
      </tags>
  </entry>
  <entry>
    <title>IR 기법</title>
    <url>/2019/09/17/IR%EA%B8%B0%EB%B2%95/</url>
    <content><![CDATA[<p>홈페이지를 만들때 이미지를 사용할 경우 img태그를 사용해 alt로 이미를 부여 합니다.</p>
<p>IR(image replacement)은 웹표준 및 접근성을 위한 기법입니다. 이미지를 배경으로 처리하고 이미지의 의미를 텍스트화 하여 CSS로  숨겨, 이미지 대체 텍스트를 제공하기 위한 기법 입니다. IR기법은 앞에서 얘기한 대로 접근성이 매우 유용하기 때문에 검색시에 검색엔진으로 부터 높은 가중치를 받을 수 있습니다.</p>
<p>IR을 사용하는 방법으로는 크게 </p>
<ol>
<li><p>padding을 사용하는 방법(가로 250px,세로 195px인 이미지)</p>
<h2 class="brand1">CSS ZenGarden</h2>

<p> .brand1{ background:pink url()no-repeat;height: 0;width: 250px;padding-left: 195px;overflow: hidden;}</p>
</li>
<li><p>text-indent 를 사용하는 방법</p>
<h2 class="brand2">CSS ZenGarden</h2>

<p>.brand2{background: pink url(/images/title.png)no-repeat;height: 195px;width: 290px;text-indent: 290px;</p>
<p>​    <em>/\</em> text-indent: -9999px; */*white-space: nowrap;overflow: hidden;}</p>
<p>*text-indent의 값을 -9999px을 주어 텍스트를 아예 화면 밖으로 밀어 버리는 경우도 있지만, 이 경우에는 성능상 좋지 않으므로 white-space:nowrap와 overflow:hidden을 사용한다.</p>
</li>
<li><p>postion을 활용하는 방법</p>
<h1 class="brand3">CSS ZenGarden</h1>

<p>.brand3{background: lime ;height: 195px;width: 290px;text-align: center;line-height: 195px; font-size: 16px;font-weight: 400;position: relative;} .brand3::after{ content: “”;position: absolute;top: 0;left: 0;background: url(/images/title.png)no-repeat;width: 100%;height: 100%;}</p>
</li>
</ol>
<p>이외에도 숨기고자하는 텍스트를 span태그로 감싸 준 후 화면에서 안보이게 처리해주는 방법도 있고, 방법은 다양하다.</p>
<p>그리고 Daum은 이런 여러기법중에서  Phark Method와WA IR 기법을 주로 사용하여 대체텍스트를 제공해주고 있다.</p>
<p>Phark Method (권장): 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 text-indent를 이용하여 화면 바깥으로(-9999px만큼 내어 쓰기) 빼내어 보이지 않게 하는 방법.</p>
<p>장점:스크린 리더기가 읽어주고,추가적인 태그사용을 하지 않는다.</p>
<p>WA IR 기법(권장):이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span 태그로 감싼 후 z-index:-1을 이용하여 화면에 안보이게 처리하는 방법.</p>
<p>장점:스크린 리더기 가 읽어줌,CSS on / Image off 시 텍스트 보임.</p>
]]></content>
      <tags>
        <tag>IR기법 활용에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>제너레이터와 async-await</title>
    <url>/2020/05/05/generator-aync-await-md/</url>
    <content><![CDATA[<h1 id="1-제네레이터"><a href="#1-제네레이터" class="headerlink" title="1.제네레이터"></a>1.제네레이터</h1><p>es6에서 도입된 제너레이터 함수는  이터러블을 생성하는 함수이다. 제너레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편하게 이터러블을 구현 할 수 있다. 또한 제너레이터 함수는 비동기 처리에 유용하게 사용된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//이터레이션 ㅍ,로토콜을 구현하여 무한 이터러블을 생성하는 함수</span></span><br><span class="line"><span class="keyword">const</span> createInfinittbyIteration = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i =<span class="number">0</span>;<span class="comment">//자유 변수</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;,</span><br><span class="line">    next()&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>:++i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> n <span class="keyword">of</span> createInfinitbyIteration())&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">5</span>)<span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n)<span class="comment">//1 2 3 4 5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//무한 이터러블을 생성하는 제너레이터 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createInfinittbyIteration</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;<span class="keyword">yield</span> ++i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> n <span class="keyword">of</span> createInfinittbyIteration())&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n) <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>제너레이터 함수는 일반 함수와는 다른 독특한 동작을 한다. 제너레이터 함수는 일반 함수와 같이 함수의 코드 블로그을 한번에 실행하지 않고 함수 코드 블록의 실행을 일시 중단했다가 필요한 시점에 재시작 할 수 있는 특수한 함수이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'첫번째 호출'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;								<span class="comment">//첫번째 호출시에 이 지점까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'두 번째 호출'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;								<span class="comment">//두번째 호출 시에 이 지점까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'세번째 호출'</span>)<span class="comment">// 세번째 호출 시에 이 지점까지 실행한다</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());<span class="comment">//첫번째 호출 &#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());<span class="comment">//두번째 호출 &#123;value:2,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());<span class="comment">//세번째 호출 &#123;value:undefined,done:true&#125;;</span></span><br></pre></td></tr></table></figure>

<p>일반 함수를 호출하면 return 문으로 반환값을 리턴하지만 제너레이터 함수를 호출하면 제너레이터를 반환한다. 이 제너레이터는 이터러블이면서 동시에 이터레이터인 객체이다. 다시 말해 제너레이터 함수가 생성한 제너레이터는 Symbol.iterator메소드를 소유한 이터러블이다. 그리고 제너레이터는 next()메소드를 소유하며 next메소드를 호출하면 value,done 프로퍼티를 갖는 이터레이터 객체를 반환하는 이터레이터이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//제너레이터 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> v <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="keyword">yield</span> v;</span><br><span class="line">  <span class="comment">//=&gt;yield* [1,2,3];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//제너레이터 함수를 호출하면 제너레이터를 반환한다.</span></span><br><span class="line"><span class="keyword">let</span> generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터는 이터러블이다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> generatorObj) <span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i int generatorObj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)<span class="comment">// 1 2 3 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터는 이터레이터이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span> <span class="keyword">in</span> generatoroBJ)	<span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:1,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:2,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:3,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:undefined,done:true&#125;;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-제너레이터-함수의-정의"><a href="#2-제너레이터-함수의-정의" class="headerlink" title="2.제너레이터 함수의 정의"></a>2.제너레이터 함수의 정의</h1><p>제너레이터 함수는 function* 키워드로 선언을 한다. 그리고 하나 이상의 yield문을 포함한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//제너레이터 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genDecFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObj = genDecFunc();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 함수 표현식</span></span><br><span class="line"><span class="keyword">const</span> genExpFunc = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 메소드 </span></span><br><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">  *generatorObjMethod()&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">generatorObj = obj.generatorObjMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 클래스 메소드</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">  *generatorClsMethod()&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">generatorObj = myClass.generatorClsMethod();</span><br></pre></td></tr></table></figure>

<h1 id="3-제너리이터-함수의-호출과-제너레이터-객체"><a href="#3-제너리이터-함수의-호출과-제너레이터-객체" class="headerlink" title="3.제너리이터 함수의 호출과 제너레이터 객체"></a>3.제너리이터 함수의 호출과 제너레이터 객체</h1><p>제너레이터 함수를 호출하면 제너레이터 함수의 코드 블록이 실행되는 것이 아니라 제너레이터 객체를 반환한다. 앞에서 살펴본 바와 같이 제너레이터 객체는 이터러블이며 동시에 이터레이터이다. 따라서 next메소드를 호출하기 위해 Symbol.iterator 메소드로 이터레이터를 별도로 생성할 필요가 없다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//제너레이터 함수 정의 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 1'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>; <span class="comment">//첫번째 next메소드 호출시 여기 까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 2'</span>)</span><br><span class="line"> 	<span class="keyword">yield</span> <span class="number">2</span>; <span class="comment">//두번째 next메소드 호출시 여기 까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 3'</span>)</span><br><span class="line"> 	<span class="keyword">yield</span> <span class="number">3</span>; <span class="comment">//세번째 next메소드 호출시 여기 까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 4'</span>)</span><br><span class="line"> 	</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.</span></span><br><span class="line"><span class="comment">//제너레이터 객체는 이터러블이며 동시에 이터레이터이다.</span></span><br><span class="line">.<span class="comment">//따라서 Symbol.iterator 메소드로 이터레이터를 별도 생성할 필요가 없다.</span></span><br><span class="line"><span class="keyword">const</span> generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//첫번째 next 메소드 호출:첫번째 yield문까지 실행되고 일시 중단된다.</span></span><br><span class="line"><span class="comment">// Point 1</span></span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 두번째 next 메소드 호출: 두번째 yield 문까지 실행되고 일시 중단된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());</span><br><span class="line"><span class="comment">// Point 2</span></span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 세번째 next 메소드 호출: 세번째 yield 문까지 실행되고 일시 중단된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());</span><br><span class="line"><span class="comment">// Point 3</span></span><br><span class="line"><span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 네번째 next 메소드 호출: 제너레이터 함수 내의 모든 yield 문이 실행되면 done 프로퍼티 값은 true가 된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());</span><br><span class="line"><span class="comment">// Point 4</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>제너레이터 함수가 생성한 제너레이터 객체의 next메소드를 호출하면 처음만나는 yield문까지 실행되고 실시 중단된다. 또 다시 next메소드를 호출하면 중단된 위치에서 다시 실행이 시작하여 다음 만나는  yieldㅁ누 까지 실행되고 또 다시 일시 중단 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start -&gt; generatorObj.next() -&gt; <span class="keyword">yield</span> <span class="number">1</span> -&gt; generatorObj.next() -&gt; <span class="keyword">yield</span> <span class="number">2</span> -&gt; ... -&gt; end</span><br></pre></td></tr></table></figure>

<p>next 메소드는 이터레이터 결과 객체와 가티이 value,done이라는 프로퍼티를 갖는 객체를 반환한다.vlaue프로퍼티는 yield문이 실행되었는지를 나타내는 boolean타입의 값이다. 마지막 yield문까지 실행된 상태에서 next메소드를 호출하면 done프로퍼티 값을 true가 된다.</p>
<h1 id="4-제너레이터의-활용"><a href="#4-제너레이터의-활용" class="headerlink" title="4.제너레이터의 활용"></a>4.제너레이터의 활용</h1><h2 id="4-1-이터러블의-구현"><a href="#4-1-이터러블의-구현" class="headerlink" title="4.1. 이터러블의 구현"></a>4.1. 이터러블의 구현</h2><p>제너레이터는 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편하게 이터러블을 구현할 수 있다. 이터레이션 프로토콜을 준수하여 무한 피보나치 수열을 생성하는 함수를 구현해 보겠다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 이터러블을 생성하는 함수</span></span><br><span class="line"><span class="keyword">const</span> infinityFibonacci =(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [pre,cur] =[<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [sYMBOL.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;,</span><br><span class="line">    next()&#123;</span><br><span class="line">      [pre,cur] = [cur,pre+cur];</span><br><span class="line">      <span class="comment">//done프로퍼티를 생략한다.</span></span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>:cur&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//infinityFibonacci는 무한 이터러블이다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> infinityFibonacci)&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">10000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">//1 2 3 5 8..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이터레이션 프로토콜을 보다 간단하게 처리하기 위해 제너레이터를 활용할 수 있다. 제너레이터는 활용하여 무한 피보나치수열을 구현한 이터러블을 만들어보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 이터러블틀 생성하는 제너레이터 함수</span></span><br><span class="line"><span class="keyword">const</span> infinityFibonacci =(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">let</span> [pre,cur] = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    [pre,cur] = [cur,pre+cur];</span><br><span class="line">    <span class="keyword">yield</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">//infinityFibonacci는 무한 이터러블이다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> infinityFibonacci)&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &gt;<span class="number">10000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>제너레이터 함수에 최대값을 인수를 전달해보자</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 이터러블을 생성하는 제너레이터 함수</span></span><br><span class="line"><span class="keyword">const</span> createInfiniteFibByGen =<span class="function"><span class="keyword">function</span>* (<span class="params">max</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">let</span> [prec,curr] = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    [prev,curr] =[curr,prev+curr];</span><br><span class="line">    <span class="keyword">if</span>(curr &gt;= max)<span class="keyword">return</span><span class="comment">//제너레이터 함수 종료</span></span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> createInfiniteFibByGen(<span class="number">10000</span>))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이터레이터의 next메소드와 다르게 제너레이터 객체의next메소드에는 인수를 전달할 수도 있다. 이를 통해서 제너레이터 객체에 데이터를 전달 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> res;</span><br><span class="line">  res = <span class="keyword">yield</span> n <span class="comment">//n:0&lt;= gen함수에 전달한 인수</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//res:1 &lt;= 두번째 next 호출 시 전달한 데이터</span></span><br><span class="line">  res = <span class="keyword">yield</span> res;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//res:2 &lt;= 세번째 next 호출 시 전달한 데이터</span></span><br><span class="line">  res = <span class="keyword">yield</span> res;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// res: 3 ⟸ 네번째 next 호출 시 전달한 데이터</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generatorObj = gen(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());  <span class="comment">// 제너레이터 함수 시작</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next(<span class="number">1</span>)); <span class="comment">// 제너레이터 객체에 1 전달</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next(<span class="number">2</span>)); <span class="comment">// 제너레이터 객체에 2 전달</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next(<span class="number">3</span>)); <span class="comment">// 제너레이터 객체에 3 전달</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 3, done: true &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>이터레이터의 next메소드는 이터러블의 데이터를 꺼내 온다. 이에 반해 제너레이터의 next메소드에 인수를 전달하면 제너레이터 객체에 데이터를 밀어 넣는 다. 제너레이터의 이런 특성은 동시성 프로그래밍을 가능케 한다.</p>
<h1 id="4-비동기-처리"><a href="#4-비동기-처리" class="headerlink" title="4.비동기 처리"></a>4.비동기 처리</h1><p> 제너레이터를 사용해 비동기 처리를 동기 처리처럼 구현할 수 있다. 다시말해 비동기 처리 함수가 처리 결과를 반환하도록 구현할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params">genObj,username</span>)</span>&#123;</span><br><span class="line">  fetch(<span class="string">`https://api.github.com/users/<span class="subst">$&#123;username&#125;</span>`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span>res.json())</span><br><span class="line">  <span class="comment">//1.제너레이터 객체에 비동기 처리 결과를 전달한다.</span></span><br><span class="line">  .then(<span class="function"><span class="params">user</span>=&gt;</span> genObj.next(user.name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//제너레이터 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> g =(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> user;</span><br><span class="line">  <span class="comment">//2.비동기 처리 함수가 결과를 반환한다.</span></span><br><span class="line">  <span class="comment">//비동기 처리의 숭성가 보장된다.</span></span><br><span class="line">  user = <span class="keyword">yield</span> getUser(g,<span class="string">'kim'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user); <span class="comment">//</span></span><br><span class="line">  </span><br><span class="line">  user =<span class="keyword">yield</span> getUser(g,<span class="string">'lee'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">  </span><br><span class="line">  user = <span class="keyword">yield</span> getUser(g,<span class="string">'park'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 함수 시작</span></span><br><span class="line">g.next();</span><br></pre></td></tr></table></figure>

<p>1.비동기 처리가 완료되면 next메소드를 통해 제너레이터 객체에 비동기 처리 결과를 전달한다.<br>2.제너레이터 객체에 전달된 비동기 처리 결과는 user 변수에 할당한다.<br>제너레이터를 통해 비동기 처리를 동기 처럼 구현 할 수 있으나 코드는 장황해졌다. 따라서 좀더 간편하게 비동기 처리를 구현할 수있는 async/await가 es7에 도입되었다.</p>
<p><strong>async -await 을 통한 비동기 처리</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise을 반환하는 함수정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params">username</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`https://api.github.com/users/<span class="subst">$&#123;username&#125;</span>`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span>res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">user</span> =&gt;</span>user.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">async</span> fucntion getUsersAll()&#123;</span><br><span class="line">  <span class="keyword">let</span> user;</span><br><span class="line">  user = <span class="keyword">await</span> getUsers(<span class="string">'kim'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">  </span><br><span class="line">  user = <span class="keyword">await</span> getUsers(<span class="string">'park'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">  </span><br><span class="line">  user = <span class="keyword">await</span> getUsers(<span class="string">'lee'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;</span><br><span class="line">getUsersAll();</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>제어레이터와 async-await에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>tabindex을 이용한 키보드 접근성</title>
    <url>/2019/09/22/tabindex%EC%9D%84%EC%9D%B4%EC%9A%A9%ED%95%9C%ED%82%A4%EB%B3%B4%EB%93%9C%EC%A0%91%EA%B7%BC%EC%84%B1/</url>
    <content><![CDATA[<p>키보드의 접근성을 고려한 tabindex의 사용.</p>
<p>tabindex는 기본적으로  키보드의 tab키를 눌렀을 때 이동순서를 임의로 조정 할 수 있는 html의 속성 입니다. tabindex의 포커스의 순서를 부여하는 방식을 tabintdex 값에 양의정수를 넣어주면 됩니다. 예를 들어 어떤 html요소에 taindex=”1”을 주었다면 해당 웹 페이지 상에서 tab키를 눌렀을때 tabindex=”1”이 부여하는 요소가 가장 먼저 포커스 됩니다. 그러나 taindex는 신중하게 사용해야 할 필 요가 있습니다. 일반적으로 키보드의  tab키를 눌렀을때 포커스는 html의 마크업 순서를 따르며 링크요소 또는 폼 요소등 tab키로 포커스를 가질 수  있는 요소에 마크업 순서에 따라 자연스럽게 이동합니다. 기본적으로 마크업이 논리적으로 이루어져 있다면 굳이 tabindex을 사용할 이유가 없습니다. 오히려 잘못된 tabindex를 사용함으로써 스크린 리더 사용자가 웹 페이지의 구조를 이해하는데 어려움으로 작용하게 될 수 있습니다.</p>
<p>tabindex는 위에서 설명한것 같이 마크업 순서가 논리적으로 잘 구성되어있다면 대체로 사용할 필요가 없습니다. 임의의 페이지에 처음  접속하는 필수 회원 로그인을 행하는 경우 폼 요소에 tabindex를 부여하여 먼저 회원 로그인을 유도하는등의 이유로 사용할 수는 있습니다. 그러나 이러한 경우에도 페이지 로딩 시autofocus기능을 사용하여 회원 로그인을 유도하는 것이 바람직하다고 생각합니다. 그럼 tabindex는 언제 사용할까요?</p>
<p>웹페이지를 구성하다 보면 페이지 탐색에 논리적 순서를 부여하는 사용자가 자연스럽게 페이지를 탐색할 수 있도록합니다.</p>
<p>tabindex속성은 양의정수값 이외에 0과 -1의 값을 가질 수도 있습니다. 먼저 tabindex=”0”은 tab키를 눌렀을때 포커스를 받을 수없는 요소 이를테면 <span>등의 요소에 포커스를 받게 할 수 있습니다.  반면 -1은 기본적으로 tab키를 눌렀을때 포커스받을 수있는 폼 요소나 링크 요소를 강제로  포커스 받지 못하도록 하는 값입니다. </span></p>
]]></content>
      <tags>
        <tag>tabindex을 이용한 키보드 접근성 및 간단한 내용 정리</tag>
      </tags>
  </entry>
  <entry>
    <title>Set 과 Map</title>
    <url>/2020/05/04/setandmap-md/</url>
    <content><![CDATA[<h1 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h1><p>Set 객체는 중복되지 않는 유일한 값들의 집합(set)이다. Set 객체는 배열과 유사하지만 아래와 같은 점에서 차이가 있다.</p>
<table>
<thead>
<tr>
<th align="left">구분</th>
<th align="center">배열</th>
<th align="center">Set 객체</th>
</tr>
</thead>
<tbody><tr>
<td align="left">동일한 값을 중복하여 포함</td>
<td align="center">○</td>
<td align="center">✕</td>
</tr>
<tr>
<td align="left">요소 순서의 의미</td>
<td align="center">○</td>
<td align="center">✕</td>
</tr>
<tr>
<td align="left">인덱스로 요소에 접근</td>
<td align="center">○</td>
<td align="center">✕</td>
</tr>
</tbody></table>
<p>이러한 Set 객체의 특성은 <a href="https://ko.wikipedia.org/wiki/집합" target="_blank" rel="noopener">수학적 집합</a>의 특성과 일치한다. Set은 수학적 집합을 구현하기 위한 자료 구조이다. Set을 통해 교집합, 합집합, 차집합, 여집합 등을 구현할 수 있다.</p>
<h2 id="1-1-Set-객체의-생성"><a href="#1-1-Set-객체의-생성" class="headerlink" title="1.1. Set 객체의 생성"></a>1.1. Set 객체의 생성</h2><p>Set 객체는 Set 생성자 함수로 생성한다. Set 생성자 함수에 인수를 전달하지 않으면 빈 Set 객체가 생성된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(0) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이때 이터러블의 중복된 값은 Set 객체에 요소로 저장되지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(set1); <span class="comment">// Set(3) &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set2); <span class="comment">// Set(4) &#123;"h", "e", "l", "o"&#125;</span></span><br></pre></td></tr></table></figure>

<p>중복을 허용하지 않는 Set 객체의 특성을 활용하여 배열에서 중복된 요소를 제거할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 배열의 중복 요소 제거</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.filter(<span class="function">(<span class="params">v, i, self</span>) =&gt;</span> self.indexOf(v) === i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniq([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [2, 1, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set을 사용한 배열의 중복 요소 제거</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(array)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniq([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [2, 1, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-요소-개수-확인"><a href="#1-2-요소-개수-확인" class="headerlink" title="1.2. 요소 개수 확인"></a>1.2. 요소 개수 확인</h2><p>Set 객체의 요소 개수를 확인할 때는 Set.prototype.size 프로퍼티를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(3) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.size); // 3</span><br></pre></td></tr></table></figure>

<p>Set.prototype.size 프로퍼티는 setter 함수없이 getter 함수만 존재하는 접근자 프로퍼티이다. 따라서 Set.prototype.size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(Set.prototype, 'size'));</span><br><span class="line">// &#123;<span class="keyword">set</span>: undefined, enumerable: false, configurable: true, <span class="keyword">get</span>: ƒ&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.size = 10; // 무시된다.</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 3</span><br></pre></td></tr></table></figure>

<h2 id="1-3-요소-추가"><a href="#1-3-요소-추가" class="headerlink" title="1.3. 요소 추가"></a>1.3. 요소 추가</h2><p>Set 객체에 요소를 추가할 때는 Set.prototype.add 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(0) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(1) &#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set.prototype.add 메소드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 연속적으로 Set.prototype.add 메소드를 호출할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1).add(2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set 객체에 중복된 요소의 추가는 허용되지 않는다. 단, 이때 에러가 발생하지는 않고 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1).add(2).add(2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>일치 비교 연산자 <code>===</code>을 사용하면 NaN과 NaN을 다르다고 평가한다.(“7.3.1. 동등/일치 비교 연산자” 참고) 하지만 Set 객체는 NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다. 또한 일치 비교 연산자 <code>===</code>와 마찬가지로 +0과 -0도 같다고 평가하여 중복 추가를 허용하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line">console.log(NaN === NaN); // false</span><br><span class="line">console.log(0 === -0); // true</span><br><span class="line"></span><br><span class="line">// NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다.</span><br><span class="line"><span class="keyword">set</span>.add(NaN).add(NaN);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(1) &#123;<span class="literal">NaN</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +0과 -0을 같다고 평가하여 중복 추가를 허용하지 않는다.</span></span><br><span class="line"><span class="keyword">set</span>.add(0).add(-0);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="literal">NaN</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set 객체는 자바스크립트의 모든 값을 요소로 저장할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">  .add(1)</span><br><span class="line">  .add('a')</span><br><span class="line">  .add(true)</span><br><span class="line">  .add(undefined)</span><br><span class="line">  .add(null)</span><br><span class="line">  .add(&#123;&#125;)</span><br><span class="line">  .add([]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>); // Set(7) &#123;<span class="number">1</span>, <span class="string">"a"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, &#123;&#125;, []&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-요소-존재-여부-확인"><a href="#1-4-요소-존재-여부-확인" class="headerlink" title="1.4. 요소 존재 여부 확인"></a>1.4. 요소 존재 여부 확인</h2><p>Set 객체에 특정 요소가 존재하는지 확인하려면 Set.prototype.has 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(2)); // true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(4)); // false</span><br></pre></td></tr></table></figure>

<h2 id="1-5-요소-삭제"><a href="#1-5-요소-삭제" class="headerlink" title="1.5. 요소 삭제"></a>1.5. 요소 삭제</h2><p>Set 객체의 요소를 삭제할 때는 Set.prototype.delete 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 요소 2를 삭제한다.</span><br><span class="line"><span class="keyword">set</span>.delete(2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 요소 1을 삭제한다.</span></span><br><span class="line"><span class="keyword">set</span>.delete(1);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(1) &#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set.prototype.delete 메소드에는 인덱스가 아니라 삭제하려는 요소값을 전달하여야 한다. Set 객체는 순서에 의미가 없다. 다시 말해 배열과 같이 인덱스를 갖지 않는다.</p>
<p>만약 존재하지 않는 Set 객체의 요소를 삭제하려하면 에러없이 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 존재하지 않는 요소 0를 삭제한다.</span><br><span class="line"><span class="keyword">set</span>.delete(0); // 무시된다</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(3) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set.prototype.delete 메소드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다. 따라서 Set.prototype.add 메소드와 같이 연속적으로 호출할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// delete는 불리언 값을 반환한다.</span><br><span class="line"><span class="keyword">set</span>.delete(1).delete(2); // TypeError: <span class="keyword">set</span>.delete(...).delete is not a function</span><br></pre></td></tr></table></figure>

<h2 id="1-6-요소-일괄-삭제"><a href="#1-6-요소-일괄-삭제" class="headerlink" title="1.6. 요소 일괄 삭제"></a>1.6. 요소 일괄 삭제</h2><p>Set 객체의 요소를 일괄 삭제할 때는 Set.prototype.clear 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.clear();</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(0) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-요소-순회"><a href="#1-7-요소-순회" class="headerlink" title="1.7. 요소 순회"></a>1.7. 요소 순회</h2><p>Set 객체의 요소를 순회할 때는 Set.prototype.forEach 메소드를 사용한다. Set.prototype.forEach 메소드는 Array.prototype.forEach 메소드와 유사하게 콜백함수와 forEach 메소드 내부에서 this로 사용될 객체(옵션)를 전달한다. 이때 콜백함수는 아래와 같이 3개의 인수를 전달받는디.</p>
<ul>
<li>첫번재 인수 : 현재 순회중인 요소값</li>
<li>두번재 인수 : 현재 순회중인 요소값</li>
<li>세번재 인수 : 현재 순회중인 Set 객체(this)</li>
</ul>
<p>첫번재 인수와 두번재 인수는 같은 값이다. 이처럼 동작하는 이유는 Array.prototype.forEach 메소드와 인터페이스를 통일하기 위함으로 다른 의미는 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.forEach((v, v2, <span class="keyword">set</span>) =&gt; console.log(v, v2, <span class="keyword">set</span>));</span><br><span class="line">/*</span><br><span class="line">1 1 Set(3) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="built_in">Set</span>(<span class="number">3</span>) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="built_in">Set</span>(<span class="number">3</span>) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<p><strong>Set 객체는 이터러블이다</strong>. 따라서 for…of문으로 순회할 수 있으며 스프레드 문법의 대상이 될 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// Set 객체는 Set.prototype의 Symbol.iterator 메소드를 상속받는 이터러블이다.</span><br><span class="line">console.log(Symbol.iterator in <span class="keyword">set</span>); // true</span><br><span class="line"></span><br><span class="line">// 이터러블인 Set 객체는 for...of 문으로 순회할 수 있다.</span><br><span class="line">for (const value of <span class="keyword">set</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이터러블인 Set 객체는 스프레드 문법의 대상이 될 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log([...set]); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>Set 객체는 요소의 순서에 의미를 갖지 않지만 Set 객체를 순회하는 순서는 요소가 추가된 순서를 따른다. 이는 ECMAScript 사양에 규정되어 있지는 않지만 다른 이터러블의 순회와 호환성을 유지하기 위함이다.</p>
<h2 id="1-8-집합-연산"><a href="#1-8-집합-연산" class="headerlink" title="1.8. 집합 연산"></a>1.8. 집합 연산</h2><p>Set은 수학적 집합을 구현하기 위한 자료 구조이다. Set을 통해 교집합, 합집합, 차집합 등을 구현할 수 있다. 이들 프로토타입 메소드를 구현하면 아래와 같다.</p>
<h3 id="1-8-1-교집합"><a href="#1-8-1-교집합" class="headerlink" title="1.8.1. 교집합"></a>1.8.1. 교집합</h3><p>교집합(A∩B)은 집합 A와 집합 B의 공통 요소로 구성된다</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.intersection = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="comment">// 2개의 set의 요소가 공통되는 요소이면 교집합의 대상이다.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(value)) result.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA와 setB의 교집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.intersection(setB)); <span class="comment">// Set(2) &#123;2, 4&#125;</span></span><br><span class="line"><span class="comment">// setB와 setA의 교집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.intersection(setA)); <span class="comment">// Set(2) &#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.intersection = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...this].filter(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">set</span>.has(v)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const setA = new Set([1, 2, 3, 4]);</span><br><span class="line">const setB = new Set([2, 4]);</span><br><span class="line"></span><br><span class="line">// setA와 setB의 교집합</span><br><span class="line">console.log(setA.intersection(setB)); // Set(2) &#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// setB와 setA의 교집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.intersection(setA)); <span class="comment">// Set(2) &#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-2-합집합"><a href="#1-8-2-합집합" class="headerlink" title="1.8.2. 합집합"></a>1.8.2. 합집합</h3><p>합집합(A∪B)은 집합 A와 집합 B의 중복없는 모든 요소로 구성된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.union = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this(Set 객체)를 복사</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="comment">// 합집합은 2개의 Set 객체의 모든 요소로 구성된 집합이다. 중복된 요소는 포함되지 않는다.</span></span><br><span class="line">    result.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA와 setB의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.union(setB)); <span class="comment">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// setB와 setA의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.union(setA)); <span class="comment">// Set(4) &#123;2, 4, 1, 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.union = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...this, ...set]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA와 setB의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.union(setB)); <span class="comment">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// setB와 setA의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.union(setA)); <span class="comment">// Set(4) &#123;2, 4, 1, 3&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-3-차집합"><a href="#1-8-3-차집합" class="headerlink" title="1.8.3. 차집합"></a>1.8.3. 차집합</h3><p>차집합(A-B)은 집합 A에는 존재하지만 집합 B에는 존재하지 않는 요소들의 집합이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.difference = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this(Set 객체)를 복사</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="comment">// 차집합은 어느 한쪽 집합에는 존재하지만 다른 한쪽 집합에는 존재하지 않는 요소로 구성된 집합이다.</span></span><br><span class="line">    result.delete(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA에 대한 setB의 차집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.difference(setB)); <span class="comment">// Set(2) &#123;1, 3&#125;</span></span><br><span class="line"><span class="comment">// setB에 대한 setA의 차집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.difference(setA)); <span class="comment">// Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.difference = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...this].filter(<span class="function"><span class="params">v</span> =&gt;</span> !<span class="keyword">set</span>.has(v)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const setA = new Set([1, 2, 3, 4]);</span><br><span class="line">const setB = new Set([2, 4]);</span><br><span class="line"></span><br><span class="line">// setA에 대한 setB의 차집합</span><br><span class="line">console.log(setA.difference(setB)); // Set(2) &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// setB에 대한 setA의 차집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.difference(setA)); <span class="comment">// Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-4-부분-집합과-상위-집합"><a href="#1-8-4-부분-집합과-상위-집합" class="headerlink" title="1.8.4. 부분 집합과 상위 집합"></a>1.8.4. 부분 집합과 상위 집합</h3><p>집합 A가 집합 B에 포함되는 경우(A⊆B), 집합 A는 집합 B의 부분 집합이며 집합 B는 집합 A의 상위 집합이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this가 subset의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.isSuperset = <span class="function"><span class="keyword">function</span> (<span class="params">subset</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> subset) &#123;</span><br><span class="line">    <span class="comment">// superset의 모든 요소가 subset의 모든 요소를 포함하는지 확인</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA가 setB의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.isSuperset(setB)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// setB가 setA의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.isSuperset(setA)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this가 subset의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.isSuperset = <span class="function"><span class="keyword">function</span> (<span class="params">subset</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> supersetArr = [...this];</span><br><span class="line">  <span class="keyword">return</span> [...subset].every(<span class="function"><span class="params">v</span> =&gt;</span> supersetArr.includes(v));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA가 setB의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.isSuperset(setB)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// setB가 setA의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.isSuperset(setA)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h1><p>Map 객체는 키와 쌍으로 이루어진 컬렉션이다.   Map객체는 객체와 유사하지만 다음과같은 차이점이 있다.</p>
<table>
<thead>
<tr>
<th align="center">구분</th>
<th align="center">객체</th>
<th align="center">Map객체</th>
</tr>
</thead>
<tbody><tr>
<td align="center">키로 사용할수있는 값</td>
<td align="center">문자열 또는 심볼 값</td>
<td align="center">객체를 포함하는 모든 값</td>
</tr>
<tr>
<td align="center">이터러블</td>
<td align="center">X</td>
<td align="center">O</td>
</tr>
<tr>
<td align="center">크기확인</td>
<td align="center">Object.keys(obj).length</td>
<td align="center">map.size</td>
</tr>
</tbody></table>
<h3 id="2-1-Map-객체의-생성"><a href="#2-1-Map-객체의-생성" class="headerlink" title="2.1 Map 객체의 생성"></a>2.1 Map 객체의 생성</h3><p>Map 객체는 Map 생성자 함수로 생성한다. Map 생성자 함수에 인수를 전달하지않으면 빈 Map객체가 생성된다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>Map 생성자 함수는 이터러블을 인수로 전달 받아 Map객체를 생성한다. 이때 인수로 전달 되는 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성이 되어야한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>,<span class="string">'value1'</span>],[<span class="string">'key1'</span>,<span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map1) <span class="comment">//Map(2) &#123;'lkey1=&gt;'value'm'key2'=&gt;'value2'&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// TypeError: Iterator value 1 is not an entry object</span></span><br></pre></td></tr></table></figure>

<p>중복된 키는 Map 객체의 요소로 저장되지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>,<span class="string">'value2'</span>],[<span class="string">'key1'</span>,<span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(1) &#123;"key1" =&gt; "value1"&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-요소의-개수확인"><a href="#2-2-요소의-개수확인" class="headerlink" title="2.2 요소의 개수확인"></a>2.2 요소의 개수확인</h2><p> Map 객체의 요소의 개수 확인 할때에는 Map.prototype.size 프로퍼티를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>,<span class="string">'value1'</span>],[<span class="string">'key2'</span>,<span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(2) &#123;"key1" =&gt; "value1", "key2" =&gt; "value2"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>Map.prototype.size 프로퍼티는 setter함수 없이 getter함수만 존재하는 접그자 프로퍼티 이다. 따라서 Map.prototype.size 프로퍼티에 숫자를 할당하여 Map 객체의 요소개수를 변경 할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>, <span class="string">'value1'</span>], [<span class="string">'key2'</span>, <span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Map</span>.prototype,<span class="string">'size'</span>));</span><br><span class="line"><span class="comment">//&#123;set:undefined, enumberable:false,configurable:true,get:function&#125;</span></span><br><span class="line"></span><br><span class="line">map.size =<span class="number">10</span>; <span class="comment">//무시된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-요소-추가"><a href="#2-3-요소-추가" class="headerlink" title="2.3 요소 추가"></a>2.3 요소 추가</h2><p>Map 객체의 요소를 추가할 때는 Map.prototype.set메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">//Map(0) &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'key1'</span>,<span class="string">'value1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">//Map(1) &#123;'key1'=&gt;'value1'&#125;;</span></span><br></pre></td></tr></table></figure>

<p>Map.prototype.set메소드는 새로운 요소가 추가된 Map객체를 반환한다. 따라서 연속적으로 Map.prototype.set 메소드를 호출할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'key1'</span>,<span class="string">'value1'</span>)</span><br><span class="line">.set(<span class="string">'key2'</span>,<span class="string">'value2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(2) &#123;'key1'=&gt;'value1','key2'=&gt;'value2'&#125;;</span></span><br></pre></td></tr></table></figure>

<p>Map객체에 중복된 키를 갖는 요소의 추가는 허용되지않는다. 단 이때 에러가 발생하지는 않고 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map</span><br><span class="line">  .set(<span class="string">'key1'</span>, <span class="string">'value1'</span>)</span><br><span class="line">  .set(<span class="string">'key1'</span>, <span class="string">'value2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(1) &#123;"key1" =&gt; "value1"&#125;</span></span><br></pre></td></tr></table></figure>

<p>객체는 문자열 또는 심볼 값만을 키로 사용할수 있지만 Map객체의 키 타입에는 제한이 없다. 따라서 객체는 포함한 모든 값을 키로 사용할 수 있다. 이는 Map 객체와 일반 객체의 가장 두드러지는 차이이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> lee  = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim = &#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line">map.set(lee,<span class="string">'developer'</span>)</span><br><span class="line">.set(kim,<span class="string">'developer'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(2) &#123; &#123;name:'lee'&#125;=&gt; 'developer',&#123;name:'kim'&#125;=&gt;'developer' &#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-요소-취득"><a href="#2-4-요소-취득" class="headerlink" title="2.4 요소 취득"></a>2.4 요소 취득</h2><p>Map객체의 요소를 취득 할때 는 Map.prototype.get메소드를 사용한다. Map객체에 해당하는 ㅣ를 갖는 요소가 존재하지 않으면 undefined을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line">map.set(lee,<span class="string">'deveoper'</span>).set(kim,<span class="string">'developer'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(lee)); <span class="comment">///developer;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'key'</span>)) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-요소-존재-여부-확인"><a href="#2-5-요소-존재-여부-확인" class="headerlink" title="2.5 요소 존재 여부 확인"></a>2.5 요소 존재 여부 확인</h2><p> Map객체에 특정 요소가 존재하는지 확인 하려면  Map.prototype.has메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(lee)) <span class="comment">//true;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'key'</span>)) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-요소의-삭제"><a href="#2-6-요소의-삭제" class="headerlink" title="2.6 요소의 삭제"></a>2.6 요소의 삭제</h2><p>Map객체의 요소를 삭제할때에는 Map.prototype.delete메소드를 사용한다. 만약 존재하지 않는 Map객체의 요소를 삭제 하려면 에러없이 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line">map.delete(kim);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(1) &#123;&#123;name:'lee'&#125;=&gt;'developer'&#125;;</span></span><br></pre></td></tr></table></figure>

<p>Map.prototype.delete 메소드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다. 따라서 Map.prototype.set 메소드와 같이 연속적으로 호출 할수없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim=&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]);</span><br><span class="line"></span><br><span class="line">map.delete(lee).delete(kim) <span class="comment">//TypeError: map.delete(...).delete is not a function</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7-요소의-일괄-삭제"><a href="#2-7-요소의-일괄-삭제" class="headerlink" title="2.7 요소의 일괄 삭제"></a>2.7 요소의 일괄 삭제</h2><p>Map 객체의 요소를 일괄 삭제 할때는 Map.prototype.clear 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim=&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line">map.clear();</span><br><span class="line">consoleg.log(map) <span class="comment">//Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-요소의-순회"><a href="#2-8-요소의-순회" class="headerlink" title="2.8 요소의 순회"></a>2.8 요소의 순회</h2><p>Map 객체의 요서를 순회할 때는 Map.prototype.forEach메소드를 사용한다. Map.prototype.forEach메소드는 Array.prototype.forEach메소드와 유사하게 콜백함수와 forEach 메소드 내부에서 this로 사용 될 객체(옵션)를 전달한다. 이때 콜백 함수는 다음과 다팅 3개의 인수를 받는다.</p>
<ul>
<li>첫번째 인수 : 현재 순회중인 요소 값</li>
<li>두번째 인수 : 현재 순회중인 요소 키</li>
<li>세번째 인수 : 현재 순회중인 Map객체(this)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function">(<span class="params">v,k,map</span>)=&gt;</span>consoel.log(v,k,map));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">developer &#123;name: "Lee"&#125; Map(2) &#123;</span></span><br><span class="line"><span class="comment">  &#123;name: "Lee"&#125; =&gt; "developer",</span></span><br><span class="line"><span class="comment">  &#123;name: "Kim"&#125; =&gt; "designer"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">designer &#123;name: "Kim"&#125; Map(2) &#123;</span></span><br><span class="line"><span class="comment">  &#123;name: "Lee"&#125; =&gt; "developer",</span></span><br><span class="line"><span class="comment">  &#123;name: "Kim"&#125; =&gt; "designer"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Map객체는 이터러블이다 .따라서 for …of문으로  순회할수있으며 스프레드 문법의 대상이 될 수 도있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map rorcpsms Map.prototype의 Symbol.iterator 메소드를 상속받는 이터러블 이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> map) <span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//이터러블인 Map객체는 for...of문으로 순회할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> entry <span class="keyword">of</span> map)&#125;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry) <span class="comment">//[&#123;name:'lee'&#125;=&gt;'developer'][&#123;name:'kim'&#125;=&gt;'designer']</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//이터러블인  Map객체는 스프레드 문법의 대상이 될수있다.</span></span><br><span class="line"><span class="built_in">console</span>.log([...map]);</span><br><span class="line"><span class="comment">//[[&#123;name:'lee'&#125;,'developer'],[&#123;name:'kim'&#125;,'designer']];</span></span><br></pre></td></tr></table></figure>

<p>Map은 이터러블이면서 동시에 이터레이터인 객체를 반환하는 메소드를 제공한다.</p>
<ul>
<li>Map.prototype.keys 메소드는 Map객체에서 요소 키를 값으로 갖는 이터레이터를 반환한다.</li>
<li>Map.prototype.values메소드는 Map객체에서 요소값을 값으로 갖는 이터레이터를 반환한다.</li>
<li>Map.prototype.entries메소드는  Map객체에서 요소 키와 요소 값을 값으로 갖는 이터레이터를 반환한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">of</span> map.keys())&#123;</span><br><span class="line">  consoel.log(key) <span class="comment">//&#123;name:'lee'&#125;&#123;name:'kim'&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> value <span class="keyword">of</span> map.values())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//developer designer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> entry <span class="keyword">of</span> map.entries())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry) <span class="comment">//[&#123;name:'lee'&#125;,'developer'] [&#123;name:'kim'&#125;,''designer];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map객체는 요소의 순서에 의미를 갖지 않지만 Map객체를 순회하는 순서는 요소가 추가된 순서를 따른다.<br>이는 ECMAScript 사양에 규정되어 있지는 않지만 다른 이터러블의 순회와 호환성을 유지하기 위함이다.</p>
]]></content>
      <tags>
        <tag>Set  과  Map에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>프론트엔드 개발공부를 한 한달의 감상</title>
    <url>/2019/09/29/%EA%B0%9C%EB%B0%9C%EA%B3%B5%EB%B6%80%EA%B0%90%EC%83%81/</url>
    <content><![CDATA[<p>처음에 학원에 들어오게 되었을때,학원의 광고에 이끌려 이제는 쉽게 개발자로서 나의 커리어를 시작할 도약이 되겠구나 생각했다.하지만 처음에 수업을 듣고 난 후, 나의 생각은 정말 오만하고 생각이 없었다는것을 느꼈다.이세상에 쉬운것은 절대 없었다. 내가 알고있던것은 정말 일부에 지나지 않았다. 처음 수업을 들은 후 나는 굉장히 충격과 좌절을 느꼈다. 수업을 따라가는 것 조차 너무나도 버거웠다. 굉장히 불안하고 힘들었다. 내가 그나마 할 수있는 것은 학원 매니져님을 붙잡고 하나하나 질문하는것 뿐이었다. 그래서 첫 수업이 끝난 후 나는 학원 문을 닫을 때 까지 학원을 떠나지 못했다. 집에 가는 중에도 계속생각했다.내가 잘 할 수 있을까?하는 생각을 끊임없이했다.<br>처음에는 어떻게 공부해야 할 지도 너무 막막했다.이게 맞는지 저게 맞는지..몇일 동안을 수업이 끝나고 집으로 돌아가는 내내 기분이 안좋았다. 심지어 학원을 환불받아야하나 하는 생각도 했다.하지만 나에게는 포기했을때 선택할 수 있는 다른 선택지가 없다고 느꼈다. 나에게 프론트엔드 개발자의 길은 너무도 멀리있어서 보이지도 않는 하나의 점처럼 느껴졌다.<br>하지만 조금씩 수업을 듣고 공부를 하면서 조금씩 나아진다는 것을 느꼈다.주말에도 공부를 하고 하다보니까 수업을 듣는것도 이해하는 것도 조금은 수월해 졌다.<br>내가 항상 걱정했던것은 다른사람들은 잘하는데 나만 제일 못하는 것같고 도퇴되면 어쩌지 하는 두려움이었다. 그러다 문득 느낀것이 다른사람들과 나는 출발점이 달랐던 것이었다.컴퓨터 관련 전공자,현업에서 뛰던 경험이 있는 사람들, 비 전공에 혼자서만 공부를 했던 나와는 출발점이 달랐다.그렇기에 다른 사람과 비교하면 차이가 나는것은 당연한 것 이였다.<br>어느날 인터넷에서 개발자와 관련된 글을 읽다가 한가지 글이 굉장히 인상에 남았다.’개발자의 길은 남들과 비교하는 순간 끝이다’라는 글이었다.<br>남들과 비교를 하면서 스스로의 성취에 무뎠었다. 앞으로  나는 나에게만 집중해야겠다 생각했다. 그리고 다른 출발점을 따라 잡기 위해서 더 많은 노력을 할 것이다. 비록 지금은 더디고 느리지만, 나보다 앞선 사람들을 훨씬 추월하고 싶다.그리고 작은 성취를 느끼며 조금씩 조금씩 나아갈 것이다.작은 성취 하나하나가 나를 앞으로 나가게 하는 원동력이 된다. 처음 느꼈던 좌절을 발판삼아 앞으로 나아갈 것이다.앞으로 좌절 보다는 도전하고 극복하겠다.<br>지켜봐라. </p>
]]></content>
      <tags>
        <tag>HTML,CSS 수업을 듣고 난 한 달</tag>
      </tags>
  </entry>
  <entry>
    <title>메모리,참조,키워드,변수,선언,할당,재할당,호이스팅</title>
    <url>/2019/10/04/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B0%B8%EC%A1%B0%ED%82%A4%EC%9B%8C%EB%93%9C/</url>
    <content><![CDATA[<p><strong>변수</strong>-값을 다룬다.(데이터를 다룬다.)</p>
<p><strong>참조</strong>-변수에 저장된 값을 읽어들이는것을 참조라한다.</p>
<p>함수/객체 (변수를 모르면 못함)</p>
<p>10(리터럴)+(연산자)20(리터럴):좌변과 우변의 값 +연산자를 메모리에 저장한다.</p>
<p><strong>메모리셀</strong>:1byte짜리 방이 존재한다.1byte단위로 저장<br><strong>메모리주소</strong>:각각 셀마다 주소가있다.<br>인간에게 유의미한 데이터는 최소 1byte이상</p>
<p>숫자를 기억하여 메모리에 저장한다. 연산을 cpu에서 한다. cpu에서 연산 한 후 이를 메모리에 저장을 한다.<br>메모리에 저장되는 모든 값은 2진수이다.</p>
<p><strong>1+2 안 쓴다표현식(unuse-expression)? 쓴다는 의미?</strong> 메모리 어딘가에 저장함.(10과20) 30이라는 값을 더한이유는 이 값을 ‘사용하겠다’는 의미이다.곧 재사용을 할 수없다는 것이다.  값이 메모리에 저장이 됐지만 주소를 알아야 접근할 수있는데,<br>위치 안알려줌(잘못 저장하면 문제가 생김)/알려준다고해도 문제가 됨.(같은 곳에 저장될 보장이없다.임의의 공간에 저장이 되기때문이다.) 저장된 데이터를 재사용하기 위해서 프로그래밍 언어는 변수를 제공한다.</p>
<p>따라서 변수는 데이터가 저장되는 곳의 메모리 주소를 기억한다.(반드시 변수에는 하나의 값만 저장할 수 있다.)</p>
<p><strong>변수란</strong> 하나의 값을 저장할 수 있는 메모리공간에 붙인 이름 또는 메모리공간 자체를 말한다.</p>
<p><strong>여기서 값이란(하나의값)?</strong> 메모리에 들어가는 대상.컴퓨터가 인식할 수있는 값의 종류. 7가지 (숫자 문자열 불리언 undefined null symbol 객체-값의 유형)</p>
<p>자료구조-데이터 구조(여러 개의 값이 들어있는,연관된 데이터의 그룹) ex)객체,배열</p>
<hr>
<p>자바스크립트 엔진은 변수이름 result (식별자-고유한 이름,일종의 카드 키)을 안다.<br>키워드-명령어(뒤에 값을 준다.) 자바스크립트에게 내리는 명령<br>변수에 저장된 값을 읽어들이는 것을 참조라한다.</p>
<p><strong>변수의 이름</strong>-&gt;할당값/값을 의미해야함<br>변수의 이름은 저장된 값의 의미를 이해 할 수있는 이름은 가독성을 높여주는 부수효과 .변수이름을 신중하게 정해야한다.</p>
<p>var result=10+20; 각 값10,20 메모리에 저장하고 30이라는 결과를 가져옴(평가)<br>10,20이라는 값은 필요없는 값-가비지컬렉터에의해 쓰지않는 값이기 때문에 다른값이 들어갈수있게 해준다. 가비지 ㅌ컬렉터는 값을 지우는 것이아니다.</p>
<p><strong>var(키워드) result(변수이름/식별자)=10+20(표현식);</strong><br><strong>표현식을 변수에 할당(assign,저장,대입)</strong></p>
<p>code-runner(dom api가 없으면 사용해도 괜찮다.)<br>quokka(command shift p);</p>
<hr>
<p><strong>식별자(변수이름)</strong> -메모리에 있는 값을 구별해서 끄집어낼 수  있는 값./식별자는 어떤 값을 구별하여 식별해낼 수있는 고유한 이름</p>
<p><strong>함수는값이다</strong>.함수덩어리 메모리에 그대로 들어감ex)foo();</p>
<p>클래스-객체를 만들어냄 ex)class Bar(){} new Bar();<br>식별자는 메모리 주소를 알고 있다.<br>변수,함수,클래스 네이밍있다.</p>
<p><strong>변수선언</strong>-변수를 생성한다.<br>변수란 컴퓨터에서 메모리와 관련있다.</p>
<p><strong>변수선언</strong>-변수생성한다(변수이음,메모리공간-매핑된 상황) 자바스크립트 엔진에 변수이름 등록 ,값 저장을 위한 메모리 공간 확보위함</p>
<p>변수선언 var result 변수이름을 자바스크립크 엔진에 등록해 알린다.</p>
<p><strong>변수의 이름은 어디에 저장이 되는 가?</strong>  변수이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록이된다. 또한 자바 스크립트 엔진은 실행 컨텍스트를 통해서 식별자와 스코프를 관리한다. 변수이름과  변수값은 실행 컨텍스트내의 key와  value형식으로 등록되어 관리된다.<br>변수 선언 키워드 사용(var,let,const)</p>
<p>var 키워드를 사용한 변수선언은 선언단계와 초기화 단계가 동시에 일어난다.</p>
<p><strong>변수선언(메모리 공간을 확보하기 위해)=할당1.논리적 선이된후2.할당</strong></p>
<p>기본적 변수는 선언을 하고 할당해야함.</p>
<p>변수를 선언만하고,할당을 하지 않으면 -undefined값이나옴. 값이 정의되지않는다. 변수는 암묵적으로 undefined값을 가진다 .자바스크립트엔진에 부여. 알아서 할당한다 .undefined라는 값으로-우리가 일부로 할당하는 경우는 없다. 자바스크립트엔진이 쓰기위한 값,변수가 선언만되고 할당되지 않았다는것을 알려주기 위함이 크다.-인터프리터 언어는 런타임에 에러가 발생해서 볼 수있기 때문에 최대한 에러가 나지 않게한다.</p>
<p> 할당하지 않고 변수선언마저하지 않음 에러를 일으킨다.</p>
<hr>
<p><strong>변수 호이스팅(중요함)</strong>-변수선언이 위로 끌어올려진것처럼 동작한다.</p>
<p>console.log(score);//원래 에러가 나야함.<br>var score;//변수선언</p>
<p><strong>모든(식별자와 관련있다.)선언문은 먼저 실행한다.</strong><br>인터프리터가 코드를 한줄한줄 해석하기 전에 쭉 일고 선언문만을 골라서 먼저 실행한다. 이는 코드를 실행하기 전에 평가를 한다고 말한다.-이후 실행될 수있는 환경을 만들어냄.<br>변수의 선언이 코드가 순차적으로 실행되는 런타임 이전에 먼저 실행된다는 것에 주목하자.</p>
<p>위 끌어올려서 실행된 실행문은 또 실행되지 않는다.<br>(let,const호이스팅이 되지만 안되는것 처럼 작동한다.이후에 수업할 내용이다.)<br>위의 내용은 변수 호이스팅의 내용이고,함수 호이스팅이 따로 존재한다.<br>**이런식으로 코드를 짜지 말아야하는 예시가 될 수있다.-&gt;최소한 선언을 하고 참조해라.</p>
<p><strong>왜 호이스팅이 발생하는가?-&gt;</strong>선언문은 실행될때 가장먼저 골라져서 실행되기대문에 발생한다.<br>console.log(result);// undefined을 출력한다.<br>var result=100;(var result;<br>                                 result=100;)으로 해석될수있다.</p>
<p>선언문과 할당 ,선언문이전에 참조를 하지 말아라.</p>
<p>console.log(result);//undefined.<br>var result=100;<br>console.log(result)//100출력</p>
<hr>
<p><strong><em>값의 할당-</em></strong>변수 선언은 소스 코드가 순차적으로 실행되기 이전, 즉 런타임 이전에 먼저 실행되지만 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**</p>
<p><strong>값의 재할당-</strong>이미 할당되어있는 면수에 새로운 값을 또ㄱ디시 할당하는 것을 말한다.<br>var 키워드로 선언한 변수는 값을 재할당할 수 있따.</p>
<p>원시값(6가지 타입:undefined,null,불리언,문자열,숫자,symbol,)은 값을 변경할 수 없다.리뮤터블(한번 값을 설정하면 바꿀수없다.)</p>
<p><strong>언매니지드/ 매니지드</strong><br><strong>가비지 컬렉터</strong>는 지우는 역할이 아니라 값이 할당될때 다른 값이 들어가지 못하도록 블락한것을 풀어주어 다른 값이 들어갈 수 있도록하는 역할을 한다고 생각하면 쉽다.</p>
<p><strong>힌트는 :변수를 하나를 더만들어서 사용하라.</strong></p>
<p>var x=1;<br>var y=2;</p>
<hr>
<p>var z=y;</p>
<p>x=z;<br>y=x;<br>console.log(x,y);// 2,1로 출력되도록 값을 바꾸어라.</p>
]]></content>
      <tags>
        <tag>메모리,참조,키워드,변수,선언,할당,재할당,호이스팅,</tag>
      </tags>
  </entry>
  <entry>
    <title>반응형웹 수업내용 간단한 정리</title>
    <url>/2019/09/22/%EB%B0%98%EC%9D%91%ED%98%95%EC%9B%B9%EC%88%98%EC%97%85%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/</url>
    <content><![CDATA[<p>반응형 웹 디자인(responsive Web design) 모바일디바이스와 타블렛 같은 다양한 디바이스들이 등장하게 되었고, 그에 환경에 따른 별도의 대응이 필요하게 되었다.</p>
<p> RWD vs AWD(적응형):view port에 따라 증가하다가 특정 크기에서 고정형(데스크탑 +모바일)<br>반응형 웹의 100(width를  특정한 너비를 설정하지 않는다.)</p>
<p>컨텐츠는 물과 같다.용기는 다르더라도 내용물은 물은 그대로다.</p>
<p>미디어 쿼리 배치중요하다. 추천하는 방법은 모바일 환경에 대한 선형 디자인을 처음으로 고려하고 brekpoint를 추가하면서 너비나 상황 변하였을때의 값을 설정해주는 것이 좋은 방법이 된다.(모바일에서 데스크탑으로)<br> mobile first:컨텐츠 전략 선택 선형적인 기본작업을 모바일에서 만들고 그것을 데스크탑 컨텐츠로 순서로 최적화를 한다.</p>
<p>max-width:너비를 자신의 이상으로 안하겠다.너비가 줄수도 있지만 증가하진않는다.<br>height:auto:높이를 너비가 변호하는 것에 따에 자동으로 맞춘다.</p>
<p><picture>&lt;source min-width:40em srcset:big-jpg 1x:big -jpg 2x&gt;최소의 너비에서 다음으로 srcset의 값을 보여주겠다. 배율이 1일때와 2배율일때 각각 상황에 맞게 사용하겠다.<picture>은 재사용과 수정에 용이하다.<br></picture><br></picture></p>
<p>10vh(view height)화면 view port의 1/10을 높이로 정하겠다. 앞에서 이야기했듯이 모바일 first 선형화</p>
<p>display:flex 의 order속성은 기본 값이 :0 기본 값보다 작으면 -1이면 기본 보다 먼저 값은 값이 있으면 순서대로 정의 한다.</p>
<p>flex-flow:row wrap은 축은 바꾸지 않고 wrap 을 사용함으로서 줄을 바꿈.</p>
<p>breakpoint는 쉽게 생각하면 추가될때 바뀌는 구간이라고 생각하면 된다.<br>@media screen and (min-width:801px)::801이 되면서 내용을 덮어씌우겠다.</p>
]]></content>
      <tags>
        <tag>반응형 웹 수업내용</tag>
      </tags>
  </entry>
  <entry>
    <title>데이터 타입 연산자</title>
    <url>/2019/10/08/%EB%B3%80%EC%88%98%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85%20%EC%97%B0%EC%82%B0%EC%9E%90/</url>
    <content><![CDATA[<p>var person,$elem,_name,first_name,val1;</p>
<p>,쉼표는 연산자다.<br>자바스크립트는 대소문자를 구분한다.</p>
<p>var FRISTNAME:식별자의 이름을 대문자로 쓰면 개발자들사이에서 ‘상수’라는 것을 암묵적으로 약속한다.</p>
<p>변수는 값의 이름을 나타낼수 있는 의미가 중요하다.<br>주석은 가급적 많이 사용하지 않는것이 좋다-오히려 주석이 이해를 방해/그만큼 네이밍이 중요하다.</p>
<p>카멜케이스- var fristName변수,함수 기본적으로 사용<br>파스칼케이스-var FirstName생성자함수,클래스<br>스테이크케이스-var first_name;<br>헝가리언 케이스-var strFirstName;<br>var $elem=$(‘.myClass’);</p>
<p>var a=10+20; 10.+,20은 각각이 토큰이다.</p>
<p>+는 산술 연산자,<br>식(표현식:10+20)=&gt; 값(value)으로 30;<br>식이 값이 되려면 자바스크립트 엔진이 식을 평가(evaluation)한다.<br>var a=10+20;(전체를 문:statement)</p>
<hr>

<p><strong>데이터 타입</strong>(7가지-숫자,문자열,불리언,undefined,null,symbol,객체 혹은 참조)</p>
<p>-데이터 타입이 필요하다-&gt;할당할때 변수에 확보해야하는 메모리 공간을 확보할 수있다.</p>
<p>1.타입을 알아야-메모리 공간을 확보한다.<br>2.몇 바이트 공간이 필요한가<br>3.가져온 값을 어떻게 해석해야하는가?</p>
<p>숫자값 저장(8byte 사용) 타입마다 확보해야하는 메모리 공간 제각각이다. 타입을 모르면 확보해야할 메모리를 모른다.</p>
<p>score을 선두에 접근한다. 8byte만큼 가져옴-&gt;가져온 데이터 2진수(문자/숫자/불리언 등으로 어떻게 알것이냐?)<br>-&gt;따라서 식별자는 타입을 알아야한다.</p>
<hr>

<p><strong>값</strong>:현재 메모리에 들어있는 데이터<br><strong>값의 특징:</strong>타입을 가지고 있다(7가지 타입중하나)<br><strong>값이란?</strong> 더이산 평가 할 수 없는 하나의 표현식이다.<br>ex)30-리터럴/리터럴 표기법(10진수)/값을 만들어낸느 가장 시초<br><strong>평가란?</strong>식을 하나의 값으로 계산한다.ex)10+20평가의 대상 -평가의 결과물은 <strong>값</strong>이다.<br>표현식은 평가가 되어 값이 되는 것이다.<br>10(피연산자,리터럴)+(산술 연산자)20(피연산자,리터럴)</p>
<p>값을 표기하는 방법 크게 두가지다</p>
<p>1.<strong>리터럴</strong>(ex)30.<br><strong>2.표현식</strong>(ex)10+20-&gt;하나 이상의 리터럴,하나 이상의 표현식 연산자로 만들어진 ‘문(statement)’이다.</p>
<p>10+20:표현식-&gt; 자바스크립트엔진에서 평가-&gt;값 30을 만듦/리터럴 표기법를 평가해야 값을 만들어낸다.(평가 전에는 값이 만들어지지않는다.)</p>
<p>숫자 리터럴/문자열 리터럴/불리언 리터럴/null리터럴/undefined리터럴/객체 리터럴/배열 리터럴/함수 리터럴/정규표현식 리터럴</p>
<p>리터럴은 사람이 이해하기 편하게 하기 위해서 만들었다.</p>
<p><strong>데이터 타입</strong><br><strong>원시타입</strong>(숫자/문자열/불리언/undefined/null/symbol)</p>
<p><strong>객체 타입</strong>(object/reference type):객체,함수,배열</p>
<p>정수/실수-모든숫자를 실수 타입으로 처리를 한다.</p>
<ul>
<li>Infinity : 양의 무한대</li>
<li>-Infinity : 음의 무한대</li>
<li>NaN : 산술 연산 불가(not-a-number)</li>
</ul>
<p>표현식은 평가 되어져서 하나의 값을 만든다.<br>식별자는 결국 표현식이다.<br>(ex)var a=10;var a=b;b=a+10;표현식은 하나의 값으로 표현할 수있다.</p>
<p><strong>문자열</strong><br>작은 따옴표,큰 따옴표-개행하기 위해서는 이스케이프 시퀀스를 사용한다.(개행:\n);</p>
<p>백틱문자는 엔터나 띄어쓰기 같은 것,’’,””을 모두 동시에 사용할 수 있다는 장점이 있다.</p>
<p>console.log(‘My name is’+frist+’’+second+’!’);</p>
<p>+은 문자열 연산자-좌우항에 하나라도 문자열이 있다면 + 연산자로 결합하여 문자열이 된다.<br><code>${문자열}</code> ex)console.log(<code>1+1=${1+1}</code>);</p>
<p>‘2’는 문자열이다. 이는 암묵적인 타입변환이 일어났단는 것을 알수있다. 이러한 암묵적인 변환은 에러의 온상이 된다.</p>
<p><strong>불리언 타입</strong><br>논리적인 참,거짓을 나타내는 true 와 false를 가진다.</p>
<p><strong>undefined타입</strong><br>undefined타입 값은 undefined가 유일 하다.선언 이후에 명시적으로 값을 할당하지 은 변수는 자바스크립트 엔진의 암묵적 초기화에 의해서 undefined값을 가진다. 따라서 선언은 되었지만 아직 값을 할당하지 낳은 변수에 접근하면 undefined가 반환된다.</p>
<p><strong>선언</strong>:변수는 선언이라고 부를 것이다.<br><strong>정의</strong> :무언가를 할당해서 그 변수에 어떤 값을 가지고있는지 명확히 나타냄<br>함수,클래스는 ‘정의’로 부르겠다. 선언과 동시에 객체가 생성됨</p>
<p><strong>null타입</strong></p>
<p>변수에는 값이 없다는 것을 명확히 나타냄.<br>ex)var foo=’lee’; foo=null(가비지 컬렉터가 로 ‘lee ‘를 해제해 주세요)</p>
<p><strong>동적 타이핑(타입이 동적이다.)</strong><br>동적타입언어(자바스크립트)-변수의 타입이 없다(값에 타입이 있다.)-편하지만 신뢰성이 떨어진다(변수의 타입이 암묵적으로 변환이 된다.).</p>
<p>값에 의해서 변수의 타입이 결정이 된다.변수는 선언이 아닌 할당에 의해 타입이 결정된다. 재할당에 의해 변수의 타입은 언제든지 동적으로 바뀔 수 있다.-&gt;하나의 변수에 여러가지 값을 마구마구 집어널을 수있다.</p>
<p><strong>정적타입의 언어</strong>(자바,c)-변수자체가 타입이 있다=엄격하다(정해진타입의 값만이 들어갈수있기 때문에 )그래서 안정성이 있다.</p>
<p>언제나 변수의 타입의 값을 확정할 수있다.</p>
<p>Typescript -&gt;자바스크립트 에 정적 타입을 도입한것.</p>
<p>동적 타입언어는 편리함,but위험이 도사리고 있다.</p>
<p>동적으로 변화하는 데이터타입을 추측하기 어려운데 ,안정적인 프로그램을 만들기 위해서<br>1.변수를 최소화 한다.<br>2.전역변수(라이프 주기가 길다)사용x<br>변수의 생명주기를 짧게 만든다.<br>3.변수보다 상수를 사용해서 값의 변경을 억제 하자.<br>4.변수의 이름을 존재를 파악할 수있도록 명명한다.</p>
<hr>
<p><strong>표현식과 연산자</strong></p>
<p><strong>표현식</strong> :하나의 값을 표현할 수있는 문<br>표현식에 리터럴,식별자,연산자를 사용할 수있다.</p>
<p><strong>리터럴</strong>-사람이 이해할 수있는 값으로 나타냄<br>리럴은 표현식을 만드는 요소중에 하나이다.리터럴은 표현식이 될수있지만, 표현식은 리터럴 일수도 아닐 수도 있다.</p>
<p><strong>문</strong>-표현식일수도 아닐수도 있다.(문&gt;표현식)</p>
<p><strong>표현식인 문</strong>-값으로 표현(변수에 할당)<br><strong>표현식이 아닌 문</strong>-값으로 표현 (변수에 할당x)<br> 표현식인 문과 표현식이 아닌 문을 확인하는 가장 쉬운 방법은 변수에 할당해보는 방법이다.</p>
<p><strong>변수선언문</strong>-표현식이 아닌 문<br><strong>할당문**</strong>-(ex)x=5; 어떤 변수에 할당할 수있다.</p>
<p>문은 세미콜론으로 끝나야한다. 그러나 단 코드 블록 뒤에는 붙이지 않는다. 자동 삽입 기능이있지만 붙이는 것이 권고 된다.</p>
<p><strong>연산자</strong>:표현식을 만드는 연산자.피연산자에는 식이 올수도 있다.</p>
<p><strong>이항 연산자</strong>는 부수효과가 없다.<br>그러나 단항 연산자++,–부수효과가 있다.</p>
<p>+’10’숫자로 암묵적으로 변한이 일어남</p>
<p><strong>비교연산자</strong><br>===타입이 다르면 false이다.==타입이 달라도 같은 결과라고 나오는 경우가 있기에 ===을 사용해야함.<br>!==와 !==도 마찬가지</p>
<p>NaN===NaN은 false을 반황하는대   NaNdㅡㄴ 자신과 일치하지 않은 유일한 값이다. 따라서 NaN인지를 조사하려면 빌트인 함수를 isNaN을 사용해여한다.</p>
<p><strong>대소 연산자</strong>도 true와 false값을 받는다.</p>
<p><strong>3항 조건 연산자</strong><br>조건식? 조건식 이 true일때 반환하는 값 :조건식이 false일때 반환하는 값<br>var x=2;</p>
<p>var result=x%2? ‘홀수’:’짝수’;</p>
<p>console.log(result);</p>
<p>var x=2,result;</p>
<p>if(x%2){<br>result=’홀수’;</p>
<p>}else{</p>
<p>result=’짝수’</p>
<p>}console.log(result);</p>
<p><strong>논리연산자</strong></p>
<p>or(논리합:||)and(논리곱:&amp;&amp;) not(!)</p>
<p><strong>드모르간의 법칙</strong> !(x || y)===(!x &amp;&amp; !y)</p>
<p><strong>단축평가</strong>-피연산자가 불리언이 아닐수도 있다 어느 한쪽을 선택함</p>
<table>
<thead>
<tr>
<th>단축 평가 표현식</th>
<th>평가 결과</th>
</tr>
</thead>
<tbody><tr>
<td>true||anything</td>
<td>true</td>
</tr>
<tr>
<td>false||anything</td>
<td>anything</td>
</tr>
<tr>
<td>true&amp;&amp;anything</td>
<td>anything</td>
</tr>
<tr>
<td>false&amp;&amp;anything</td>
<td>false</td>
</tr>
</tbody></table>
<p><strong>typeof연산자</strong> </p>
<p>typeof funciton(){}-함수 리터럴-&gt;function을 받는다<br>생성자 함수=new 객체와 새로운 함수를 만든다.<br>typeof null은 object를 반환한다.</p>
<p><strong>지수연산자</strong></p>
<p>5 ** 2-&gt;25;</p>
<p>var num=5;<br>num ** =2-&gt;25</p>
<p>1.연산자 ++/–변수 ㄱ밧을 고친 다 부수효과가 존재한다.<br>2.동등연산자의 차이(===/==);<br>3.삼항조건연산자,if문 대신 사용할 수 있다.</p>
]]></content>
      <tags>
        <tag>변수 뒷부분 + 1.데이터타입 2.연산자</tag>
      </tags>
  </entry>
  <entry>
    <title>웹접근성과 WAI-ARIA</title>
    <url>/2019/09/17/%EC%9B%B9%EC%A0%91%EA%B7%BC%EC%84%B1/</url>
    <content><![CDATA[<p> 웹 접근성이란 웹 사이트에서 제공하는 정보를 차별없이 동등하게 이용 할 수 있도록하는 보장하는 것을 말한다. 신제적(고령층 ,장애인,비장애인 ) 환경적 요건(다양한 플랫폼,웹 브라우져,장치)을 모두 포함한다.</p>
<p>WAI ; Web Accessibility InitiativeWAI는 시각·청각 기능 등에 장애를 지닌 사람도 일반인과 동등하게 웹에 접근하여 이용할 수 있도록 관련 지침을 개발하고 웹 접근성 향상을 위한 노력을 기울이는 W3C의 산하 단체를 말한다</p>
<p>ARIA:Accessible Rich Internet Applications’의 약자로 리치 인터넷을 위한 W3C 접근성 명세입니다.</p>
<p>RIA:정적인 HTMl과 단순한 자바스크립트 환경의 웹이 아닌 동적인 자바스크립트와 Ajax와 같은 기술을 사용한 환경에서 수준 높은 UX(User eXperience)를 제공하는 웹 애플리케이션을 의미한다.</p>
<p>WAI-ARIA는 RIA에서 스크린 리더기 및 보조기기 등에서 접근성 및 운용성을 향상시키기 위한 목적으로 탄생했으며 웹 애플리케이션에 역할,속성,상태 정보를 추가하여 이를 개선 할 수 있도록 제공하고 있다.</p>
<p>1)대표적인 역할( role):tablist,button,tab,tooltip,list,</p>
<p>application,abnner,navigation,form,search..</p>
<p>2)Property &amp; State:(상태와 속성):aria-labelledby=”” : 레이블 제공을 위한 aria-속성. 상태 값은 연결시킬 레이블 id를 입력한다.</p>
<p>aria-haspopup=”” : 팝업요소가 하위에 존재하고 있다는걸 인식 시켜주는 aria-속성. 상태 값은 false(default) / true / menu / listbox / tree / gird / dialog</p>
<p>aria-live : 페이지의 어떤 위치에 있든 업데이트된 정보를 사용자에게 알려주는 aria-속성. 상태 값은 assertive / off(default) / polite</p>
<p>aria-labelledby=”” : 레이블 제공을 위한 aria-속성. 상태 값은 연결시킬 레이블 id를 입력한다.</p>
<p>aria-selected=”” : 탭메뉴 선택 유무를 알려준다. 상태 값은 선택되었을 때 true / 선택되지 않았을 때 false 입력</p>
<p>ria-controls=”” : 현재 요소가 제어하는 대상을 명시하는 속성으로 탭메뉴와 본문을 연결시켜준다. 상태 값은 tabpanel의 id명 입력</p>
]]></content>
      <tags>
        <tag>웹 접근성과 WAI-ARIA</tag>
      </tags>
  </entry>
  <entry>
    <title>스코프</title>
    <url>/2020/05/03/%EC%8A%A4%EC%BD%94%ED%94%84/</url>
    <content><![CDATA[<p><strong>스코프</strong></p>
<p>식별자(변수)가 유효한 범위,식별자와 깊은 관련,함수와 관련<br>어떨때 유효하고 어떨때 유효하지 않은가?<br>함수는 스코프를 만든다.(var키워드로 선언한 경우)</p>
<p>var 키워드는 함수의 코드블록만을 코드 블록으로 인정하는 함수레벨 스코프를 따른다. var 키워드는 함수가 스코프를 만든다.</p>
<p>중첩함수-스코프도 중첩이 된다.(어떤 우선순위를 가지는 가?을 아는 것이 중요)<br>스코프는 간단하게 말하면 자바스크립트엔진이 식별자를 찾는 규칙이다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//선언하고 할당할때 a라는 식별자를 찾는다.</span></span><br></pre></td></tr></table></figure>

<p>즉 스코프는 식별자에 존재한다. 프로퍼티는 prototype체인에 존재한다.</p>
<p>스코프의 생명주기<br>함수에 매개변수가 업ㄱ다면 외부와 단절이 된다. 하지만 매개변수는 없는 것이 가장 좋다.-&gt;외부에 의존하기 때문에</p>
<p>함수는 재사용을 한다. 변수를 왜쓰는가?-어떤 상태를 유지해야할때 사용한다.<br>변수를 공용으로 쓸때는(전역변수와 관련하여)? 고정되어 변하지 않는 값ㅇ르 가지는 경우에 사용한다.<br>상수는 재할당을 금지시킨다. 따라서  전역변수는 상수개념이 아니면 사용하지 않는것이 좋다.</p>
<p>1.순수함수-1언제나 동일 한 반환값(return x+y)<br>x(2,3)=5</p>
<p>2.비순수함수 -외부함수에 영향을 받음</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>스코프 함수</strong></p>
<p>변수가 어디에서 선언이 됐느냐가 즉 선언 위치가 스코프를 만든다.<br>class는 함수이다.<br>자신이 선언된 위치에 의해 다른 식벼자를 참조할 유효범위가 결정된다.</p>
<p>function foo(){}는 식별자가 2개이다. 1.암묵적으로 자바스크립트 엔진이 변수이름으로 만든 식별자.</p>
<p>2.지역함수의 식별자. 그런데 에러를 일으키지않는다. 그리고 foo는 전역 함수이다. 또한 호출하는 foo()에서 foo는 함수이름이 아니고 자바스크립트엔진이 생성한 암묵적인 식별자다.</p>
<p>스코프는 자카스크립트엔진이 식별자는 찾는 규칙이다. 코드와 가장 근접한 곳에있는 스코프를 본다.<br>자바스크립트 코드의 문맥과 환경이있따. 코드를 실행하기 위한 문맥을 기억한다. 자바스크립트는 전역과 지역을 어떻게 구분하는걸까?</p>
<p>식별자는 스코프내에서 유니크하다.<br>전역은 어디근 참조(문맥을 찾는다.)가 가능하다. 코드가 해당하는 스코프부터 식별자를 찾는다. 그후에 상위로 간다.<br>쉐도잉-그림자 처럼 가져려진다.<br>식별자는 자바스크립트엔진에 등록이된다.<br>이때 스코프가 정해진다.<br>식별자는 스코프 체인에서 찾는다. 함수는 변수와 저장되는 매카니즘이 같다. 찾는 매카니즘도 동일하다.</p>
<p><strong>렉시컬 시코프</strong><br>자바스크립트엔진이 함수를 정의할때 어디서 호출될지 알수없다.<br>언제 함수의 상위 스코프가 오는냐? 함수의를 할때 취치에 의해 상위 스코프가정해진다. 어디서 호출되든지 간에 정의위치에 ㄱ따라 사우이스코프가 정해져버린다.<br>동적스코프와 /렉시컬스코프의 차이</p>
<p>매개변수가 값을 할당하는 것은 호출할때, 호출된 직후 매개변수undefined 선언된다. 이후에 할당된다.<br>변수도 어디에서 선언되는지에 따라 스코프가 정해진다.함수도 마찬가지</p>
<p><strong>암묵적 전역변수</strong><br>전역함수에서 선언하지않은 변수는 전역변수가 된다.<br>모듈(자바스크립트 엔진은 파일 스코프를 가지지않는다.)-&gt;한개의 파일로 함ㅍ쳐진다. 같은 이름의 변숙가 있다면 재할다잉 된다.이런 문제 따문에 전역변수를 사용하지않는다.<br>자바스크립트에는 순서가 있다.엄청 여러개의 스크립트파일들을  webpack 번들링 로 하나로 묶고 그 안에서 스코프를 줘서 나눈다.</p>
<p><strong>변수의 생명주기</strong>- 변수 생명주기는 직역변수일때 함수의 생명주기가 짧다.리소스가 빨리 해방이 된다.<br> 반대로 전역변수의 생명주기(스코프가 길다.)는 길기 때문에 재할당 수정등의 여러가지 문제를 야기한다.</p>
<p>짧고 생명주기가 짧은 함수가 가독성이 좋다. 그리고  한가지 일만 을 시킬수있어서 좋다.</p>
<p>전역변수의 생명주기는 스크립트 로드가 되자마자 생성되고 애플리케이션이 종료될때 까지 (브라우저 종료) 전역변수는 리소스 할당이 적다.,암묵적 결함을 하고,네이밍스페이스를 오염시킨다. </p>
<p>모둘패턴 (문법이 아닌 디자인 패턴이다.)<br>즉시실행함수는 코드가 실행되면 바로 실행이 된다. 객체 리터럴이 바로 함수에 할당이 된다. 모듈패턴은 자바스크립트에는 자바에서 public,private,protected같은 접근제한자가 없다. 따라서 이를 상요함으로써 변수에 접근을 하지못하게하는 역할을 하기위해 사용한다.<br>let,const 블록레벨 스코프</p>
<p>var키워드는 전역 변수의 분제점으로 귀결된다. 왜var키워드를 사용할 수없는가?-&gt;함수레벨 스코프,전역변수 문제점,재할당 등의 이유.</p>
<p>변수 호이스팅은 나쁜점이다. 지양해야하는 부분.<br>변수는 선언하고 참조해라</p>
<p>let/const 변수 선언 중복선언애러,변수는 스코프가 분리되있으면 다른 변수이다.</p>
<p>for문()의 소괄호의 부분은 코드블록안에 있다고 생각을 하는 것이 좋다.</p>
<p>const/let은 호이스팅이 안하는 것 처럼 보이지만 한다.-런타임이전에 변수는 선언이 된다. 하지만 런타임에 선언문을 만나야지 값이 할당된다. 그렇기 때문에 선언문이전에 호출을 하면 에러를 발생시킨다. 즉 선언된 것을 자바스크립트엔진이 알지만 이에 접근하지 말라는 의미다.</p>
<p><strong>전역객체</strong></p>
<p>브라우저의 전역객체는 :window이다.<br>node.js의 전역객체는 :gloabal이다.<br>var키워드로 선언한 모든 전역변수는 window객체릐 프로퍼티가 된다.</p>
<p>브라우저의 페이지를 바꾸면 전역객체또한 리셋이 된다.<br>전역객체는 var키워드로 선언한다.<br>function foo(){}와 var foo=funciton(){}모두 window의 객체이다.</p>
<p>let으로 선언한 전역변수는 더이상 읽어들을 전역변수가 없다면 생명주기를 다하고 죽는다.<br>var와 let키워드를 섞어서 사용하지만고 한가지만을 통일해서 사용하자.<br>window객체의프로퍼티는 전역변수와 같게 사용 할 수 있다.</p>
<p><strong>const키워드</strong><br>재할당을 할수없다. 변수 선언과 동시에 값을 할당해 주어야한다.<br>상수도 변수이다. 재할당을 금지시킨다.(스네이크 케이스,대문자로 사용한다.).</p>
<p><strong>const 키워드의 객체</strong><br>재할당을 하는 일은 극히 드물다.<br>대부분 변수 const 사용한다. 변수 재할당 할일 이 없다.<br>객체는 변경가능한 값이다. 객체를 가지는 변수는 let을 사용할 이유가 없다. 객체는 기본적으로 재할당하지 않는다. es6/const ,let을 사용한다. 재할당 필요한 경우에만 let을 사용한다. </p>
<p>전역 코드의 실행이 종료되면 let종료,window는 살아있다. 완료값은 변수에 할당되는 값이 아니다.</p>
]]></content>
      <tags>
        <tag>스코프</tag>
      </tags>
  </entry>
</search>
