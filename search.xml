<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>하이브리드 웹, 네이티브 웹, 웹 앱의 차이점</title>
    <url>/2020/05/07/%20webapp/</url>
    <content><![CDATA[<h3 id="localStorage와-session-storage의-가장-큰-차이점"><a href="#localStorage와-session-storage의-가장-큰-차이점" class="headerlink" title="localStorage와 session storage의 가장 큰 차이점"></a>localStorage와 session storage의 가장 큰 차이점</h3><ul>
<li><p>local storage  만료기간이 없기때문에  브라우저가 종료되어도 남아있는다.</p>
</li>
<li><p>session storage 브라우저가 종료되면은 사라진다.</p>
</li>
</ul>
<hr>

<h2 id="1-하이브리드-앱"><a href="#1-하이브리드-앱" class="headerlink" title="1. 하이브리드 앱"></a>1. 하이브리드 앱</h2><p>하이브리드 앱은 네이티브 개발과 웹 기술을 융합한 방식입니다. 기본 기능은 HTML 등의 웹 문서로 구현하고, 패키징은 아이폰, 안드로이드 등 모바일 운영 체제(OS) 별로 구현하는 것이다.<br>따라서 네이티브 앱과 같이 앱 스토어에서 다운로드하여 사용할 수 있고, 기기에 저장된 고유 파일이나 카메라와 같은 하드웨어적인 부분에 접근성을 가질 수도 있습니다. 또한, 근본적으로는 웹 기술을 이용한 것이기에 빠르고, 편리하게 앱을 유지보수할 수 있습니다.</p>
<p><strong>하이브리드 앱의 단점</strong>은 네이티브 앱보다 UI를 구성하는 디자인 부분이 취약하며, 성능이 떨어진다는 것입니다. 또한, 웹 브라우저를 실행하여 콘텐츠를 제공하기에 인터넷 속도에 따라 구동 속도가 느려질 수도 있습니다.</p>
<h3 id="1-1-하이브리드-APP의-장점"><a href="#1-1-하이브리드-APP의-장점" class="headerlink" title="1.1. 하이브리드 APP의 장점"></a>1.1. 하이브리드 APP의 장점</h3><p>■ 네이티브 API 와 브라우저 API 를 이용한 다양한 개발이 가능 합니다.<br>■ 웹개발 기술을 사용해 앱을 개발할 수 있습니다.<br>■ 한번의 개발로 다수의 플랫폼에 대응할 수 있습니다.</p>
<h3 id="1-2-하이브리드-APP의-단점"><a href="#1-2-하이브리드-APP의-단점" class="headerlink" title="1.2.하이브리드 APP의 단점"></a>1.2.하이브리드 APP의 단점</h3><p>■ 웹뷰에서 앱을 실행하는 경우이기 때문에 앱의 성능이 곧 브라우저의 성능 입니다.<br>■ UI 프레임워크 도구를 사용하지 않는다면 개발자가 UI를 제작해야 합니다</p>
<hr>

<h3 id="모바일-웹-web-이란"><a href="#모바일-웹-web-이란" class="headerlink" title="모바일 웹 (web) 이란?"></a>모바일 웹 (web) 이란?</h3><p>모바일 웹은 모바일에서 PC용 사이트의 글자폰트와 이미지 , 터치 아이콘 , 플래시 등 데스크탑 브라우저에서 실행되는 기능을 모바일에 맞추어 표현한 사이트를 의미합니다. 쉽개말해 , PC용 홈페이지를 모바일 스크린의 크기에 맞춰 줄여 놓은 것이라고 생각하시면 됩니다.</p>
<hr>

<h2 id="2-웹-앱"><a href="#2-웹-앱" class="headerlink" title="2. 웹 앱"></a>2. 웹 앱</h2><p>웹앱은 모바일웹 과 네이티브앱을 결합한 형태로 모바일웹의 특징을 가지면서 네이티브앱의 장점을 갖고 있습니다. 모바일웹 보다는 조금 더<br>모바일에 최적화 된 앱을 의미 합니다. 웹앱도 모바일웹 처럼 일반적인 웹기술로 개발되고 모바일 브라우저에서 실행되지만 풀 브라우저 방식이 아닌 단일 페이지 방식으로 화면을 진화해 속도가 빠르다는 장점이 있습니다.</p>
<p>모바일 웹 앱이란 PC나 스마트폰 등 단말기의 기종에 관계없이 모든 단말기에서 같은 콘텐츠를 볼 수 있도록 해주는 앱입니다.<br>운영체제(OS)와 직접 통신하는 네이티브 앱과 다르게 웹 앱은 브라우저 내에서 실행됩니다. 따라서 앱을 따로 다운로드하거나 업그레이드하지 않고, 항상 최신 버전을 유지할 수 있지요. 또한, OS별로 별도의 플랫폼이 필요하지 않고, HTML5와 같은 표준 웹 언어로 만들어지기 때문에 제작 비용도 저렴하고, 개발 기간도 비교적 짧은 편입니다.<br>웹 앱 방식은 상대적으로 개발 공수가 적게 들고, 업데이트가 쉽지만 기능상 제한이 많이 따릅니다. 웹 앱은 처음부터 디바이스에 적합한 형태로 만들어지는 것이 아니기 때문입니다. 따라서 네이티브 앱과 비교해 봤을 때, 느리기도 하고, 앱을 통해 기기 고유의 정보를 사용할 수도 없습니다.</p>
<h3 id="2-1-모바일-웹앱의-장점"><a href="#2-1-모바일-웹앱의-장점" class="headerlink" title="2.1. 모바일 웹앱의 장점"></a>2.1. 모바일 웹앱의 장점</h3><p>■ 웹사이트를 보는 것이기 때문에 따로 설치할 필요가 없습니다.<br>■ 모든 기기와 브라우저에서 접근할 수 있습니다.<br>■ 별도 설치 및 승인과정이 필요치 않아 유지보수가 용이 합니다.</p>
<h3 id="2-2-모바일-웹앱의-단점"><a href="#2-2-모바일-웹앱의-단점" class="headerlink" title="2.2. 모바일 웹앱의 단점"></a>2.2. 모바일 웹앱의 단점</h3><p>■ 플랫폼 API (카메라 등) 을 사용할 수 없고 오로지 , 브라우저 API만을 사용할 수 있습니다.<br>■ 친화적인 터치 앱을 개발하기가 약간 번거로운 점이 있습니다. (까다로움)<br>■ 네이티브 , 하이브리드 앱보다 실행이 까다롭습니다. (브라우저를 열고 검색해 들어가야 합니다.)</p>
<hr>

<h2 id="3-네이티브-앱"><a href="#3-네이티브-앱" class="headerlink" title="3. 네이티브 앱"></a>3. 네이티브 앱</h2><p>네이티브 앱은 우리가 흔히 말하는 ‘ 어플리케이션 ‘ 을 의미 합니다. 모바일 기기에 최적화 된 언어로 개발 된 앱으로 안드로이드 SDK를 이용해 Java (자바) 언어로 만드는 앱과 iOS 기반 SDK를 이용해 Swift (스위프트) 로 만드는 대부분의 앱이 여기에 속한다고 할 수 있습니다.</p>
<p>네이티브 앱이란 모바일 기기에 직접 다운로드하여 사용하는 앱입니다. </p>
<p>네이티브 앱이란 모바일 기기에 직접 다운로드하여 사용하는 앱입니다. 네이티브 앱은 사용자가 공용 앱스토어에서 직접 설치할 수도 있고, 모바일 공급업체에서 제공할 수도 있습니다.<br>네이티브 어플을 만들기 위해서는 개발자가 사람이 읽을 수 있는 형식으로 소스코드를 작성하고, 다양한 운영체제(OS: Operation System) 별로 선언 파일이나 이미지, 오디오 등의 리소스를 만들어야 합니다. 그다음, 모바일 운영체제(OS)에서 제공하는 툴을 활용하여 소스코드를 컴파일하고, 여러 실행 파일을 만들어야 하지요.<br>이처럼 네이티브 앱은 각기의 모바일 운영체제(OS)에서 제공하는 툴과 언어 등에 따라 기능들을 최대한 살리기 때문에, 높은 사양의 그래픽과 성능을 자랑하면서도 구동 속도가 빠른 편입니다. 뿐만 아니라 디바이스 전체에 액세스 권한을 가질 수 있어, 기기에 저장된 주소록, 캘린더 등의 고유 정보를 사용할 수도 있지요.<br>하지만 다른 방식들보다 높은 수준의 기술력이 필요하며, 각기의 모바일 운영체제(OS)별로 앱을 개발해야하기 때문에 개발 기간이나 비용이 많이 들 수 있습니다.</p>
<h3 id="3-1-네이티브-앱의-장점"><a href="#3-1-네이티브-앱의-장점" class="headerlink" title="3.1. 네이티브 앱의  장점"></a>3.1. 네이티브 앱의  장점</h3><p>성능이 웹앱 , 하이브리드 앱에 비하여 가장 높습니다.<br>■ 네이티브 API를 호출하여 사용함으로 플랫폼과 밀착되어 있습니다.<br>■ 해당 언어에 익숙한 사용자라면 좀 더 쉽게 접근할 수 있습니다.</p>
<h3 id="3-2-네이티브-앱의-단점"><a href="#3-2-네이티브-앱의-단점" class="headerlink" title="3.2. 네이티브 앱의 단점"></a>3.2. 네이티브 앱의 단점</h3><p>플랫폼에 한정적 입니다.<br>■ 해당 플랫폼에서 요구하는 언어에 제약적 입니다. 따라서 해당 언어와 플랫폼의 API를 다루는데 익숙해야 합니다.</p>
]]></content>
      <tags>
        <tag>하이브리드 웹, 네이티브 웹, 웹 앱의 차이점에대해 알아보자</tag>
      </tags>
  </entry>
  <entry>
    <title>10월 7일 러버덕(키워드,식별자,변수와 선언,메모리,메모리 주소,할당,호이스팅)</title>
    <url>/2019/10/07/10%EC%9B%947%EC%9D%BC%EB%9F%AC%EB%B2%84%EB%8D%95/</url>
    <content><![CDATA[<h3 id="1-키워드"><a href="#1-키워드" class="headerlink" title="1.키워드:"></a><strong>1.키워드</strong>:</h3><p>명령어(뒤에 값을 준다.)<br><strong>자바스크립트에게 내리는 명령.</strong><br>변수선언하려면 반드시  키워드 사용(var/let,const)</p>
<h3 id="2-식별자-변수이름"><a href="#2-식별자-변수이름" class="headerlink" title="2.식별자(변수이름):"></a><strong>2.식별자(변수이름):</strong></h3><p>고유한이름/일종의 카드키와 같다.<br><strong>식별자(변수이름)-메모리에 있는 값을 구별해서 끄집에 낼 수 있는 값</strong><br>./어떤 값을 구별하여 식별해 낼 수 있는고유한 이름.</p>
<p>또한 <strong>식별자는 메모리 주소를 알고있다.</strong></p>
<p>변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 저장된다.<br>네이밍 규칙-예약어x/특수문자 _ $가능 숫자 처음 에 안나옴.</p>
<h3 id="3-변수와-선언"><a href="#3-변수와-선언" class="headerlink" title="3.변수와 선언:"></a><strong>3.변수와 선언:</strong></h3><p><strong>변수-</strong>데이터를 다룬다. 하나의 값을 저장할 수있는 메모리 공간에 붙은 이름 혹은 메모리 자체를 의미한다.</p>
<p>변수를 사용하려면 반드시 선언을 해줘야한다.</p>
<p><strong>변수의 선언-</strong><br>변수를 생성한다. 변수란 컴퓨터의 메모리 와 관련있다.<br>자바스크립크엔진에 변수이름 등록,값 저장을 위한 메모리 공간을 확보하기위함.</p>
<h3 id="4-메모리와-주소"><a href="#4-메모리와-주소" class="headerlink" title="4.메모리와 주소:"></a><strong>4.메모리와 주소:</strong></h3><p>메모리:데이터를 저장할 수 있는 데이터 셀들의 집합체.<br>메모리주소: 메모리 공간의 위치를 나타내며 0부터 시작하여 메모리의 크기만큼 정수로 표현된다. </p>
<p>값을 입력하면 메모리 임의의 공간에 저장이 된다.하지만 메모리의 주소는 알여주지 않는데 저장된 데이터를 재사용하기 위해서는 변수를 제공해야하고 변수는 저장되는 곳의 메모리 주소를 기억한다.</p>
<p>매니지드:(자바스크립트):<br>언매니지드(c언어):</p>
<h3 id="5-할당"><a href="#5-할당" class="headerlink" title="5.할당:"></a><strong>5.할당</strong>:</h3><p> 변수에 값을 저장한다. 할당한다(저장한다.대입한다.assign한다)<br>논리적으로 기본적으로 변수를 선언하고 할당해야한다. 변수만을 선언하고 할당하지 않으면 값이 정의 되지 않았기 때문에 undefined가 출력이 된다.</p>
<p>변수선언은 소소코드가 순차적으로 실행되기 이전,즉 런타임 이전에 먼저실행되지만,값의 할당은 소스코드가 순차적으로 실행되는 시점인 런타임에 실행된다.</p>
<h3 id="6-호이스팅"><a href="#6-호이스팅" class="headerlink" title="6.호이스팅-"></a><strong>6.호이스팅-</strong></h3><p>왜 호이스팅이 발생하는가?-&gt;**선언문은 실행될때 가장먼저 골라져서 실행되기대문에 발생한다.위 끌어올려서 실행된 실행문은 또 실행되지 않는다.</p>
]]></content>
      <tags>
        <tag>1키워드,2.식별자.3.변수와 선언 4.메모리와 메모리주소5.할당6.호이스팅</tag>
      </tags>
  </entry>
  <entry>
    <title>CSR(클라이언트 사이드 렌더링)과 SSR(서버 사이드 렌더링) 차이점</title>
    <url>/2020/05/03/CSR%20SSR%20SPA%20/</url>
    <content><![CDATA[<p><strong>1.CSR(클라이언트 사이드 렌더링)</strong><img src="https://s3.amazonaws.com/media-p.slid.es/uploads/640576/images/3943424/CSR.png" alt="CSR"></p>
<p>-1.Server Sending Response to Browser<br>-2.Browser Downloads JS<br>-3.Browser executes React<br>-4.Page Now Viewable and Interatable</p>
<p>서버에서 비어있는 html와  js파일들을 받아오고 , 데이터는 서비스에 필요한 리소스를 다운로드한후 브라우저에서 렌더링한다.그렇기 때문에 초기 View을 보기가지 SSR보다 시간이 더 걸린다. 하지만 사용자에게 보여진 view의 기능은 동시에 동작한다.</p>
<p><strong>2.SSR(서버사이드 렌더링)</strong><img src="https://s3.amazonaws.com/media-p.slid.es/uploads/640576/images/3943426/SSR.png" alt="SSR"></p>
<p>-1.Server Sending Ready tobe redered HTML Response to Browser<br>-2.Browser Renders the page,Now Viewable,andBrowser Downloads JS<br>-3.Browser execute React<br>-4.Page Now interatable</p>
<p>서버에서 렌더링해 가져오기 때문에 ,첫 로딩 매우 짧다.<br>그러나 클라이언트가 js파일을 모두 다운로드하고 적용하기전가지는 각각의 기능은 동작하지않는다는 단점이 있다</p>
<p><strong>3.SPA(Single page application)</strong></p>
<p>서버로 부터 처음에만 페이지를 받아오고 이후에는 동적으로 페이지를 구성해서 새로운 페이지를 받아오지않는 웹 애플리케이션을 의미한다.<br> 페이지가 한번 로딩된 이후 데이터를 수정하거나 조회할때. 페이지가 새로고침이 되지않고 다른 페이지로 넘어가지 않습니다.</p>
<p><strong>4.MPA(Multi Page Application)</strong></p>
<p>서버로 부터 완전한 페이지를 받아오고 이후에 데이터를 수정하거나 조회할때 다른 완전한 페이지로 이동합니다.단 URL이 바뀔수있습니다.</p>
]]></content>
      <tags>
        <tag>CSR(클라이언트 사이드 렌더링)과 SSR(서버 사이드 렌더링) 차이점</tag>
      </tags>
  </entry>
  <entry>
    <title>IR 기법</title>
    <url>/2019/09/17/IR%EA%B8%B0%EB%B2%95/</url>
    <content><![CDATA[<p>홈페이지를 만들때 이미지를 사용할 경우 img태그를 사용해 alt로 이미를 부여 합니다.</p>
<p>IR(image replacement)은 웹표준 및 접근성을 위한 기법입니다. 이미지를 배경으로 처리하고 이미지의 의미를 텍스트화 하여 CSS로  숨겨, 이미지 대체 텍스트를 제공하기 위한 기법 입니다. IR기법은 앞에서 얘기한 대로 접근성이 매우 유용하기 때문에 검색시에 검색엔진으로 부터 높은 가중치를 받을 수 있습니다.</p>
<p>IR을 사용하는 방법으로는 크게 </p>
<ol>
<li><p>padding을 사용하는 방법(가로 250px,세로 195px인 이미지)</p>
<h2 class="brand1">CSS ZenGarden</h2>

<p> .brand1{ background:pink url()no-repeat;height: 0;width: 250px;padding-left: 195px;overflow: hidden;}</p>
</li>
<li><p>text-indent 를 사용하는 방법</p>
<h2 class="brand2">CSS ZenGarden</h2>

<p>.brand2{background: pink url(/images/title.png)no-repeat;height: 195px;width: 290px;text-indent: 290px;</p>
<p>​    <em>/\</em> text-indent: -9999px; */*white-space: nowrap;overflow: hidden;}</p>
<p>*text-indent의 값을 -9999px을 주어 텍스트를 아예 화면 밖으로 밀어 버리는 경우도 있지만, 이 경우에는 성능상 좋지 않으므로 white-space:nowrap와 overflow:hidden을 사용한다.</p>
</li>
<li><p>postion을 활용하는 방법</p>
<h1 class="brand3">CSS ZenGarden</h1>

<p>.brand3{background: lime ;height: 195px;width: 290px;text-align: center;line-height: 195px; font-size: 16px;font-weight: 400;position: relative;} .brand3::after{ content: “”;position: absolute;top: 0;left: 0;background: url(/images/title.png)no-repeat;width: 100%;height: 100%;}</p>
</li>
</ol>
<p>이외에도 숨기고자하는 텍스트를 span태그로 감싸 준 후 화면에서 안보이게 처리해주는 방법도 있고, 방법은 다양하다.</p>
<p>그리고 Daum은 이런 여러기법중에서  Phark Method와WA IR 기법을 주로 사용하여 대체텍스트를 제공해주고 있다.</p>
<p>Phark Method (권장): 이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 text-indent를 이용하여 화면 바깥으로(-9999px만큼 내어 쓰기) 빼내어 보이지 않게 하는 방법.</p>
<p>장점:스크린 리더기가 읽어주고,추가적인 태그사용을 하지 않는다.</p>
<p>WA IR 기법(권장):이미지로 대체할 엘리먼트에 배경이미지를 설정하고 글자는 span 태그로 감싼 후 z-index:-1을 이용하여 화면에 안보이게 처리하는 방법.</p>
<p>장점:스크린 리더기 가 읽어줌,CSS on / Image off 시 텍스트 보임.</p>
]]></content>
      <tags>
        <tag>IR기법 활용에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>제어문</title>
    <url>/2020/05/12/control-flow-statement-md/</url>
    <content><![CDATA[<h1 id="1-블록문"><a href="#1-블록문" class="headerlink" title="1. 블록문"></a>1. 블록문</h1><p>블록문는 0개이 상의 문을 중괄호로 묶은것으로 콛블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블ㄹ고문을 하나의 시랳아 단위로 취급한다. 블록문은 단독으로 사용할 수도 있으나 일반적으로 제어문이나 함수를 정의할때 상요하는 것이 일반적이다.<br>블록문이 사용되는 다양한 예제가 있다. 문의 끝에는 세미 콜론을 붙이는 것이 일반적이다. 하지만 블록 문은 언제나 문의 종료를 의미하는 자체 종결성을 갖기 때문에 블록문의 끝에는 세미콜론을 붙이지 않는다는 것에 주의하자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//블록문</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> foo = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//제어문</span></span><br><span class="line"><span class="keyword">var</span> x =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;<span class="number">10</span>)&#123;</span><br><span class="line">  x++</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-조건문"><a href="#2-조건문" class="headerlink" title="2. 조건문"></a>2. 조건문</h1><p>조건문은 주어진 조건식의 평가 결과에 따라 코드블록의(블록문)의 실행을  결정한다. 조건식은 불리언 값으로 평가 될 수있는 표현식이다. 자바스크립트는 2가지의 조건문 if …else if 문과 switch문을 제공한다.</p>
<h2 id="2-1-if-…-else-if-문"><a href="#2-1-if-…-else-if-문" class="headerlink" title="2.1. if … else if 문"></a>2.1. if … else if 문</h2><p>if .. else  문은 주언진 조건식(불리언 값으로 평가 될수 있는 표현식)의 평가 결과,즉 놀리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다. 조건식의 평가 결과가 참일 경우,if 문 다음의 코들 블록이 실행되고 거짓일 경우 else일경우 다음의 코드 블록이 실행된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(조건식)&#123;</span><br><span class="line">  <span class="comment">//조건식이  참이면 이 코드 블록이 실행된다.</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//조건식이 거짓이면 이 코드 블록리 실행된다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if의 조건식은 불리언 값으로 평가 되어야한다. 만약if문의 조건식이 불리언값이 아닌 다른 값으로 평가 되면 자바스크립트 엔진에 의해서 암묵적으로 데이터 타입이 불리언 값으로 강제로 변환이 되어 실행할 코드 블록을 결정한다.<br>조건식을 추가하여 조건에 따라 실행될 코드 블록을 늘리고 싶으면 else if문을 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(조건식)&#123;</span><br><span class="line">  <span class="comment">//조건식1이 참이면 이 코드 블록을 실행</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(조건식)&#123;</span><br><span class="line">  <span class="comment">//조건식2이 참이면 이 코드블록을 실행</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="comment">//조건식1과 조건식2가 모두 거짓이면 이 코들 블록을 실행</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> else if문과 else문은 옵션이다. 즉 사용 할 수도 있고 사용하지 않을 수도 있다. if문과 else문은 2번이상 사용할수 없지만 else if문은 2 이상 사용 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind;</span><br><span class="line"><span class="comment">//if문</span></span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  kind =<span class="string">'양수'</span>;<span class="comment">//양수</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kind);</span><br><span class="line"></span><br><span class="line"><span class="comment">//if else 문</span></span><br><span class="line"><span class="keyword">if</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">  kind = <span class="string">'양수'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  kind =<span class="string">'음수'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kind<span class="comment">//양수</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if else if문 </span></span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  kind =<span class="string">'양수'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt;<span class="number">0</span>)&#123;</span><br><span class="line">  kind = <span class="string">'음수'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  kind = <span class="string">'영'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(kind); <span class="comment">//양수</span></span><br></pre></td></tr></table></figure>

<p>만약에 코드 블록의 문이 하나라면 중괄호를 생략 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind;</span><br><span class="line"><span class="keyword">if</span>(num &gt; <span class="number">0</span> )kind = <span class="string">'양수'</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(num &lt; <span class="number">0</span>)kind = <span class="string">'음수'</span>;</span><br><span class="line"><span class="keyword">else</span> kind = <span class="string">'영'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(kind) <span class="comment">//양수</span></span><br></pre></td></tr></table></figure>

<p>대부분의 if…else 문은 삼항 조건 연산자로 바꿔 사용가능하다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x =<span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> result;</span><br><span class="line"><span class="keyword">if</span>(x % <span class="number">2</span>)&#123;</span><br><span class="line">  result = <span class="string">'홀수'</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  result = <span class="string">'짝수'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">//짝수</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> result = (x % <span class="number">2</span> )? <span class="string">'홀수'</span>:<span class="string">'짝수'</span>;</span><br><span class="line">consoel.log(result) <span class="comment">//짝수</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> kind = num ? (n &gt;<span class="number">0</span>? <span class="string">'양수'</span>: <span class="string">'음수'</span>):<span class="string">'영'</span></span><br><span class="line"><span class="built_in">console</span>.log(num) <span class="comment">//양수</span></span><br></pre></td></tr></table></figure>

<p>(n &gt;0? ‘양수’: ‘음수’)는 표현식이다. 즉 삼항 조건 연산자는 값으로 평가되는 표현식을 만든다. 하지만 if . else 문은 표현식이 아닌 문이다. 따라서 삼항 조건 연산자 표현식은 값 처럼 사용 할 수 있기 때문에 변수 할당 할 수 있다.하지만 if..else문은  값처럼 사용 할수 없다는 차이가 있다. 따라서 조건에 따라 단순히 값을 결정하는 경우 if ..else문 보다 삼항 조건 연산자를 사용하는 것이 가독성이 좋다. 하지만 조건에 따라 실행하여야 하는 내용이 복잡하여 여러 줄의 문이 필요하다면 if ..else문을 사용 하는 평이 가독성이 좋다.</p>
<h2 id="2-2-switch문"><a href="#2-2-switch문" class="headerlink" title="2.2. switch문"></a>2.2. switch문</h2><p>switch문은 주어진 표현식을 형가하여 그 값과 일치하는 표현식을 갖는 case문으로 실행하는 순서를 이동 시킨다. case문은 상화을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행 할  문들을 위치 시킨다.<br>switch문의 표현식과 일치하는 표현식을 갖는 case문이 없다면 실행 순서는 default 문으로 이동한다. default 문은 옵션으로 사용 할 수 있고 않을 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(표현식)&#123;</span><br><span class="line">  <span class="keyword">case</span> 표현식<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 표현식<span class="number">1</span>이 일치하면 실행될 문;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 표현식<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 표현식<span class="number">2</span>이 일치하면 실행될 문;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">switch</span> 문의 표현식과 일치하는 표현식을 갖는 <span class="keyword">case</span>문이 없을 때 실핼될 문</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>else if 문의 조건식은 불리언 값으로 평가되어야 하지만 , switch 문의 표현식은 불리언 값 보다는 문자열 ,숫자 값인 경우가 많다. if ..else 문은 논리적 참,거짓으로 실행할 코들 블록을 결정한다.switch문은 논리적참,거짓 보다 다양한 상황에 따라 실행될 코드 블록을 결정 할 때가 많다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> month = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> monthName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: monthName = <span class="string">'January'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: monthName = <span class="string">'February'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: monthName = <span class="string">'March'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>: monthName = <span class="string">'April'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>: monthName = <span class="string">'May'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>: monthName = <span class="string">'June'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>: monthName = <span class="string">'July'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>: monthName = <span class="string">'August'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>: monthName = <span class="string">'September'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>: monthName = <span class="string">'October'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>: monthName = <span class="string">'November'</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>: monthName = <span class="string">'December'</span>;</span><br><span class="line">  <span class="keyword">default</span>: monthName = <span class="string">'Invalid month'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(monthName); <span class="comment">// November</span></span><br></pre></td></tr></table></figure>

<p>그런데 위 예제를 실행해 보면은 ‘November’가 출력되지 않고 ‘Invalid  month’을 출력한다. 이는 switch문의 표현식의 평가 결과와 일치하는 case 문으로 실행한 것은 맞지만 ,문을 실행한 후  switch문을 탈출 하지않고 switch문이 끝날 때 까지 이후의 모든 case문과 default문을 실행 했기 때문이다. 이를 <strong><u>폴 스루</u></strong> 했다고 한다. 다시 말해 변수 monthName에  ‘November’가 할당된 후 switch 문을 탈출 하지않고 연이어 재할되기 때문이다. 때문에 ‘Invalid month’출력된다.<br>결과가 이러한 이유는 case문에 해당하는 문의 마지막 break문을 사용하지 않았기 때문이다. break 키워드로 구성된 break문은 코드 블록에서 탈출하는 역할을 한다. break문이 없다면 case문의 표현식과 일치하지 않더라도 실행 순서는 다음 case문으로 연이어 이동한다. 올바른 switch문의 예는 다음과 같다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> month = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">var</span> monthName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (month) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>: monthName = <span class="string">'January'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>: monthName = <span class="string">'February'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>: monthName = <span class="string">'March'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>: monthName = <span class="string">'April'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>: monthName = <span class="string">'May'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>: monthName = <span class="string">'June'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">7</span>: monthName = <span class="string">'July'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">8</span>: monthName = <span class="string">'August'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>: monthName = <span class="string">'September'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>: monthName = <span class="string">'October'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">11</span>: monthName = <span class="string">'November'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">12</span>: monthName = <span class="string">'December'</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: monthName = <span class="string">'Invalid month'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(monthName); <span class="comment">// November</span></span><br></pre></td></tr></table></figure>

<p>deafult 문에는 break문을 생략하는 것이 일반적이다. default문은 switch문의 가장 마지막에 위치하므로 defualt문의 실행은 따라서 별도의 break문이 필요 없다.</p>
<p>break문을 생략한 폴 스루가 유용한 경우도 있다 폴스루는 여러개의 case문을 하나의 조건으로 사용할 수 있다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> year =<span class="number">2020</span>;</span><br><span class="line"><span class="keyword">var</span> month = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> days = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(month)&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span> :<span class="keyword">case</span> <span class="number">3</span>:<span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">    days = <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:<span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">    days = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    days =((year % <span class="number">4</span> ===<span class="number">0</span> &amp;&amp; year % <span class="number">100</span> !== <span class="number">0</span>) || (yaer % <span class="number">400</span> === <span class="number">0</span>))?<span class="number">29</span>:<span class="number">28</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Invalid month'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(days);</span><br></pre></td></tr></table></figure>

<p>switch문은 case, default,break등 다양한 키워드를 사용해야하고 상화에 따라 실행될 코들 블록리 중괄호로 붂어 있지 안흥며 폴스루가 발생하는 등 문법도 복잡하다. 따라서 C언어를 기반으로 하는 프로그래밍 언어는 대부분 switch문을 지원하지만 피이썬과 같이 switch문을 지원 하지 않는 프로그래밍 언어도 존재한다.<br>만약 if ..else문으로 해결 할 수 있다면 switch문 보다 if ..else문을 사용했을때 가독성이 더 좋다. 하지만 if…else 문보다는 switch 문을 사용했을때 더 가독성이 좋다면 switch문을 사용하는 편이 좋다.</p>
<h1 id="3-반복문"><a href="#3-반복문" class="headerlink" title="3. 반복문"></a>3. 반복문</h1><p>반복문은 주어진 조건식의 평가 결과가 참인 경우 코드블럭을 실행한다. 그 후 저건식을 다시 검사하여 여전히 참인 경우 코드블록을 다시 실행한다. 이는 조건식이 거짓일때 까지 반복한다.<br>자바스크립트는 3가지의 반복문 for문 while문 do while문 을 제공한다.<br>반복문을 대체 할 수 있는 다양한 기능 </p>
<p>자바스크립트는 배열을 순회할때 사용하는 forEach 메소드,객체의 프로퍼티를 열거할 때 사용하는 for ..in문 Es6에서 새롭게 이터러블을  순회할 수 있는 for..of문과 같이 반복문을 대체 할 수 있는 다양한 기능을 제공한다.</p>
<h2 id="3-1-for문"><a href="#3-1-for문" class="headerlink" title="3.1. for문"></a>3.1. for문</h2><p>for문은 조건식이 거짓으로 판별 될때 까지 코드 블록을 반복 실행한다. 가장 일반적으로 사용되는 for문의 형태는 다음과 같다. 변수 선언문의 변수이름은 반복을 의미하는 iteration의 i을 사용하는 것이 일반적이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(변수 선언문 또는 할당문;조건식;증감식)&#123;</span><br><span class="line">  조건식이 참인 경우 반복 실행될 문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</span><br><span class="line">  consoel.log(i) <span class="comment">// 0 1 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://poiemaweb.com/assets/fs-images/8-1.png" alt="img"></p>
<p>for문의 변수 선언문,조건식,증감식은 모구 옵션이다. 반드시 사용할 필요는 없다. 어떤식도 선언하지 않으면 무한 루프가 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 루프</span></span><br><span class="line"><span class="keyword">for</span>(;;)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;=<span class="number">6</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j =<span class="number">0</span>;j&lt;=<span class="number">6</span>;j++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i+j === <span class="number">6</span>)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`[<span class="subst">$&#123;i&#125;</span>,<span class="subst">$&#123;j&#125;</span>]`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 결과</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">4</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">5</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<h2 id="3-2-while문"><a href="#3-2-while문" class="headerlink" title="3.2. while문"></a>3.2. while문</h2><p>while문은 주언진 조건식의 평가가 참이면 코드블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이면 실행을 종료한다. 만약 조건식의 평가 결과가 블리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참 거짓을 구별하게 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//count가 3보다 작을 때 까지 코드블록을 계속 반복 실행한다.</span></span><br><span class="line"><span class="keyword">while</span>(count &lt;<span class="number">3</span>)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count); <span class="comment">// 0 1 2 </span></span><br><span class="line">  count++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>조건식의 평가 결과 가 언제나 참이면 무한 루프를 돈다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 루프를 탈출하기 우해서 조건을 만들고 break을 사용하여 탈출한다.</span></span><br><span class="line"> <span class="keyword">var</span> count =<span class="number">0</span>;</span><br><span class="line"><span class="comment">//무한 루프</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  consoel.log(count);</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">//count가 3이면 코들블록을 탈출한다.</span></span><br><span class="line">  <span class="keyword">if</span>(count ===<span class="number">3</span>)<span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">//0 1 2 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-do-while문"><a href="#3-3-do-while문" class="headerlink" title="3.3. do while문"></a>3.3. do while문</h2><p>do…while문은 코드블록을 먼저 실행하고 조건식을 평가한다. 따라서 코드블록은 무조건 한번이상 실행된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counr =<span class="number">0</span>;</span><br><span class="line"><span class="comment">//count가 3보다 작을때 까지 코드블록을 곗고 반복 실행;</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125;<span class="keyword">while</span>(count &lt;<span class="number">3</span>) <span class="comment">//0 1 2;</span></span><br></pre></td></tr></table></figure>

<h1 id="4-break문"><a href="#4-break문" class="headerlink" title="4.  break문"></a>4.  break문</h1><p>switch문과 while문 네서 살펴 보았듯이 break문은 코드 블록을 탈출한다. 좀 더 정확히 말하면 코드블록을 탈출하는 것이 아니라 레이블문 ,반복문(for,for..in,for…of ,while문,do…while문) 또는 switch문의 코드블록을 탈출한다.<br>레이블 문,반복문,switch 문의 코드블록 이외에 break 문을 사용하면 SyntaxError문법에러가 발생한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">  <span class="keyword">break</span>;<span class="comment">// Uncaught SyntaxError: Illegal break statement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>레이블 문(label statement)이란 식별자가 붙은 문을 말한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foo라는 레이블 식별자가 붙은 레이블 문</span></span><br><span class="line">foo: <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br></pre></td></tr></table></figure>

<p>레이블 문은 프로그램의 실행 순서를 제어하기 위햇 사용한다. 사실  switch 문의 case문과 default도 레이블 문이다. 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//foo라는 식별자가 붙은 레이블 블록문</span></span><br><span class="line">foo:&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">break</span> foo;<span class="comment">//foo 레이블 블록문을 탈출한다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Done'</span>);</span><br></pre></td></tr></table></figure>

<p>중첩된 for 문의 내부 for문에서 break문을 실행하면 내부 for문을 탈출하여 외부 for문으로 진입한다. 이때 내부for문이 아닌 외부 for문을 탈출하려면 레이블문을 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//outer라는 식별자가 붙은 레이블 for문</span></span><br><span class="line">outer:<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">    <span class="comment">//i+j === 3 이면 outer라는 식별자가 붙은 레이블 for문을 탈출한다.</span></span><br><span class="line">    <span class="keyword">if</span>( i+j === <span class="number">3</span>) <span class="keyword">break</span> outer;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`inner [<span class="subst">$&#123;i&#125;</span>,<span class="subst">$&#123;j&#125;</span>]`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Done!'</span>);</span><br></pre></td></tr></table></figure>

<p>레이블 문은 중첩된 for문 외부로 탈출할 때 유용하지만 그 외의 경우 레이블 문은 일반적으로 권장 하지않는다. 레이블 문을 사용하면 프로그램의 흐름이 복잡해져서 가독성이 나빠지고 오류를 발생시킬 가능성이 높아지기 때문이다.</p>
<p>break문은 레이블 문 뿐 만이 아니라 반복문,switch문에서도 사용 할 수 있다. 이 경우에는 break문에 레이블 식별자를 지정하지 않는다. break문은 반복문을 더 이상 진행하지 않아도 될때 불필요한 반복을 회피할 수 있어 유용하다.</p>
<p>아래는 문자열에서 특정한 인덱스의 위치를 검색하는 예제이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">'Hello world'</span>;</span><br><span class="line"><span class="keyword">var</span> search = <span class="string">'l'</span>;</span><br><span class="line"><span class="keyword">var</span> index ;</span><br><span class="line"><span class="comment">//문자열은 유사배열이므로 for문으로 순회할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i &lt; string.length;i++)&#123;</span><br><span class="line">  <span class="comment">//문자열의 개별 문자가 'l'이면;</span></span><br><span class="line">  <span class="keyword">if</span>(string[i] === search)&#123;</span><br><span class="line">    index = i;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//반복문은 탈출한다.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(index) <span class="comment">//2;</span></span><br><span class="line"></span><br><span class="line">consoel.log(string.indexOf(search)) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h1 id="5-continue문"><a href="#5-continue문" class="headerlink" title="5. continue문"></a>5. continue문</h1><p>continue문은 반복문의 코드블록 실행 을 현 시점에서 중담하고 반복문의 증감식으로 이동한다. break문처럼 반복문을 탈출하지않는다.<br>문자열에서 특정 문자의 개수를 카운트하는 예제이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">'Hello world'</span>;</span><br><span class="line"><span class="keyword">var</span> search =<span class="string">'l'</span>;</span><br><span class="line"><span class="keyword">var</span> index ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;string.length;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(string [i] !== serach) <span class="keyword">continue</span>;</span><br><span class="line">  <span class="comment">//string[i] === 'l'일때에만 아래의 count++가 실행된다.</span></span><br><span class="line">  <span class="comment">//string[i] !== 'l'일 때에는 for문의 조건의 증감식으로 이동한다.</span></span><br><span class="line">  count++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(count) <span class="comment">//3;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> regexp =<span class="keyword">new</span> <span class="built_in">RegExp</span>(search,<span class="string">'g'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(string.match(regexp).length); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;string.length;i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(string[i] === search)&#123;</span><br><span class="line">    count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 if문 내에서 실행해야 할 코드가 한 줄이라면 continue문을 사용했을때 보다 간편하며 가독성이 좋다. 하지만 if문 내에서 실행할 코드가 길다면 들여쓰기가 한 단계 더 깊어지므로 continue 문을 사용하는 것이 가독성이 더 좋다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// continue 문을 사용하지않으면 if문 내에 코드를 작성해야한다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;string.length;i++)&#123;</span><br><span class="line">  <span class="comment">//'l'이면 카운트를 증가 시킨다.</span></span><br><span class="line">  <span class="keyword">if</span>(string[i] === search)&#123;</span><br><span class="line">    count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//continue 문을 사용하면 id문 밖에 코드를 작성할수있다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;string.length;i++)&#123;</span><br><span class="line">  <span class="comment">//'l'이 아니면 카운트를 증가 시키지 않는다.</span></span><br><span class="line">  <span class="keyword">if</span>( string[i] !== search) <span class="keyword">continue</span>;</span><br><span class="line">  count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>제어문에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>ECMAScript와 Javascript의 차이</title>
    <url>/2020/05/15/ecmascript-and-javascript-md/</url>
    <content><![CDATA[<h1 id="ECMAScript-와-JavaScript"><a href="#ECMAScript-와-JavaScript" class="headerlink" title="ECMAScript  와 JavaScript"></a>ECMAScript  와 JavaScript</h1><p>![image-20200516171849635](/Users/pokeoseu/Library/Application Support/typora-user-images/image-20200516171849635.png)</p>
<p><strong><u>ECMAScript는 자바스크립트의 표준사양인 ECMA-262를 말하며</u></strong> 프로그래밍 언어의 타입 , 값,객체와 프로퍼티,함수,표준 빌트인 객체 등 핵심 문법을 규정한다. 각 브라우저 제조사는 ECAMScript를 준수하여 브라우저에 내장되어있는 자바스크립트 엔진을 구현한다.<br><strong><u>자바스크립트는 일반적으로 프로그래밍 언어</u></strong>로서 기본 뼈대를 이루는 ECMAScript와 브라우저가 별도 지원하는 클라이언트 사이드 WEB API,즉 DOM ,BOM, Canvas ,XMLHttpRequest, Fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker등을 아우르는 개념이다.<br> 즉 Javascript &gt; Ecmascript (자바스크립가 더 큰 개념이다.)<br>클라이언트 사이드 WEB API는 ECMAScript와는 별도로 World Wide Web Consortium(W3C)에서도 별도로 명세로 관리하고 있다.</p>
<p>요약하자면 ECMAScript는 ecma 인터내셔녈에 의해 정의된 ECMA -262 기술규격에 의해 정의된 범용 자바스크립트 언어를 뜻합니다. ‘ECMAScript 사양’입니다.<br>ECMA -262 는 표준의 이름이고, ECMAScript는 ECMA -262에서 정의된 하나의 사양을 의미합니다. ECMAScript는 스크립트언어가 준수해야하는 규칙,세부사항 및 지침을 제공합니다.</p>
<p>JavaScript는 ECMAScript가 사양을 준수하는 범용 스크립트팅 언어 입니다. 자바스크립트느 ECMAScript아우르는 개념입니다..</p>
<p>또한 JavaScripts는 1996년에 반들어 졌고 , 그 다음 해에 JavaScriptd를 표준화하기 위해서 1997년 ECMAScript가 만들어졌습니다. JavaScript는 ECMAScript 사양을 준수하는 언어이며 , JavaScript가  ECMAScript을 기반하는 동시에 ECMAScript도 JavaScript를 기반으로 한다. </p>
]]></content>
      <tags>
        <tag>ECMAScript와 Javascript의 차이</tag>
      </tags>
  </entry>
  <entry>
    <title>제너레이터와 async-await</title>
    <url>/2020/05/05/generator-aync-await-md/</url>
    <content><![CDATA[<h1 id="1-제네레이터"><a href="#1-제네레이터" class="headerlink" title="1.제네레이터"></a>1.제네레이터</h1><p>es6에서 도입된 제너레이터 함수는  이터러블을 생성하는 함수이다. 제너레이터 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편하게 이터러블을 구현 할 수 있다. 또한 제너레이터 함수는 비동기 처리에 유용하게 사용된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//이터레이션 ㅍ,로토콜을 구현하여 무한 이터러블을 생성하는 함수</span></span><br><span class="line"><span class="keyword">const</span> createInfinittbyIteration = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i =<span class="number">0</span>;<span class="comment">//자유 변수</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [<span class="built_in">Symbol</span>.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;,</span><br><span class="line">    next()&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>:++i&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> n <span class="keyword">of</span> createInfinitbyIteration())&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">5</span>)<span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n)<span class="comment">//1 2 3 4 5</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//무한 이터러블을 생성하는 제너레이터 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">createInfinittbyIteration</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i =<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;<span class="keyword">yield</span> ++i;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> n <span class="keyword">of</span> createInfinittbyIteration())&#123;</span><br><span class="line">  <span class="keyword">if</span>(n&gt;<span class="number">5</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(n) <span class="comment">// 1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>제너레이터 함수는 일반 함수와는 다른 독특한 동작을 한다. 제너레이터 함수는 일반 함수와 같이 함수의 코드 블로그을 한번에 실행하지 않고 함수 코드 블록의 실행을 일시 중단했다가 필요한 시점에 재시작 할 수 있는 특수한 함수이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'첫번째 호출'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;								<span class="comment">//첫번째 호출시에 이 지점까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'두 번째 호출'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;								<span class="comment">//두번째 호출 시에 이 지점까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'세번째 호출'</span>)<span class="comment">// 세번째 호출 시에 이 지점까지 실행한다</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());<span class="comment">//첫번째 호출 &#123;value:1,done:false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());<span class="comment">//두번째 호출 &#123;value:2,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());<span class="comment">//세번째 호출 &#123;value:undefined,done:true&#125;;</span></span><br></pre></td></tr></table></figure>

<p>일반 함수를 호출하면 return 문으로 반환값을 리턴하지만 제너레이터 함수를 호출하면 제너레이터를 반환한다. 이 제너레이터는 이터러블이면서 동시에 이터레이터인 객체이다. 다시 말해 제너레이터 함수가 생성한 제너레이터는 Symbol.iterator메소드를 소유한 이터러블이다. 그리고 제너레이터는 next()메소드를 소유하며 next메소드를 호출하면 value,done 프로퍼티를 갖는 이터레이터 객체를 반환하는 이터레이터이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//제너레이터 함수 정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> v <span class="keyword">of</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])<span class="keyword">yield</span> v;</span><br><span class="line">  <span class="comment">//=&gt;yield* [1,2,3];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//제너레이터 함수를 호출하면 제너레이터를 반환한다.</span></span><br><span class="line"><span class="keyword">let</span> generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터는 이터러블이다.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> generatorObj) <span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> i int generatorObj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i)<span class="comment">// 1 2 3 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터는 이터레이터이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'next'</span> <span class="keyword">in</span> generatoroBJ)	<span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:1,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:2,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:3,done:false&#125;;</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next()) <span class="comment">//&#123;value:undefined,done:true&#125;;</span></span><br></pre></td></tr></table></figure>

<h1 id="2-제너레이터-함수의-정의"><a href="#2-제너레이터-함수의-정의" class="headerlink" title="2.제너레이터 함수의 정의"></a>2.제너레이터 함수의 정의</h1><p>제너레이터 함수는 function* 키워드로 선언을 한다. 그리고 하나 이상의 yield문을 포함한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//제너레이터 함수 선언문</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">genDecFunc</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> generatorObj = genDecFunc();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 함수 표현식</span></span><br><span class="line"><span class="keyword">const</span> genExpFunc = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 메소드 </span></span><br><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">  *generatorObjMethod()&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">generatorObj = obj.generatorObjMethod();</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 클래스 메소드</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span>&#123;</span><br><span class="line">  *generatorClsMethod()&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> myClass = <span class="keyword">new</span> MyClass();</span><br><span class="line">generatorObj = myClass.generatorClsMethod();</span><br></pre></td></tr></table></figure>

<h1 id="3-제너리이터-함수의-호출과-제너레이터-객체"><a href="#3-제너리이터-함수의-호출과-제너레이터-객체" class="headerlink" title="3.제너리이터 함수의 호출과 제너레이터 객체"></a>3.제너리이터 함수의 호출과 제너레이터 객체</h1><p>제너레이터 함수를 호출하면 제너레이터 함수의 코드 블록이 실행되는 것이 아니라 제너레이터 객체를 반환한다. 앞에서 살펴본 바와 같이 제너레이터 객체는 이터러블이며 동시에 이터레이터이다. 따라서 next메소드를 호출하기 위해 Symbol.iterator 메소드로 이터레이터를 별도로 생성할 필요가 없다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//제너레이터 함수 정의 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 1'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>; <span class="comment">//첫번째 next메소드 호출시 여기 까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 2'</span>)</span><br><span class="line"> 	<span class="keyword">yield</span> <span class="number">2</span>; <span class="comment">//두번째 next메소드 호출시 여기 까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 3'</span>)</span><br><span class="line"> 	<span class="keyword">yield</span> <span class="number">3</span>; <span class="comment">//세번째 next메소드 호출시 여기 까지 실행된다.</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Point 4'</span>)</span><br><span class="line"> 	</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.</span></span><br><span class="line"><span class="comment">//제너레이터 객체는 이터러블이며 동시에 이터레이터이다.</span></span><br><span class="line">.<span class="comment">//따라서 Symbol.iterator 메소드로 이터레이터를 별도 생성할 필요가 없다.</span></span><br><span class="line"><span class="keyword">const</span> generatorObj = counter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//첫번째 next 메소드 호출:첫번째 yield문까지 실행되고 일시 중단된다.</span></span><br><span class="line"><span class="comment">// Point 1</span></span><br><span class="line"><span class="comment">// &#123;value: 1, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 두번째 next 메소드 호출: 두번째 yield 문까지 실행되고 일시 중단된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());</span><br><span class="line"><span class="comment">// Point 2</span></span><br><span class="line"><span class="comment">// &#123;value: 2, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 세번째 next 메소드 호출: 세번째 yield 문까지 실행되고 일시 중단된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());</span><br><span class="line"><span class="comment">// Point 3</span></span><br><span class="line"><span class="comment">// &#123;value: 3, done: false&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 네번째 next 메소드 호출: 제너레이터 함수 내의 모든 yield 문이 실행되면 done 프로퍼티 값은 true가 된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());</span><br><span class="line"><span class="comment">// Point 4</span></span><br><span class="line"><span class="comment">// &#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>

<p>제너레이터 함수가 생성한 제너레이터 객체의 next메소드를 호출하면 처음만나는 yield문까지 실행되고 실시 중단된다. 또 다시 next메소드를 호출하면 중단된 위치에서 다시 실행이 시작하여 다음 만나는  yieldㅁ누 까지 실행되고 또 다시 일시 중단 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">start -&gt; generatorObj.next() -&gt; <span class="keyword">yield</span> <span class="number">1</span> -&gt; generatorObj.next() -&gt; <span class="keyword">yield</span> <span class="number">2</span> -&gt; ... -&gt; end</span><br></pre></td></tr></table></figure>

<p>next 메소드는 이터레이터 결과 객체와 가티이 value,done이라는 프로퍼티를 갖는 객체를 반환한다.vlaue프로퍼티는 yield문이 실행되었는지를 나타내는 boolean타입의 값이다. 마지막 yield문까지 실행된 상태에서 next메소드를 호출하면 done프로퍼티 값을 true가 된다.</p>
<h1 id="4-제너레이터의-활용"><a href="#4-제너레이터의-활용" class="headerlink" title="4.제너레이터의 활용"></a>4.제너레이터의 활용</h1><h2 id="4-1-이터러블의-구현"><a href="#4-1-이터러블의-구현" class="headerlink" title="4.1. 이터러블의 구현"></a>4.1. 이터러블의 구현</h2><p>제너레이터는 함수를 사용하면 이터레이션 프로토콜을 준수해 이터러블을 생성하는 방식보다 간편하게 이터러블을 구현할 수 있다. 이터레이션 프로토콜을 준수하여 무한 피보나치 수열을 생성하는 함수를 구현해 보겠다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 이터러블을 생성하는 함수</span></span><br><span class="line"><span class="keyword">const</span> infinityFibonacci =(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [pre,cur] =[<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    [sYMBOL.iterator]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>;&#125;,</span><br><span class="line">    next()&#123;</span><br><span class="line">      [pre,cur] = [cur,pre+cur];</span><br><span class="line">      <span class="comment">//done프로퍼티를 생략한다.</span></span><br><span class="line">      <span class="keyword">return</span> &#123;<span class="attr">value</span>:cur&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//infinityFibonacci는 무한 이터러블이다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> infinityFibonacci)&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">10000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(num) <span class="comment">//1 2 3 5 8..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이터레이션 프로토콜을 보다 간단하게 처리하기 위해 제너레이터를 활용할 수 있다. 제너레이터는 활용하여 무한 피보나치수열을 구현한 이터러블을 만들어보자.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 이터러블틀 생성하는 제너레이터 함수</span></span><br><span class="line"><span class="keyword">const</span> infinityFibonacci =(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">let</span> [pre,cur] = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    [pre,cur] = [cur,pre+cur];</span><br><span class="line">    <span class="keyword">yield</span> cur;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">//infinityFibonacci는 무한 이터러블이다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> infinityFibonacci)&#123;</span><br><span class="line">  <span class="keyword">if</span>(num &gt;<span class="number">10000</span>) <span class="keyword">break</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>제너레이터 함수에 최대값을 인수를 전달해보자</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//무한 이터러블을 생성하는 제너레이터 함수</span></span><br><span class="line"><span class="keyword">const</span> createInfiniteFibByGen =<span class="function"><span class="keyword">function</span>* (<span class="params">max</span>)</span>&#123;</span><br><span class="line">  	<span class="keyword">let</span> [prec,curr] = [<span class="number">0</span>,<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    [prev,curr] =[curr,prev+curr];</span><br><span class="line">    <span class="keyword">if</span>(curr &gt;= max)<span class="keyword">return</span><span class="comment">//제너레이터 함수 종료</span></span><br><span class="line">    <span class="keyword">yield</span> curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> createInfiniteFibByGen(<span class="number">10000</span>))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이터레이터의 next메소드와 다르게 제너레이터 객체의next메소드에는 인수를 전달할 수도 있다. 이를 통해서 제너레이터 객체에 데이터를 전달 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> res;</span><br><span class="line">  res = <span class="keyword">yield</span> n <span class="comment">//n:0&lt;= gen함수에 전달한 인수</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//res:1 &lt;= 두번째 next 호출 시 전달한 데이터</span></span><br><span class="line">  res = <span class="keyword">yield</span> res;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(res) <span class="comment">//res:2 &lt;= 세번째 next 호출 시 전달한 데이터</span></span><br><span class="line">  res = <span class="keyword">yield</span> res;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// res: 3 ⟸ 네번째 next 호출 시 전달한 데이터</span></span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> generatorObj = gen(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next());  <span class="comment">// 제너레이터 함수 시작</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next(<span class="number">1</span>)); <span class="comment">// 제너레이터 객체에 1 전달</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next(<span class="number">2</span>)); <span class="comment">// 제너레이터 객체에 2 전달</span></span><br><span class="line"><span class="built_in">console</span>.log(generatorObj.next(<span class="number">3</span>)); <span class="comment">// 제너레이터 객체에 3 전달</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">&#123; value: 0, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 1, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 2, done: false &#125;</span></span><br><span class="line"><span class="comment">&#123; value: 3, done: true &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>이터레이터의 next메소드는 이터러블의 데이터를 꺼내 온다. 이에 반해 제너레이터의 next메소드에 인수를 전달하면 제너레이터 객체에 데이터를 밀어 넣는 다. 제너레이터의 이런 특성은 동시성 프로그래밍을 가능케 한다.</p>
<h1 id="4-비동기-처리"><a href="#4-비동기-처리" class="headerlink" title="4.비동기 처리"></a>4.비동기 처리</h1><p> 제너레이터를 사용해 비동기 처리를 동기 처리처럼 구현할 수 있다. 다시말해 비동기 처리 함수가 처리 결과를 반환하도록 구현할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params">genObj,username</span>)</span>&#123;</span><br><span class="line">  fetch(<span class="string">`https://api.github.com/users/<span class="subst">$&#123;username&#125;</span>`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span>res.json())</span><br><span class="line">  <span class="comment">//1.제너레이터 객체에 비동기 처리 결과를 전달한다.</span></span><br><span class="line">  .then(<span class="function"><span class="params">user</span>=&gt;</span> genObj.next(user.name));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//제너레이터 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> g =(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> user;</span><br><span class="line">  <span class="comment">//2.비동기 처리 함수가 결과를 반환한다.</span></span><br><span class="line">  <span class="comment">//비동기 처리의 숭성가 보장된다.</span></span><br><span class="line">  user = <span class="keyword">yield</span> getUser(g,<span class="string">'kim'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user); <span class="comment">//</span></span><br><span class="line">  </span><br><span class="line">  user =<span class="keyword">yield</span> getUser(g,<span class="string">'lee'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">  </span><br><span class="line">  user = <span class="keyword">yield</span> getUser(g,<span class="string">'park'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">//제너레이터 함수 시작</span></span><br><span class="line">g.next();</span><br></pre></td></tr></table></figure>

<p>1.비동기 처리가 완료되면 next메소드를 통해 제너레이터 객체에 비동기 처리 결과를 전달한다.<br>2.제너레이터 객체에 전달된 비동기 처리 결과는 user 변수에 할당한다.<br>제너레이터를 통해 비동기 처리를 동기 처럼 구현 할 수 있으나 코드는 장황해졌다. 따라서 좀더 간편하게 비동기 처리를 구현할 수있는 async/await가 es7에 도입되었다.</p>
<p><strong>async -await 을 통한 비동기 처리</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fetch = <span class="built_in">require</span>(<span class="string">'node-fetch'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Promise을 반환하는 함수정의</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUsers</span>(<span class="params">username</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fetch(<span class="string">`https://api.github.com/users/<span class="subst">$&#123;username&#125;</span>`</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span>=&gt;</span>res.json())</span><br><span class="line">  .then(<span class="function"><span class="params">user</span> =&gt;</span>user.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">async</span> fucntion getUsersAll()&#123;</span><br><span class="line">  <span class="keyword">let</span> user;</span><br><span class="line">  user = <span class="keyword">await</span> getUsers(<span class="string">'kim'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">  </span><br><span class="line">  user = <span class="keyword">await</span> getUsers(<span class="string">'park'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">  </span><br><span class="line">  user = <span class="keyword">await</span> getUsers(<span class="string">'lee'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(user);</span><br><span class="line">&#125;</span><br><span class="line">getUsersAll();</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>제어레이터와 async-await에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>let과 const 블록 레벨스코프</title>
    <url>/2020/05/09/letconst-md/</url>
    <content><![CDATA[<h1 id="1-var키워드로-선언한-변수의-문제점"><a href="#1-var키워드로-선언한-변수의-문제점" class="headerlink" title="1. var키워드로 선언한 변수의 문제점"></a>1. var키워드로 선언한 변수의 문제점</h1><h2 id="1-1-변수-중복-선언이-가능"><a href="#1-1-변수-중복-선언이-가능" class="headerlink" title="1.1.변수 중복 선언이 가능"></a>1.1.변수 중복 선언이 가능</h2><p>-변수의 중복 선언이 가능하고,이때문에 의도치 않은 값의 변경이 일어나는 부작용이 발생한다.</p>
<h2 id="1-2-함수레벨-스코프"><a href="#1-2-함수레벨-스코프" class="headerlink" title="1.2, 함수레벨 스코프"></a>1.2, 함수레벨 스코프</h2><p>var키워드로 선언한 변수는 오로지 함수의 코드블록만을 지역스코프로 인정한다. 따라서 외부에서 선언한 변수는 모두 전역변수가 된다. 함수레벨 스코프는 전역변수를 남발할 가능성이 높다. 이로인해 의도치 않은 전역변수가 중복되는 경우가 발생한다.</p>
<h2 id="1-3-변수의-호이스팅"><a href="#1-3-변수의-호이스팅" class="headerlink" title="1.3. 변수의 호이스팅"></a>1.3. 변수의 호이스팅</h2><p>변수ㅣ 호이스팅에 의해 선언문이 스코프를 선두로 끌어 올려진것 처럼 동작한다. 즉 변수 호이스팅에 의해 var키워드로 선언한 변수는 변수 선언문 이전에 참조할 수있다. 단 할당문 이전에 변수를  참조하면 언제나 undefined를 반환한다. 변수호이스팅은 가독성을 떨어뜨리고 오류를 발생시킬 수있는 여지를 만든다.</p>
<hr>

<h1 id="2-let키워드"><a href="#2-let키워드" class="headerlink" title="2.let키워드"></a>2.let키워드</h1><p>let은 키워드는 var키워드와 동일하게 변수를 선언할때 사용한다. var키워드와의 차이점은</p>
<h2 id="2-1-변수의-중복선언-금지"><a href="#2-1-변수의-중복선언-금지" class="headerlink" title="2.1. 변수의 중복선언 금지"></a>2.1. 변수의 중복선언 금지</h2><p>var 키워드로 선언한 변수를 중복선언하면 에러가 발생하지 않고 덮어씌어진다. 하지만 let키워드로 동일한 이름을 갖는 변수를 중복선언하면 문법에러가 발생한다.<br> let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.</p>
<h2 id="2-2-블록-레벨-스코프"><a href="#2-2-블록-레벨-스코프" class="headerlink" title="2.2. 블록 레벨 스코프"></a>2.2. 블록 레벨 스코프</h2><p>var키워드롤 선언한 변수는 오로지 함수의코드블록을 지역변수로 인정하는 함수레벨 스코프를 따랐다. 하지만 let 키워드로 선언한 변수는 모든 코드블록에(if/for/while/try/catch)을 지역 스코프로 인정하는 블록레벨 스코프를 따른다.</p>
<p>함수도 코드블록이므로 스코프를 만든다. 이때 함수 내의 코드 블록은 함수레벨 스코프에 중첩된다.</p>
<h2 id="2-3-변수의-호이스팅"><a href="#2-3-변수의-호이스팅" class="headerlink" title="2.3. 변수의 호이스팅"></a>2.3. 변수의 호이스팅</h2><p>var키워드와는 달리 let키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는것 처럼 동작한다.<br> var 키워드를 사용해 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해서 암묵적으로 선언단계와 초기화 단계를 한번에 진행한다.<br>그러나 let  키워드를 사용해 선언한 변수는 자바스크립트엔진이 선언단계와 초기화 단계가 분리되어 실행된다. 즉 런타임 이전에 자바스크립트 엔진에 의해서 암묵적으로 선언단계가 실행되지만 초기화단계는 변수선언문에 도달했을때 실행된다.<br>스코프의 시작지점부터 초기화 시작 지점까지의 구간을 <strong>일시적 사각사각지대</strong>라고 한다.<br>자바스크립트에 도입된 모든 선언들은 호이스팅한다.(var.let,const,function,class)</p>
<h2 id="2-4-전역객체와-let"><a href="#2-4-전역객체와-let" class="headerlink" title="2.4. 전역객체와  let"></a>2.4. 전역객체와  let</h2><p>전역객체는 어떤 객체보다도 먼저 생성되어 어떤객체에도 속하지 않은 최상위 객체이다. 일반적으로 브라우저 환경에서는 window객체,node.js환경에서는 global객체를 의미한다.<br>var키워드로 선언한 전역변수와 선언하지 않은 변수에 전역값을 할당하는 암묵적 번역변수 그리고 전역함수는 정겨 객체릐 프로퍼티가 된다. 전역깩체의 프로퍼티를 참조할때 window응 생략 할 수있따.</p>
<p><strong>let키워드로 선언한 전역변수는 전역객체 window의 프로퍼티가 아니다</strong>. <strong>즉window.foo와 같이 접근 할 수없다.</strong>let전역변수는 보이지 않는 개념적인 블록내에 존재 하게 된다.</p>
<hr>

<h1 id="3-const키워드"><a href="#3-const키워드" class="headerlink" title="3. const키워드"></a>3. const키워드</h1><p>const키워드는 상수(변하지 않는 고정된 값)를 선언하기 위해 사용한다. 하지만 반드시 상수 만을 위해 사용하지 않는다. </p>
<h2 id="3-1-선언과-초기화"><a href="#3-1-선언과-초기화" class="headerlink" title="3.1 선언과 초기화"></a>3.1 선언과 초기화</h2><p>let키워들 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할다잉 금지된다. const키워드로 선언한 변수는 값을 변경,재할당 할 수 없으므로 처음 할당한 갓을 그대로 유지한다. 따라서 변하지 않는 고정된 값,상수를 할당하기 위해사용한다.</p>
<p>cost키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야한다.그렇지 않으면 문법적인 에러가 발생한다.</p>
<p>const키워드로 let키워드와ㅏ 마찬가지로 블록 레벨 스코프를 가진다.</p>
<h2 id="3-2-상수"><a href="#3-2-상수" class="headerlink" title="3.2. 상수"></a>3.2. 상수</h2><p>상수는 가독성과 유지보수의 편의를 위해 적극적으로 사용해야한다.</p>
<p>상수를 값으로 갖는 변수는 일반적으로 변수이름을 대문자로 선언하고 상수가 저장되어있음을 명확하게 나타낸다. 여러 단어로 이루어진 경우 _로 구분을 하는 것이 일반적이다.</p>
<h2 id="3-3-const키워드와-객체"><a href="#3-3-const키워드와-객체" class="headerlink" title="3.3. const키워드와 객체"></a>3.3. const키워드와 객체</h2><p>const키워드로 선언된 변수는 재할당이 금지된다. const키워드로 선언된 변수에 원시값을 할당한 경우,원시값은 변경할 수 없는 값이고,const키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다.</p>
<p>const키워드로 선언한 변수에 깩체를 할당하는 경우, 원시값을 할당한 경우와 마찬가지로 재할당이 금지된다. 그러나 객체는 변경가능한 값이다.따라서 const 키워드로 선언된 변수에 할당된 객체는 변경이 가능하다.</p>
<p>const키워드는 재할당을 금지할뿐 불변을 의미하지 않는다. 새로운 객체를 재할당하는 것은 불가능하지만 객체의 내용을 변경하는 것은 가능하다.객체의 내용이 변경되더라도 변수에 할당된 주소값은 변경되지않는다.</p>
<hr>

<h1 id="4-var-대-let-대-const"><a href="#4-var-대-let-대-const" class="headerlink" title="4. var 대 let 대 const"></a>4. var 대 let 대 const</h1><p>변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해서 사용하는 것이 좋다. 원시값의 경우,가급적 상수를 사용하는 것이 좋다. 그리고 객체를 재할당하는 경우는 생각보다 흔하지않다. const 키워드를 사용하면 의도치 않은 재할당을 방지해주기때문이다.</p>
<p>es6에서는 var을 사용하지않는다.<br>재할당이 필요한경우에는 한정해 letd을 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.<br>변경이 발생하지않는(재할당이 필요없는 상수)원시값과 객체에는 const키워드를 사용한다. const키워드는 재할당을 금지하므로 var,let보다 안전하다.</p>
<p>변수를 선언하는 시점에는 재할다잉 필요할지 잘 모르는 경우가 많다. 그리고 객체는 의외로 재할당하는 경우가 드물다. 따라서 변수를 선언할때 일단 const 키워드로 사용하도록하자 .반드시 재할당이 필요하다면 그때 const를 let으로 변경하면 된다.</p>
]]></content>
      <tags>
        <tag>let과 const 블록레벨 스코프에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>자바스크립트의 개발환경</title>
    <url>/2020/05/10/review3-md/</url>
    <content><![CDATA[<h2 id="1-자바스크립트-실행환경"><a href="#1-자바스크립트-실행환경" class="headerlink" title="1. 자바스크립트 실행환경"></a>1. 자바스크립트 실행환경</h2><hr>

<p>모든 브라우저는 자바스크립트를 해석하고 실행할 수 있는 자바스크립트 엔진을 내장하고 있다. node.js  또한 자바스크립트엔진을 내장하고 있으며, 자바스크립트는 nodejs 와 브라우저환경에서 실행 할 수 있다.<br>브라우저에서  자바스크립트의 목적은 html,css,자바스크립트를 실행하여 웹에 보여주는 것이 주된 목적이고,  node.js는 서버 개발 환경을 제공하는 목적을 가진다.<br>또한 모두 자바스크립트의 코어인 ECMAScript를 실행할 수 있지만 ECMAScript의 추가적으로 제공하는 기능은 호환 불가능하다.<br>브라우저에서는 DOM API를 기본적으로 제공하지만 , node.js 에서는 DOM API를 제공하지 않는다.</p>
<h2 id="2-웹"><a href="#2-웹" class="headerlink" title="2. 웹"></a>2. 웹</h2><hr>

<p>자바스크립트가 가장 많이 사용되는 분야는 웹페이지와 웹 애플리케이션이다. 웹 애플리케이션은 웹 브라우저 에서 html과css와 자바스크립트가  함께 실행된다.</p>
<p>웹 브라우저 환경을 고려할 때, 보다 효율적인 자바스크립트 프로그래밍이 가능하다.<br>자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리를 한다,html파서는 script태그를 만나면 자바 스크립트 코드를 실행하기 위해서 DOM생성 프로세스를 중지하고 자바 스크립트 엔진으로 제어권한을 넘긴다.제어 권한을 넘겨받은 자바 스크립트엔진은 script태그의 자바스크립트 파일을 파싱한다. </p>
<p>자바스크립트는 명시적인 컴파일러 단계를 거치지 않지만 인터프리터 언어의 장점인 동적기능지원을 살리면서 실행속도가 느리다는 단점을 극복한다.</p>
<p>head 요소 내부에 script 태그를 위치시키면 HTML 요소가 파싱되어 DOM 객체로 변환되기 이전에 자바스크립트가 실행된다. 따라서 body태그 아래에 script태그를 두는것이 바람직하다.</p>
<p><strong>async</strong> : 웹 페이지 파싱과 외부 스크립트 파일의 다운로드가 동시에 진행된다. 스크립트는 다운로드 완료직후 실행된다.<br><strong>defer</strong> : 웹페이지 파싱과 외부 스크립트 파일의 다운로드가 동시에 진행된다.스크립트는 웹페이지 파싱완료 직후 실행된다. 두개의 차이점은 스크립트의 실행 시점이다르다.</p>
<p> 어트리뷰트는 스크립트 로딩으로 인한 병목을 근본적으로 방지하기 위해서 html5부터 script태그에 추가되었다.</p>
<p>node.js는 클라이언트 사이드, 즉 웹 브라우저에서 동작하는 간단한 웹 애플리케이션은 브라우저만으로도 개발을 할 수 있다.<br>하지만 프로젝트의 규모가 커짐에 따라 React, jQuery와 같은 외부 라이브러리를 도입하거나 Babel, Webpack, ESLint 등 여러 가지 도구를 사용해야 할 필요가 있다. 이때 Node.js와 npm이 필요하다.</p>
]]></content>
      <tags>
        <tag>자바스크립트의 개발환경</tag>
      </tags>
  </entry>
  <entry>
    <title>Set 과 Map</title>
    <url>/2020/05/04/setandmap-md/</url>
    <content><![CDATA[<h1 id="1-Set"><a href="#1-Set" class="headerlink" title="1. Set"></a>1. Set</h1><p>Set 객체는 중복되지 않는 유일한 값들의 집합(set)이다. Set 객체는 배열과 유사하지만 아래와 같은 점에서 차이가 있다.</p>
<table>
<thead>
<tr>
<th align="left">구분</th>
<th align="center">배열</th>
<th align="center">Set 객체</th>
</tr>
</thead>
<tbody><tr>
<td align="left">동일한 값을 중복하여 포함</td>
<td align="center">○</td>
<td align="center">✕</td>
</tr>
<tr>
<td align="left">요소 순서의 의미</td>
<td align="center">○</td>
<td align="center">✕</td>
</tr>
<tr>
<td align="left">인덱스로 요소에 접근</td>
<td align="center">○</td>
<td align="center">✕</td>
</tr>
</tbody></table>
<p>이러한 Set 객체의 특성은 <a href="https://ko.wikipedia.org/wiki/집합" target="_blank" rel="noopener">수학적 집합</a>의 특성과 일치한다. Set은 수학적 집합을 구현하기 위한 자료 구조이다. Set을 통해 교집합, 합집합, 차집합, 여집합 등을 구현할 수 있다.</p>
<h2 id="1-1-Set-객체의-생성"><a href="#1-1-Set-객체의-생성" class="headerlink" title="1.1. Set 객체의 생성"></a>1.1. Set 객체의 생성</h2><p>Set 객체는 Set 생성자 함수로 생성한다. Set 생성자 함수에 인수를 전달하지 않으면 빈 Set 객체가 생성된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(0) &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>Set 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성한다. 이때 이터러블의 중복된 값은 Set 객체에 요소로 저장되지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> set1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(set1); <span class="comment">// Set(3) &#123;1, 2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set2 = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(set2); <span class="comment">// Set(4) &#123;"h", "e", "l", "o"&#125;</span></span><br></pre></td></tr></table></figure>

<p>중복을 허용하지 않는 Set 객체의 특성을 활용하여 배열에서 중복된 요소를 제거할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 배열의 중복 요소 제거</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> array.filter(<span class="function">(<span class="params">v, i, self</span>) =&gt;</span> self.indexOf(v) === i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniq([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [2, 1, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set을 사용한 배열의 중복 요소 제거</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniq</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(array)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniq([<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>])); <span class="comment">// [2, 1, 3, 4]</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-요소-개수-확인"><a href="#1-2-요소-개수-확인" class="headerlink" title="1.2. 요소 개수 확인"></a>1.2. 요소 개수 확인</h2><p>Set 객체의 요소 개수를 확인할 때는 Set.prototype.size 프로퍼티를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(3) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>.size); // 3</span><br></pre></td></tr></table></figure>

<p>Set.prototype.size 프로퍼티는 setter 함수없이 getter 함수만 존재하는 접근자 프로퍼티이다. 따라서 Set.prototype.size 프로퍼티에 숫자를 할당하여 Set 객체의 요소 개수를 변경할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(Set.prototype, 'size'));</span><br><span class="line">// &#123;<span class="keyword">set</span>: undefined, enumerable: false, configurable: true, <span class="keyword">get</span>: ƒ&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.size = 10; // 무시된다.</span><br><span class="line">console.log(<span class="keyword">set</span>.size); // 3</span><br></pre></td></tr></table></figure>

<h2 id="1-3-요소-추가"><a href="#1-3-요소-추가" class="headerlink" title="1.3. 요소 추가"></a>1.3. 요소 추가</h2><p>Set 객체에 요소를 추가할 때는 Set.prototype.add 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(0) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(1) &#123;<span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set.prototype.add 메소드는 새로운 요소가 추가된 Set 객체를 반환한다. 따라서 연속적으로 Set.prototype.add 메소드를 호출할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1).add(2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set 객체에 중복된 요소의 추가는 허용되지 않는다. 단, 이때 에러가 발생하지는 않고 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.add(1).add(2).add(2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>일치 비교 연산자 <code>===</code>을 사용하면 NaN과 NaN을 다르다고 평가한다.(“7.3.1. 동등/일치 비교 연산자” 참고) 하지만 Set 객체는 NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다. 또한 일치 비교 연산자 <code>===</code>와 마찬가지로 +0과 -0도 같다고 평가하여 중복 추가를 허용하지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line">console.log(NaN === NaN); // false</span><br><span class="line">console.log(0 === -0); // true</span><br><span class="line"></span><br><span class="line">// NaN과 NaN을 같다고 평가하여 중복 추가를 허용하지 않는다.</span><br><span class="line"><span class="keyword">set</span>.add(NaN).add(NaN);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(1) &#123;<span class="literal">NaN</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// +0과 -0을 같다고 평가하여 중복 추가를 허용하지 않는다.</span></span><br><span class="line"><span class="keyword">set</span>.add(0).add(-0);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="literal">NaN</span>, <span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set 객체는 자바스크립트의 모든 값을 요소로 저장할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set();</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span></span><br><span class="line">  .add(1)</span><br><span class="line">  .add('a')</span><br><span class="line">  .add(true)</span><br><span class="line">  .add(undefined)</span><br><span class="line">  .add(null)</span><br><span class="line">  .add(&#123;&#125;)</span><br><span class="line">  .add([]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">set</span>); // Set(7) &#123;<span class="number">1</span>, <span class="string">"a"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, &#123;&#125;, []&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-4-요소-존재-여부-확인"><a href="#1-4-요소-존재-여부-확인" class="headerlink" title="1.4. 요소 존재 여부 확인"></a>1.4. 요소 존재 여부 확인</h2><p>Set 객체에 특정 요소가 존재하는지 확인하려면 Set.prototype.has 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">console.log(<span class="keyword">set</span>.has(2)); // true</span><br><span class="line">console.log(<span class="keyword">set</span>.has(4)); // false</span><br></pre></td></tr></table></figure>

<h2 id="1-5-요소-삭제"><a href="#1-5-요소-삭제" class="headerlink" title="1.5. 요소 삭제"></a>1.5. 요소 삭제</h2><p>Set 객체의 요소를 삭제할 때는 Set.prototype.delete 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 요소 2를 삭제한다.</span><br><span class="line"><span class="keyword">set</span>.delete(2);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(2) &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 요소 1을 삭제한다.</span></span><br><span class="line"><span class="keyword">set</span>.delete(1);</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(1) &#123;<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set.prototype.delete 메소드에는 인덱스가 아니라 삭제하려는 요소값을 전달하여야 한다. Set 객체는 순서에 의미가 없다. 다시 말해 배열과 같이 인덱스를 갖지 않는다.</p>
<p>만약 존재하지 않는 Set 객체의 요소를 삭제하려하면 에러없이 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// 존재하지 않는 요소 0를 삭제한다.</span><br><span class="line"><span class="keyword">set</span>.delete(0); // 무시된다</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(3) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure>

<p>Set.prototype.delete 메소드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다. 따라서 Set.prototype.add 메소드와 같이 연속적으로 호출할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// delete는 불리언 값을 반환한다.</span><br><span class="line"><span class="keyword">set</span>.delete(1).delete(2); // TypeError: <span class="keyword">set</span>.delete(...).delete is not a function</span><br></pre></td></tr></table></figure>

<h2 id="1-6-요소-일괄-삭제"><a href="#1-6-요소-일괄-삭제" class="headerlink" title="1.6. 요소 일괄 삭제"></a>1.6. 요소 일괄 삭제</h2><p>Set 객체의 요소를 일괄 삭제할 때는 Set.prototype.clear 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.clear();</span><br><span class="line">console.log(<span class="keyword">set</span>); // Set(0) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-7-요소-순회"><a href="#1-7-요소-순회" class="headerlink" title="1.7. 요소 순회"></a>1.7. 요소 순회</h2><p>Set 객체의 요소를 순회할 때는 Set.prototype.forEach 메소드를 사용한다. Set.prototype.forEach 메소드는 Array.prototype.forEach 메소드와 유사하게 콜백함수와 forEach 메소드 내부에서 this로 사용될 객체(옵션)를 전달한다. 이때 콜백함수는 아래와 같이 3개의 인수를 전달받는디.</p>
<ul>
<li>첫번재 인수 : 현재 순회중인 요소값</li>
<li>두번재 인수 : 현재 순회중인 요소값</li>
<li>세번재 인수 : 현재 순회중인 Set 객체(this)</li>
</ul>
<p>첫번재 인수와 두번재 인수는 같은 값이다. 이처럼 동작하는 이유는 Array.prototype.forEach 메소드와 인터페이스를 통일하기 위함으로 다른 의미는 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.forEach((v, v2, <span class="keyword">set</span>) =&gt; console.log(v, v2, <span class="keyword">set</span>));</span><br><span class="line">/*</span><br><span class="line">1 1 Set(3) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">2</span> <span class="number">2</span> <span class="built_in">Set</span>(<span class="number">3</span>) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="built_in">Set</span>(<span class="number">3</span>) &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">*<span class="regexp">/</span></span><br></pre></td></tr></table></figure>

<p><strong>Set 객체는 이터러블이다</strong>. 따라서 for…of문으로 순회할 수 있으며 스프레드 문법의 대상이 될 수도 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1, 2, 3]);</span><br><span class="line"></span><br><span class="line">// Set 객체는 Set.prototype의 Symbol.iterator 메소드를 상속받는 이터러블이다.</span><br><span class="line">console.log(Symbol.iterator in <span class="keyword">set</span>); // true</span><br><span class="line"></span><br><span class="line">// 이터러블인 Set 객체는 for...of 문으로 순회할 수 있다.</span><br><span class="line">for (const value of <span class="keyword">set</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이터러블인 Set 객체는 스프레드 문법의 대상이 될 수 있다.</span></span><br><span class="line"><span class="built_in">console</span>.log([...set]); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>Set 객체는 요소의 순서에 의미를 갖지 않지만 Set 객체를 순회하는 순서는 요소가 추가된 순서를 따른다. 이는 ECMAScript 사양에 규정되어 있지는 않지만 다른 이터러블의 순회와 호환성을 유지하기 위함이다.</p>
<h2 id="1-8-집합-연산"><a href="#1-8-집합-연산" class="headerlink" title="1.8. 집합 연산"></a>1.8. 집합 연산</h2><p>Set은 수학적 집합을 구현하기 위한 자료 구조이다. Set을 통해 교집합, 합집합, 차집합 등을 구현할 수 있다. 이들 프로토타입 메소드를 구현하면 아래와 같다.</p>
<h3 id="1-8-1-교집합"><a href="#1-8-1-교집합" class="headerlink" title="1.8.1. 교집합"></a>1.8.1. 교집합</h3><p>교집합(A∩B)은 집합 A와 집합 B의 공통 요소로 구성된다</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.intersection = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="comment">// 2개의 set의 요소가 공통되는 요소이면 교집합의 대상이다.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.has(value)) result.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA와 setB의 교집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.intersection(setB)); <span class="comment">// Set(2) &#123;2, 4&#125;</span></span><br><span class="line"><span class="comment">// setB와 setA의 교집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.intersection(setA)); <span class="comment">// Set(2) &#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.intersection = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...this].filter(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">set</span>.has(v)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const setA = new Set([1, 2, 3, 4]);</span><br><span class="line">const setB = new Set([2, 4]);</span><br><span class="line"></span><br><span class="line">// setA와 setB의 교집합</span><br><span class="line">console.log(setA.intersection(setB)); // Set(2) &#123;<span class="number">2</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="comment">// setB와 setA의 교집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.intersection(setA)); <span class="comment">// Set(2) &#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-2-합집합"><a href="#1-8-2-합집합" class="headerlink" title="1.8.2. 합집합"></a>1.8.2. 합집합</h3><p>합집합(A∪B)은 집합 A와 집합 B의 중복없는 모든 요소로 구성된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.union = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this(Set 객체)를 복사</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="comment">// 합집합은 2개의 Set 객체의 모든 요소로 구성된 집합이다. 중복된 요소는 포함되지 않는다.</span></span><br><span class="line">    result.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA와 setB의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.union(setB)); <span class="comment">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// setB와 setA의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.union(setA)); <span class="comment">// Set(4) &#123;2, 4, 1, 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.union = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...this, ...set]);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA와 setB의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.union(setB)); <span class="comment">// Set(4) &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"><span class="comment">// setB와 setA의 합집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.union(setA)); <span class="comment">// Set(4) &#123;2, 4, 1, 3&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-3-차집합"><a href="#1-8-3-차집합" class="headerlink" title="1.8.3. 차집합"></a>1.8.3. 차집합</h3><p>차집합(A-B)은 집합 A에는 존재하지만 집합 B에는 존재하지 않는 요소들의 집합이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.difference = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// this(Set 객체)를 복사</span></span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">new</span> <span class="built_in">Set</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="keyword">set</span>) &#123;</span><br><span class="line">    <span class="comment">// 차집합은 어느 한쪽 집합에는 존재하지만 다른 한쪽 집합에는 존재하지 않는 요소로 구성된 집합이다.</span></span><br><span class="line">    result.delete(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA에 대한 setB의 차집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.difference(setB)); <span class="comment">// Set(2) &#123;1, 3&#125;</span></span><br><span class="line"><span class="comment">// setB에 대한 setA의 차집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.difference(setA)); <span class="comment">// Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set</span>.prototype.difference = <span class="function"><span class="keyword">function</span> (<span class="params">set</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>([...this].filter(<span class="function"><span class="params">v</span> =&gt;</span> !<span class="keyword">set</span>.has(v)));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const setA = new Set([1, 2, 3, 4]);</span><br><span class="line">const setB = new Set([2, 4]);</span><br><span class="line"></span><br><span class="line">// setA에 대한 setB의 차집합</span><br><span class="line">console.log(setA.difference(setB)); // Set(2) &#123;<span class="number">1</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// setB에 대한 setA의 차집합</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.difference(setA)); <span class="comment">// Set(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-4-부분-집합과-상위-집합"><a href="#1-8-4-부분-집합과-상위-집합" class="headerlink" title="1.8.4. 부분 집합과 상위 집합"></a>1.8.4. 부분 집합과 상위 집합</h3><p>집합 A가 집합 B에 포함되는 경우(A⊆B), 집합 A는 집합 B의 부분 집합이며 집합 B는 집합 A의 상위 집합이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this가 subset의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.isSuperset = <span class="function"><span class="keyword">function</span> (<span class="params">subset</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> subset) &#123;</span><br><span class="line">    <span class="comment">// superset의 모든 요소가 subset의 모든 요소를 포함하는지 확인</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.has(value)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA가 setB의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.isSuperset(setB)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// setB가 setA의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.isSuperset(setA)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>또는 아래와 같은 방법으로도 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// this가 subset의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">Set</span>.prototype.isSuperset = <span class="function"><span class="keyword">function</span> (<span class="params">subset</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> supersetArr = [...this];</span><br><span class="line">  <span class="keyword">return</span> [...subset].every(<span class="function"><span class="params">v</span> =&gt;</span> supersetArr.includes(v));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setA = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line"><span class="keyword">const</span> setB = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">2</span>, <span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// setA가 setB의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setA.isSuperset(setB)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// setB가 setA의 상위 집합인지 확인한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(setB.isSuperset(setA)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h1><p>Map 객체는 키와 쌍으로 이루어진 컬렉션이다.   Map객체는 객체와 유사하지만 다음과같은 차이점이 있다.</p>
<table>
<thead>
<tr>
<th align="center">구분</th>
<th align="center">객체</th>
<th align="center">Map객체</th>
</tr>
</thead>
<tbody><tr>
<td align="center">키로 사용할수있는 값</td>
<td align="center">문자열 또는 심볼 값</td>
<td align="center">객체를 포함하는 모든 값</td>
</tr>
<tr>
<td align="center">이터러블</td>
<td align="center">X</td>
<td align="center">O</td>
</tr>
<tr>
<td align="center">크기확인</td>
<td align="center">Object.keys(obj).length</td>
<td align="center">map.size</td>
</tr>
</tbody></table>
<h3 id="2-1-Map-객체의-생성"><a href="#2-1-Map-객체의-생성" class="headerlink" title="2.1 Map 객체의 생성"></a>2.1 Map 객체의 생성</h3><p>Map 객체는 Map 생성자 함수로 생성한다. Map 생성자 함수에 인수를 전달하지않으면 빈 Map객체가 생성된다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>Map 생성자 함수는 이터러블을 인수로 전달 받아 Map객체를 생성한다. 이때 인수로 전달 되는 이터러블은 키와 값의 쌍으로 이루어진 요소로 구성이 되어야한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>,<span class="string">'value1'</span>],[<span class="string">'key1'</span>,<span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map1) <span class="comment">//Map(2) &#123;'lkey1=&gt;'value'm'key2'=&gt;'value2'&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map2 = <span class="keyword">new</span> <span class="built_in">Map</span>([<span class="number">1</span>,<span class="number">2</span>]);</span><br><span class="line"><span class="comment">// TypeError: Iterator value 1 is not an entry object</span></span><br></pre></td></tr></table></figure>

<p>중복된 키는 Map 객체의 요소로 저장되지 않는다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>,<span class="string">'value2'</span>],[<span class="string">'key1'</span>,<span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(1) &#123;"key1" =&gt; "value1"&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-요소의-개수확인"><a href="#2-2-요소의-개수확인" class="headerlink" title="2.2 요소의 개수확인"></a>2.2 요소의 개수확인</h2><p> Map 객체의 요소의 개수 확인 할때에는 Map.prototype.size 프로퍼티를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>,<span class="string">'value1'</span>],[<span class="string">'key2'</span>,<span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(2) &#123;"key1" =&gt; "value1", "key2" =&gt; "value2"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>Map.prototype.size 프로퍼티는 setter함수 없이 getter함수만 존재하는 접그자 프로퍼티 이다. 따라서 Map.prototype.size 프로퍼티에 숫자를 할당하여 Map 객체의 요소개수를 변경 할 수 없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'key1'</span>, <span class="string">'value1'</span>], [<span class="string">'key2'</span>, <span class="string">'value2'</span>]]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(<span class="built_in">Map</span>.prototype,<span class="string">'size'</span>));</span><br><span class="line"><span class="comment">//&#123;set:undefined, enumberable:false,configurable:true,get:function&#125;</span></span><br><span class="line"></span><br><span class="line">map.size =<span class="number">10</span>; <span class="comment">//무시된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(map.size) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-요소-추가"><a href="#2-3-요소-추가" class="headerlink" title="2.3 요소 추가"></a>2.3 요소 추가</h2><p>Map 객체의 요소를 추가할 때는 Map.prototype.set메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">//Map(0) &#123;&#125;;</span></span><br><span class="line"></span><br><span class="line">map.set(<span class="string">'key1'</span>,<span class="string">'value1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">//Map(1) &#123;'key1'=&gt;'value1'&#125;;</span></span><br></pre></td></tr></table></figure>

<p>Map.prototype.set메소드는 새로운 요소가 추가된 Map객체를 반환한다. 따라서 연속적으로 Map.prototype.set 메소드를 호출할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map.set(<span class="string">'key1'</span>,<span class="string">'value1'</span>)</span><br><span class="line">.set(<span class="string">'key2'</span>,<span class="string">'value2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(2) &#123;'key1'=&gt;'value1','key2'=&gt;'value2'&#125;;</span></span><br></pre></td></tr></table></figure>

<p>Map객체에 중복된 키를 갖는 요소의 추가는 허용되지않는다. 단 이때 에러가 발생하지는 않고 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">map</span><br><span class="line">  .set(<span class="string">'key1'</span>, <span class="string">'value1'</span>)</span><br><span class="line">  .set(<span class="string">'key1'</span>, <span class="string">'value2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map); <span class="comment">// Map(1) &#123;"key1" =&gt; "value1"&#125;</span></span><br></pre></td></tr></table></figure>

<p>객체는 문자열 또는 심볼 값만을 키로 사용할수 있지만 Map객체의 키 타입에는 제한이 없다. 따라서 객체는 포함한 모든 값을 키로 사용할 수 있다. 이는 Map 객체와 일반 객체의 가장 두드러지는 차이이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> lee  = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim = &#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line">map.set(lee,<span class="string">'developer'</span>)</span><br><span class="line">.set(kim,<span class="string">'developer'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(2) &#123; &#123;name:'lee'&#125;=&gt; 'developer',&#123;name:'kim'&#125;=&gt;'developer' &#125;;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-4-요소-취득"><a href="#2-4-요소-취득" class="headerlink" title="2.4 요소 취득"></a>2.4 요소 취득</h2><p>Map객체의 요소를 취득 할때 는 Map.prototype.get메소드를 사용한다. Map객체에 해당하는 ㅣ를 갖는 요소가 존재하지 않으면 undefined을 반환한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line">map.set(lee,<span class="string">'deveoper'</span>).set(kim,<span class="string">'developer'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(map.get(lee)); <span class="comment">///developer;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="string">'key'</span>)) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>

<h2 id="2-5-요소-존재-여부-확인"><a href="#2-5-요소-존재-여부-확인" class="headerlink" title="2.5 요소 존재 여부 확인"></a>2.5 요소 존재 여부 확인</h2><p> Map객체에 특정 요소가 존재하는지 확인 하려면  Map.prototype.has메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(map.has(lee)) <span class="comment">//true;</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'key'</span>)) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h2 id="2-6-요소의-삭제"><a href="#2-6-요소의-삭제" class="headerlink" title="2.6 요소의 삭제"></a>2.6 요소의 삭제</h2><p>Map객체의 요소를 삭제할때에는 Map.prototype.delete메소드를 사용한다. 만약 존재하지 않는 Map객체의 요소를 삭제 하려면 에러없이 무시된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line">map.delete(kim);</span><br><span class="line"><span class="built_in">console</span>.log(map) <span class="comment">// Map(1) &#123;&#123;name:'lee'&#125;=&gt;'developer'&#125;;</span></span><br></pre></td></tr></table></figure>

<p>Map.prototype.delete 메소드는 삭제 성공 여부를 나타내는 불리언 값을 반환한다. 따라서 Map.prototype.set 메소드와 같이 연속적으로 호출 할수없다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim=&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]);</span><br><span class="line"></span><br><span class="line">map.delete(lee).delete(kim) <span class="comment">//TypeError: map.delete(...).delete is not a function</span></span><br></pre></td></tr></table></figure>

<h2 id="2-7-요소의-일괄-삭제"><a href="#2-7-요소의-일괄-삭제" class="headerlink" title="2.7 요소의 일괄 삭제"></a>2.7 요소의 일괄 삭제</h2><p>Map 객체의 요소를 일괄 삭제 할때는 Map.prototype.clear 메소드를 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim=&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line">map.clear();</span><br><span class="line">consoleg.log(map) <span class="comment">//Map(0) &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-8-요소의-순회"><a href="#2-8-요소의-순회" class="headerlink" title="2.8 요소의 순회"></a>2.8 요소의 순회</h2><p>Map 객체의 요서를 순회할 때는 Map.prototype.forEach메소드를 사용한다. Map.prototype.forEach메소드는 Array.prototype.forEach메소드와 유사하게 콜백함수와 forEach 메소드 내부에서 this로 사용 될 객체(옵션)를 전달한다. 이때 콜백 함수는 다음과 다팅 3개의 인수를 받는다.</p>
<ul>
<li>첫번째 인수 : 현재 순회중인 요소 값</li>
<li>두번째 인수 : 현재 순회중인 요소 키</li>
<li>세번째 인수 : 현재 순회중인 Map객체(this)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line">map.forEach(<span class="function">(<span class="params">v,k,map</span>)=&gt;</span>consoel.log(v,k,map));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">developer &#123;name: "Lee"&#125; Map(2) &#123;</span></span><br><span class="line"><span class="comment">  &#123;name: "Lee"&#125; =&gt; "developer",</span></span><br><span class="line"><span class="comment">  &#123;name: "Kim"&#125; =&gt; "designer"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">designer &#123;name: "Kim"&#125; Map(2) &#123;</span></span><br><span class="line"><span class="comment">  &#123;name: "Lee"&#125; =&gt; "developer",</span></span><br><span class="line"><span class="comment">  &#123;name: "Kim"&#125; =&gt; "designer"</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>Map객체는 이터러블이다 .따라서 for …of문으로  순회할수있으며 스프레드 문법의 대상이 될 수 도있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee =&#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map rorcpsms Map.prototype의 Symbol.iterator 메소드를 상속받는 이터러블 이다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.iterator <span class="keyword">in</span> map) <span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//이터러블인 Map객체는 for...of문으로 순회할 수 있다.</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> entry <span class="keyword">of</span> map)&#125;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry) <span class="comment">//[&#123;name:'lee'&#125;=&gt;'developer'][&#123;name:'kim'&#125;=&gt;'designer']</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//이터러블인  Map객체는 스프레드 문법의 대상이 될수있다.</span></span><br><span class="line"><span class="built_in">console</span>.log([...map]);</span><br><span class="line"><span class="comment">//[[&#123;name:'lee'&#125;,'developer'],[&#123;name:'kim'&#125;,'designer']];</span></span><br></pre></td></tr></table></figure>

<p>Map은 이터러블이면서 동시에 이터레이터인 객체를 반환하는 메소드를 제공한다.</p>
<ul>
<li>Map.prototype.keys 메소드는 Map객체에서 요소 키를 값으로 갖는 이터레이터를 반환한다.</li>
<li>Map.prototype.values메소드는 Map객체에서 요소값을 값으로 갖는 이터레이터를 반환한다.</li>
<li>Map.prototype.entries메소드는  Map객체에서 요소 키와 요소 값을 값으로 갖는 이터레이터를 반환한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> lee = &#123;<span class="attr">name</span>:<span class="string">'lee'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> kim =&#123;<span class="attr">name</span>:<span class="string">'kim'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([lee,<span class="string">'developer'</span>],[kim,<span class="string">'designer'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">of</span> map.keys())&#123;</span><br><span class="line">  consoel.log(key) <span class="comment">//&#123;name:'lee'&#125;&#123;name:'kim'&#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> value <span class="keyword">of</span> map.values())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value) <span class="comment">//developer designer</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> entry <span class="keyword">of</span> map.entries())&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(entry) <span class="comment">//[&#123;name:'lee'&#125;,'developer'] [&#123;name:'kim'&#125;,''designer];</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Map객체는 요소의 순서에 의미를 갖지 않지만 Map객체를 순회하는 순서는 요소가 추가된 순서를 따른다.<br>이는 ECMAScript 사양에 규정되어 있지는 않지만 다른 이터러블의 순회와 호환성을 유지하기 위함이다.</p>
]]></content>
      <tags>
        <tag>Set  과  Map에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>Symbol 타입</title>
    <url>/2020/05/06/symbol-md/</url>
    <content><![CDATA[<h1 id="1-Symbol-이란"><a href="#1-Symbol-이란" class="headerlink" title="1.Symbol 이란?"></a>1.Symbol 이란?</h1><p>1997년 자바스크립트의 ECAMScript로 처음 표준화된 이래로 자바스크립트에는 6개의 타입 즉 String,Number,boolean,undefined,null,Object가 있었다. </p>
<p>심볼은(symbol)은 es6에서 새롭게 추가된 7번째 타입으로 변경이 불가능한 원시타입이다. <strong>다른 값과 중복되지 않는 유일무이한 값이다.</strong> 따라서 주로 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용된다.</p>
<p>객체의 프로퍼티 키로 사용할 수 있는 값은 빈 문자열을 포함한 모든 문자열 또는 심볼값이다.</p>
<h1 id="2-Symbol의-생성"><a href="#2-Symbol의-생성" class="headerlink" title="2.Symbol의 생성"></a>2.Symbol의 생성</h1><p>##2.1. Symbol 함수</p>
<p>심볼 값은 Symbol 함수를 호출하여 생성한다. 다른 원시 값은, 즉 문자열,숫자,불리언 ,undefined,null은 타입의 값은 리터럴 표기법을 통해 값을 생성할 수 있지만 심볼값은 심볼을 함수를 호출해야 생성해야한다. 이<u>때 생성된 심볼 값은 노출 되지 않으며 다른 값과 절대 중복 되지 않는 유일무이한 값이다.</u></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Symbol 함수를 호출하여 유일무이한 심볼값을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//심볼 값은 노출되지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(mySymbol) <span class="comment">// Symbol();</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> mySymbol) <span class="comment">//symbol</span></span><br></pre></td></tr></table></figure>

<p> 언뜻 보면 생성자 함수로 객체를 생성하는 것 처럼 보이지만 Symbol함수는 String, number, Boolean 생성자 함수와는 달리 new 연산자를 사용하지 않는다. new연산자와 함께 생성자 함수 또는 클래스를 호출하면 객체 (인스턴스)가 생성되지만 심볼 값은 변경이 불가능한 원시 값 이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Symbol</span>();  <span class="comment">//TypeError: Symbol is not a constructor</span></span><br></pre></td></tr></table></figure>

<p>Symbol 함수에는 선택적으로 문자열을 인수로 전달 할 수 있다. 이 문자열은 생성된 심볼 값에 대한 설명으로 디버깅 용도로만 사용되며 심볼 값 생성에 어떠한 영향을 주지 않는다. 즉 심볼 값에 대한 설명이 같더라도 생성되 값은 <u>유일무이한 값이다.</u></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//심볼 값에 대한 설명이 같더라도 유일무이한 심볼 값을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> mySymbol1 = <span class="built_in">Symbol</span>(<span class="string">'mySymbol'</span>);</span><br><span class="line"><span class="keyword">const</span> mySymbol2 = <span class="built_in">Symbol</span>(<span class="string">'mySymbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mySymbol1 === mySymbol2); <span class="comment">//false;</span></span><br></pre></td></tr></table></figure>

<p>심볼 값도 문자열,숫자,불리언과 같이 객체처럼 접근하면 암묵적으로 래퍼 객체를 생성한다. 아래 예제는 description  프로퍼티와 toString  메소드는 Symbol.prototype의 프로퍼티 이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 심볼도 래퍼 객체를 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>(<span class="string">'mySymbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(mySymbol.description) <span class="comment">//mySymbol</span></span><br><span class="line"><span class="built_in">console</span>.log(mySymbol.toString()) <span class="comment">//Symbol(mySymbol)</span></span><br></pre></td></tr></table></figure>

<u>

<p><strong>심볼 값은 암묵적으로 문자열이나 숫자 타입으로 변화되지 않는다.</strong></p></u><p></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//심볼 값은 암묵적인 타입 변환이 되지않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(mySymbol +<span class="string">''</span>) <span class="comment">// TypeError: Cannot convert a Symbol value to a string</span></span><br><span class="line"><span class="built_in">console</span>.log(+mySymbol);  <span class="comment">/// TypeError: Cannot convert a Symbol value to a string</span></span><br></pre></td></tr></table></figure>

<p>단 불리언 타입으로는 암묵적으로 타입 변환이 된다. 이를 통해 if문 등에서 존재 확인이 가능하다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//불리언 타입으로는 암묵적으로 타입 변환이 된다.</span></span><br><span class="line"><span class="built_in">console</span>.log(!!mySymbol)<span class="comment">//true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if문 등에서 존재 확인을 위해 사용할 수 있다.</span></span><br><span class="line"><span class="keyword">if</span>(mysymbol)<span class="built_in">console</span>.log(<span class="string">'mysymbol is not empty'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="2-2-Symbol-for-메소드"><a href="#2-2-Symbol-for-메소드" class="headerlink" title="2.2. Symbol.for 메소드"></a>2.2. Symbol.for 메소드</h2><p>Symbol.for 메소드는 인수로 전달받은 문자열을 키로 사용히여 키와 심볼의 값의 쌍들이 저장되어 있는 전역 심볼 레지스트리에 해당하는 키와 일치하는 심볼값을 검색한다.</p>
<li>검색에 성공하면 새로운 심볼 값을 생성하지않고 검색된 심볼 값을 반환한다.</li>

<li>검색 실패하면 새로운 심볼값을 생성하여 Symbol.for 메소드의 인수로 전달되는 전역 Symbol 레지스트리에 저장한 후, 생성된 심볼을 반환한다.</li>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//전역 심볼 레지스트리에 mySymbol이라는 키로 저장된 심볼 값이 없으면 새로운 심볼 값을 생성한다.</span></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'mySymbol'</span>);</span><br><span class="line"><span class="comment">//전역 심볼 레지스트리에 mySymbol이라는 키로 저장된 심볼 값이 있으면 해당 심볼 값을 반환</span></span><br><span class="line"><span class="keyword">const</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">''</span>mySymbol);</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>Symbol함수는 호출될때 마다 유일무이한 심볼 값을 생성한다. 이때 자바 스크립트 엔진이 관리하는 심볼 값 저장소인 전역 심볼 레지스트리에서 심볼 값을 검색 할 수 있는 키를 지정 할 수 없으므로 전역 심볼 레지스트리에 등록되어 관리되지않는다.<br>하지만 Symbol.for메소드를 사용하면 애플리케이션 전역에서 중복되지않는 유일무이한 상수인 심볼 값을  단 하나만 생성하여 전역 심볼의 레지스크리를 통해 공유 할 수 있다.<br>Symbol.keyFor 메소드를 사용하면 전역 심볼 레지스트리에 저장된 심볼 값의 키를 추출할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//전역 심볼을 레지슽크리에 mySymbol이라는 키로 심볼 값이 없으면 새로운 심볼 값을 생성</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="built_in">Symbol</span>.for(<span class="string">'mySymbol'</span>);</span><br><span class="line"><span class="comment">//전역 심볼 레지스트리에 저장된 심볼 값의 키를 추출</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s)) <span class="comment">//mySymbol</span></span><br></pre></td></tr></table></figure>

<h1 id="3-Symbol과-상수"><a href="#3-Symbol과-상수" class="headerlink" title="3. Symbol과 상수"></a>3. Symbol과 상수</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//위,아래,오른쪽,왼쪽을 나타내는 상수</span></span><br><span class="line"><span class="comment">//값 1,2,3,4에는 특별한 의미가 없고 상수 이름에 의미가 있다.</span></span><br><span class="line"><span class="keyword">const</span> Direction =&#123;</span><br><span class="line">  UP:<span class="number">1</span>,</span><br><span class="line">  DOWN:<span class="number">2</span>,</span><br><span class="line">  LEFT:<span class="number">3</span>,</span><br><span class="line">  RIGHT:<span class="number">4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//변숭에 상수를 할당</span></span><br><span class="line"><span class="keyword">const</span> myDirection = Direction.UP;</span><br><span class="line"><span class="keyword">if</span>(myDirection === Diretion.UP)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'You are going up'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제와 같이 값에는 특별한 의미가 없고 상수이름 자체에 의미가 있는 경우가 있다. 이때 문제는 상수 1,2,3,4가 다른 변수 값과 중복 될 수 있다는 것이다. 이러한 경우 중복될 가능성이 있는 무의미한 상수 대신 중복될 가능성이 없는 유일 무이한 심볼값을 사용 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//위,알래,오른쪽,왼쪽을 나태내는 상수.</span></span><br><span class="line"><span class="comment">//중복될 기능성이 없는 심볼 값으로 상수값을 생성</span></span><br><span class="line"><span class="keyword">const</span> Direction =&#123;</span><br><span class="line">  UP:<span class="built_in">Symbol</span>(<span class="string">'up'</span>),</span><br><span class="line">  DOWN:<span class="built_in">Symbol</span>(<span class="string">'down'</span>),</span><br><span class="line">  LEFT:<span class="built_in">Symbol</span>(<span class="string">'left'</span>),</span><br><span class="line">  RIGHT:<span class="built_in">Symbol</span>(<span class="string">'right'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//변수에 상수를 할당</span></span><br><span class="line"><span class="keyword">const</span> Direction = Direction.UP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(myDirection === Direction.UP)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'you are going up'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>enum</strong><br><strong>enum은</strong> 명명된 숫자 상수의 집합으로 열거형이라고 부른다. 자바스크립트는 enum을 지원하지는 않지만 C,Java,Python 등 많은 프로그래밍 언어와 자바 스크립트으 Superset(상위 확장)인 TYpeScript에서  enum을 지원하고 있다. 자바스크립트세서 enum을 흉내내어 사용하려면 아래와 같이 객체의 변경을 방지 하기 위해 객체를 동결  하는 Object.freeze 메소드와 심볼 값을 사용한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Javascript enum</span></span><br><span class="line"><span class="comment">//Direction 객체는 불변객체이며 프로퍼티는 유일무이한 값이다.</span></span><br><span class="line"><span class="keyword">const</span> Direction = <span class="built_in">Object</span>.freeze(&#123;</span><br><span class="line">   UP: <span class="built_in">Symbol</span>(<span class="string">'up'</span>),</span><br><span class="line">   DOWN: <span class="built_in">Symbol</span>(<span class="string">'down'</span>),</span><br><span class="line">   LEFT: <span class="built_in">Symbol</span>(<span class="string">'left'</span>),</span><br><span class="line">   RIGHT: <span class="built_in">Symbol</span>(<span class="string">'right'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//변수에 상수를 할당</span></span><br><span class="line"><span class="keyword">const</span> myDirection = Diection.UP;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(myDirection === Direction.UP)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'You are going up'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-Symbol과-프로퍼티-키"><a href="#4-Symbol과-프로퍼티-키" class="headerlink" title="4. Symbol과 프로퍼티 키"></a>4. Symbol과 프로퍼티 키</h1><p>객체의 프로퍼티키는 빈 문자열을 포함하는 모든 문자열 또는 심볼 값으로 만들수 있느며 동적으로 생성 할 수 도 있다.</p>
<p>심볼 값으로 프로퍼티 키를 동적으로 생성하여 만들어 보자. 심볼 값을 프로퍼티 키로 사용하려면 프로퍼티 키를 사용할 심볼 값에 대괄호를 사용해야한다. 프로퍼티에 접근 할때도 마찬가지로 대괄호를 사용해야한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">  <span class="comment">//심볼 값으로 프로퍼티 키를 동적 생성</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.for(<span class="string">'mySymbol'</span>)]:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>.for(<span class="string">'mySymbol'</span>)]) <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<p><strong>심볼 값은 유일무이한 값이므로 심볼 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지않는다.</strong> 기존 프로퍼티 키와 충돌하지않는 것은 물론,미래에 추가될 어떤 프로퍼티 키와도 충돌할 위험이 없다.</p>
<h1 id="5-Symbol과-프로퍼티-은닉"><a href="#5-Symbol과-프로퍼티-은닉" class="headerlink" title="5. Symbol과 프로퍼티 은닉"></a>5. Symbol과 프로퍼티 은닉</h1><p>심볼 값으로 동적으로 프로퍼티 키로 만든 프로퍼티는 for ..in 문이나 Object.keys,Object.getOwnPropertyNames 메소드로 찾을 수 없다. 이처럼 심볼 값을 동적으로 생성한  프로퍼티 키로 프로퍼티를 만들면 프로퍼티를 숨길 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj=&#123;</span><br><span class="line">  <span class="comment">//심볼 값으로 프로퍼티 키를 동적 생성</span></span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'mySymbol'</span>)]:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> key <span class="keyword">in</span> obj)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key) <span class="comment">//아무것도 출력되지않는다.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(ObJect.keys(obj)) <span class="comment">//[];</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj)); <span class="comment">//[]</span></span><br></pre></td></tr></table></figure>

<p>하지만 프로퍼티를 완전히 숨길 수 있는 것은 아니다. Es6에서 도입된  Object.getOwnPropertySymbols 메소드를 사용하면 심볼값으로 동적 생성한 프로퍼티 키로 만든 프로퍼티를 찾을 수있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj =&#123;</span><br><span class="line">  <span class="comment">//심볼 값으로 프로퍼티 키 동적 생성</span></span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'mySymbol'</span>)]:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertySymbols(obj)) <span class="comment">//[Symbol(mySymbol)];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//심볼 값을 찾을 수 있다.</span></span><br><span class="line"><span class="keyword">const</span> symbolKey1 = <span class="built_in">Object</span>.getOwnpropertySymbols(obj)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">console</span>.log(obj[symbolKey1]); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>

<h1 id="6-Symbol-과-표준-빌트인-객체-확장"><a href="#6-Symbol-과-표준-빌트인-객체-확장" class="headerlink" title="6. Symbol 과 표준 빌트인 객체 확장"></a>6. Symbol 과 표준 빌트인 객체 확장</h1><p>일반적으로 표준 빌트인 객체에 사용자 정의 메소드를 직접 추가하여 확장하는 것은 권장 하지않는다  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 표준 빌트인 객체를 확장하는 것은 권장하지않는다.</span></span><br><span class="line"><span class="comment">//즉 ,Array.prototype은 읽기 전용으로 사용하는 것의 좋다.</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.sum = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p+c,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>].sum()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<p>그 이유는 개발자가 직접 추가한 메소드는 미래에 표준 사양으로 추가될 메소드가 이름이 중복 될 수있기 때문이다. 예를 들어 Array.prototype.find메소드가 Es6의 새롭게 도입되기 이전에 Array.prototype에 find을 집겁 추가 했다면 새롭게 도입된Es6.find 메소드와 이름이 중복되어 Es6의 Array.prototype.find 와 이름이 중복 되어 Es6의 Array.prototype.find 메소드를 이전에 추가했던 사용자 정의 find 메서드가 덮어 쓴다. 표준 빌트인 메소드를 사용자 정의 메소드가 된다면 문제가 된다. </p>
<p>하지만 중복될 가능성이 없는 심볼 값으로 프로퍼티 키를 생성하여 표준 빌트린 객체를 확장하면 표준 빌트인 객체의 기존 프로퍼티 키와 충돌 되지 않는  것은 물론 , 버전이 올라감에 따라 추가 될지도 모르는 어떤 프로퍼티 키와도 충돌 될 위험없이 안전하게 표준 빌트인 객체를 확장 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//심볼 값으로 프로퍼티 키를 동적 생성하면 다른 프로퍼티 키와 절대 충돌하지않는다.</span></span><br><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.for(<span class="string">'sum'</span>)] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function">(<span class="params">p,c</span>)=&gt;</span>p+c,<span class="number">0</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>][<span class="built_in">Symbol</span>.for(<span class="string">'sum'</span>)]()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>

<h1 id="7-Well-known-Symbol"><a href="#7-Well-known-Symbol" class="headerlink" title="7. Well known Symbol"></a>7. Well known Symbol</h1><p>자바스크립트가 기본 제공하는 빌트인 심볼 값이 있다. 빌트인 심볼 값은 Symbol 함수의 프로퍼티에 할당되어있다. 브라우저 콘솔에서 Symbol 함수를 참조하여 보자.<br> <img src="https://poiemaweb.com/assets/fs-images/33-1.png" alt="33-1"></p>
<p>자바스크립트가 기본 제공하는 빌트인 심볼 값을 Well-Known-Symbol이라 부른다. Well-Known-Symbol은 자바스크립트 엔진의 내부 알고리즘에 사용된다.</p>
<p>예를 들어 배열, String객체, arguments 객체와 같이 for..of 문으로 순회가 가능한 빌트인 이터러블은 Well-Known-Symbol인 Symbol.iterator를 키로 갖는 메소드를 가지며, Symbol.iterator메소드를 호출하면 이터레이터를 반환하도록 ECAMAScript 사양에 규정되어 있다. 빌트인 이터러블은 이 규정을 준수하고 있다.</p>
<p>만약에 빌트인 이터러블이 아닌 일반객체를 이터러블 처럼 동작하도록 구현하고 싶다면 이 규정(이터레이션 프로토콜)을 따르면 된다. 즉 ECMAScript 사양에 규정 되어 있는 대로  Well-Known-Symbol인 Symbol.iterator을 키로  깆는 메소드를 객체에 추가하고 이터레이터를 반환하도록 구현하면 그 객체는 이터러블이 된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 - 5 사이의 정수로 이루어진 이터러블</span></span><br><span class="line"><span class="keyword">const</span> iterable =&#123;</span><br><span class="line">  <span class="comment">//Symbol.iterator 메소드를 구형하여 이터러블 프로토콜을 준수</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]()&#123;</span><br><span class="line">    <span class="keyword">let</span> cur =<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> max = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//Symbol.iterator 메소드는 next메소드를 소유한 이터레이터를 반환</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next();</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">      value:cur++,</span><br><span class="line">      done:cur&gt;max+<span class="number">1</span></span><br><span class="line">    	&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> num <span class="keyword">of</span> iterable)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(num); <span class="comment">//1 2 3 4 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>빌트인 이터러블</strong><br>이터러블은 for…of문으로 순회할 수 있고 스프레드 문법의 피연산자가 될 수 도 있는 객체를 말한다. 자바스크립트가 기본 제공하는 빌트인 이터러블은 아래와 같다.</p>
<table>
<thead>
<tr>
<th align="center">빌트인 이터러블</th>
<th align="center">프로퍼티 키가 Symbol.iterator인 메소드</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Array</td>
<td align="center">Array.prototype[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">String</td>
<td align="center">String.prototype[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">Map</td>
<td align="center">Map.prototype[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">Set</td>
<td align="center">Set.prototype[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">TypedArray</td>
<td align="center">TypedArray.prototype[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">arguments</td>
<td align="center">arguments[Symbol.iterator]</td>
</tr>
<tr>
<td align="center">DOM 컬렉션</td>
<td align="center">NodeList.prototype[Symbol.iterator], HTMLCollection.prototype[Symbol.iterator]</td>
</tr>
</tbody></table>
<p>이때 일반 객체에 추가해야하는 메소드의 키 Symbol.iterator은 기존 프로퍼티 키 또는 미래에 추가될 프로퍼티 키와 절대로 중복되지 않을 것이다.</p>
<p>이처럼 심볼은 중복되지 않는 상수값을 생성하는 것은 물론 기존에 작성된 코드에 영향을 주지않고 새로운 프로퍼티를 추가하기 위해 ,즉 하위 호환성을 보장하기 위해 도입되었다.</p>
]]></content>
      <tags>
        <tag>Symbol 타입에 대해</tag>
      </tags>
  </entry>
  <entry>
    <title>tabindex을 이용한 키보드 접근성</title>
    <url>/2019/09/22/tabindex%EC%9D%84%EC%9D%B4%EC%9A%A9%ED%95%9C%ED%82%A4%EB%B3%B4%EB%93%9C%EC%A0%91%EA%B7%BC%EC%84%B1/</url>
    <content><![CDATA[<p>키보드의 접근성을 고려한 tabindex의 사용.</p>
<p>tabindex는 기본적으로  키보드의 tab키를 눌렀을 때 이동순서를 임의로 조정 할 수 있는 html의 속성 입니다. tabindex의 포커스의 순서를 부여하는 방식을 tabintdex 값에 양의정수를 넣어주면 됩니다. 예를 들어 어떤 html요소에 taindex=”1”을 주었다면 해당 웹 페이지 상에서 tab키를 눌렀을때 tabindex=”1”이 부여하는 요소가 가장 먼저 포커스 됩니다. 그러나 taindex는 신중하게 사용해야 할 필 요가 있습니다. 일반적으로 키보드의  tab키를 눌렀을때 포커스는 html의 마크업 순서를 따르며 링크요소 또는 폼 요소등 tab키로 포커스를 가질 수  있는 요소에 마크업 순서에 따라 자연스럽게 이동합니다. 기본적으로 마크업이 논리적으로 이루어져 있다면 굳이 tabindex을 사용할 이유가 없습니다. 오히려 잘못된 tabindex를 사용함으로써 스크린 리더 사용자가 웹 페이지의 구조를 이해하는데 어려움으로 작용하게 될 수 있습니다.</p>
<p>tabindex는 위에서 설명한것 같이 마크업 순서가 논리적으로 잘 구성되어있다면 대체로 사용할 필요가 없습니다. 임의의 페이지에 처음  접속하는 필수 회원 로그인을 행하는 경우 폼 요소에 tabindex를 부여하여 먼저 회원 로그인을 유도하는등의 이유로 사용할 수는 있습니다. 그러나 이러한 경우에도 페이지 로딩 시autofocus기능을 사용하여 회원 로그인을 유도하는 것이 바람직하다고 생각합니다. 그럼 tabindex는 언제 사용할까요?</p>
<p>웹페이지를 구성하다 보면 페이지 탐색에 논리적 순서를 부여하는 사용자가 자연스럽게 페이지를 탐색할 수 있도록합니다.</p>
<p>tabindex속성은 양의정수값 이외에 0과 -1의 값을 가질 수도 있습니다. 먼저 tabindex=”0”은 tab키를 눌렀을때 포커스를 받을 수없는 요소 이를테면 <span>등의 요소에 포커스를 받게 할 수 있습니다.  반면 -1은 기본적으로 tab키를 눌렀을때 포커스받을 수있는 폼 요소나 링크 요소를 강제로  포커스 받지 못하도록 하는 값입니다. </span></p>
]]></content>
      <tags>
        <tag>tabindex을 이용한 키보드 접근성 및 간단한 내용 정리</tag>
      </tags>
  </entry>
  <entry>
    <title>프론트엔드 개발공부를 한 한달의 감상</title>
    <url>/2019/09/29/%EA%B0%9C%EB%B0%9C%EA%B3%B5%EB%B6%80%EA%B0%90%EC%83%81/</url>
    <content><![CDATA[<p>처음에 학원에 들어오게 되었을때,학원의 광고에 이끌려 이제는 쉽게 개발자로서 나의 커리어를 시작할 도약이 되겠구나 생각했다.하지만 처음에 수업을 듣고 난 후, 나의 생각은 정말 오만하고 생각이 없었다는것을 느꼈다.이세상에 쉬운것은 절대 없었다. 내가 알고있던것은 정말 일부에 지나지 않았다. 처음 수업을 들은 후 나는 굉장히 충격과 좌절을 느꼈다. 수업을 따라가는 것 조차 너무나도 버거웠다. 굉장히 불안하고 힘들었다. 내가 그나마 할 수있는 것은 학원 매니져님을 붙잡고 하나하나 질문하는것 뿐이었다. 그래서 첫 수업이 끝난 후 나는 학원 문을 닫을 때 까지 학원을 떠나지 못했다. 집에 가는 중에도 계속생각했다.내가 잘 할 수 있을까?하는 생각을 끊임없이했다.<br>처음에는 어떻게 공부해야 할 지도 너무 막막했다.이게 맞는지 저게 맞는지..몇일 동안을 수업이 끝나고 집으로 돌아가는 내내 기분이 안좋았다. 심지어 학원을 환불받아야하나 하는 생각도 했다.하지만 나에게는 포기했을때 선택할 수 있는 다른 선택지가 없다고 느꼈다. 나에게 프론트엔드 개발자의 길은 너무도 멀리있어서 보이지도 않는 하나의 점처럼 느껴졌다.<br>하지만 조금씩 수업을 듣고 공부를 하면서 조금씩 나아진다는 것을 느꼈다.주말에도 공부를 하고 하다보니까 수업을 듣는것도 이해하는 것도 조금은 수월해 졌다.<br>내가 항상 걱정했던것은 다른사람들은 잘하는데 나만 제일 못하는 것같고 도퇴되면 어쩌지 하는 두려움이었다. 그러다 문득 느낀것이 다른사람들과 나는 출발점이 달랐던 것이었다.컴퓨터 관련 전공자,현업에서 뛰던 경험이 있는 사람들, 비 전공에 혼자서만 공부를 했던 나와는 출발점이 달랐다.그렇기에 다른 사람과 비교하면 차이가 나는것은 당연한 것 이였다.<br>어느날 인터넷에서 개발자와 관련된 글을 읽다가 한가지 글이 굉장히 인상에 남았다.’개발자의 길은 남들과 비교하는 순간 끝이다’라는 글이었다.<br>남들과 비교를 하면서 스스로의 성취에 무뎠었다. 앞으로  나는 나에게만 집중해야겠다 생각했다. 그리고 다른 출발점을 따라 잡기 위해서 더 많은 노력을 할 것이다. 비록 지금은 더디고 느리지만, 나보다 앞선 사람들을 훨씬 추월하고 싶다.그리고 작은 성취를 느끼며 조금씩 조금씩 나아갈 것이다.작은 성취 하나하나가 나를 앞으로 나가게 하는 원동력이 된다. 처음 느꼈던 좌절을 발판삼아 앞으로 나아갈 것이다.앞으로 좌절 보다는 도전하고 극복하겠다.<br>지켜봐라. </p>
]]></content>
      <tags>
        <tag>HTML,CSS 수업을 듣고 난 한 달</tag>
      </tags>
  </entry>
  <entry>
    <title>메모리,참조,키워드,변수,선언,할당,재할당,호이스팅</title>
    <url>/2019/10/04/%EB%A9%94%EB%AA%A8%EB%A6%AC%EC%B0%B8%EC%A1%B0%ED%82%A4%EC%9B%8C%EB%93%9C/</url>
    <content><![CDATA[<p><strong>변수</strong>-값을 다룬다.(데이터를 다룬다.)</p>
<p><strong>참조</strong>-변수에 저장된 값을 읽어들이는것을 참조라한다.</p>
<p>함수/객체 (변수를 모르면 못함)</p>
<p>10(리터럴)+(연산자)20(리터럴):좌변과 우변의 값 +연산자를 메모리에 저장한다.</p>
<p><strong>메모리셀</strong>:1byte짜리 방이 존재한다.1byte단위로 저장<br><strong>메모리주소</strong>:각각 셀마다 주소가있다.<br>인간에게 유의미한 데이터는 최소 1byte이상</p>
<p>숫자를 기억하여 메모리에 저장한다. 연산을 cpu에서 한다. cpu에서 연산 한 후 이를 메모리에 저장을 한다.<br>메모리에 저장되는 모든 값은 2진수이다.</p>
<p><strong>1+2 안 쓴다표현식(unuse-expression)? 쓴다는 의미?</strong> 메모리 어딘가에 저장함.(10과20) 30이라는 값을 더한이유는 이 값을 ‘사용하겠다’는 의미이다.곧 재사용을 할 수없다는 것이다.  값이 메모리에 저장이 됐지만 주소를 알아야 접근할 수있는데,<br>위치 안알려줌(잘못 저장하면 문제가 생김)/알려준다고해도 문제가 됨.(같은 곳에 저장될 보장이없다.임의의 공간에 저장이 되기때문이다.) 저장된 데이터를 재사용하기 위해서 프로그래밍 언어는 변수를 제공한다.</p>
<p>따라서 변수는 데이터가 저장되는 곳의 메모리 주소를 기억한다.(반드시 변수에는 하나의 값만 저장할 수 있다.)</p>
<p><strong>변수란</strong> 하나의 값을 저장할 수 있는 메모리공간에 붙인 이름 또는 메모리공간 자체를 말한다.</p>
<p><strong>여기서 값이란(하나의값)?</strong> 메모리에 들어가는 대상.컴퓨터가 인식할 수있는 값의 종류. 7가지 (숫자 문자열 불리언 undefined null symbol 객체-값의 유형)</p>
<p>자료구조-데이터 구조(여러 개의 값이 들어있는,연관된 데이터의 그룹) ex)객체,배열</p>
<hr>
<p>자바스크립트 엔진은 변수이름 result (식별자-고유한 이름,일종의 카드 키)을 안다.<br>키워드-명령어(뒤에 값을 준다.) 자바스크립트에게 내리는 명령<br>변수에 저장된 값을 읽어들이는 것을 참조라한다.</p>
<p><strong>변수의 이름</strong>-&gt;할당값/값을 의미해야함<br>변수의 이름은 저장된 값의 의미를 이해 할 수있는 이름은 가독성을 높여주는 부수효과 .변수이름을 신중하게 정해야한다.</p>
<p>var result=10+20; 각 값10,20 메모리에 저장하고 30이라는 결과를 가져옴(평가)<br>10,20이라는 값은 필요없는 값-가비지컬렉터에의해 쓰지않는 값이기 때문에 다른값이 들어갈수있게 해준다. 가비지 ㅌ컬렉터는 값을 지우는 것이아니다.</p>
<p><strong>var(키워드) result(변수이름/식별자)=10+20(표현식);</strong><br><strong>표현식을 변수에 할당(assign,저장,대입)</strong></p>
<p>code-runner(dom api가 없으면 사용해도 괜찮다.)<br>quokka(command shift p);</p>
<hr>
<p><strong>식별자(변수이름)</strong> -메모리에 있는 값을 구별해서 끄집어낼 수  있는 값./식별자는 어떤 값을 구별하여 식별해낼 수있는 고유한 이름</p>
<p><strong>함수는값이다</strong>.함수덩어리 메모리에 그대로 들어감ex)foo();</p>
<p>클래스-객체를 만들어냄 ex)class Bar(){} new Bar();<br>식별자는 메모리 주소를 알고 있다.<br>변수,함수,클래스 네이밍있다.</p>
<p><strong>변수선언</strong>-변수를 생성한다.<br>변수란 컴퓨터에서 메모리와 관련있다.</p>
<p><strong>변수선언</strong>-변수생성한다(변수이음,메모리공간-매핑된 상황) 자바스크립트 엔진에 변수이름 등록 ,값 저장을 위한 메모리 공간 확보위함</p>
<p>변수선언 var result 변수이름을 자바스크립크 엔진에 등록해 알린다.</p>
<p><strong>변수의 이름은 어디에 저장이 되는 가?</strong>  변수이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록이된다. 또한 자바 스크립트 엔진은 실행 컨텍스트를 통해서 식별자와 스코프를 관리한다. 변수이름과  변수값은 실행 컨텍스트내의 key와  value형식으로 등록되어 관리된다.<br>변수 선언 키워드 사용(var,let,const)</p>
<p>var 키워드를 사용한 변수선언은 선언단계와 초기화 단계가 동시에 일어난다.</p>
<p><strong>변수선언(메모리 공간을 확보하기 위해)=할당1.논리적 선이된후2.할당</strong></p>
<p>기본적 변수는 선언을 하고 할당해야함.</p>
<p>변수를 선언만하고,할당을 하지 않으면 -undefined값이나옴. 값이 정의되지않는다. 변수는 암묵적으로 undefined값을 가진다 .자바스크립트엔진에 부여. 알아서 할당한다 .undefined라는 값으로-우리가 일부로 할당하는 경우는 없다. 자바스크립트엔진이 쓰기위한 값,변수가 선언만되고 할당되지 않았다는것을 알려주기 위함이 크다.-인터프리터 언어는 런타임에 에러가 발생해서 볼 수있기 때문에 최대한 에러가 나지 않게한다.</p>
<p> 할당하지 않고 변수선언마저하지 않음 에러를 일으킨다.</p>
<hr>
<p><strong>변수 호이스팅(중요함)</strong>-변수선언이 위로 끌어올려진것처럼 동작한다.</p>
<p>console.log(score);//원래 에러가 나야함.<br>var score;//변수선언</p>
<p><strong>모든(식별자와 관련있다.)선언문은 먼저 실행한다.</strong><br>인터프리터가 코드를 한줄한줄 해석하기 전에 쭉 일고 선언문만을 골라서 먼저 실행한다. 이는 코드를 실행하기 전에 평가를 한다고 말한다.-이후 실행될 수있는 환경을 만들어냄.<br>변수의 선언이 코드가 순차적으로 실행되는 런타임 이전에 먼저 실행된다는 것에 주목하자.</p>
<p>위 끌어올려서 실행된 실행문은 또 실행되지 않는다.<br>(let,const호이스팅이 되지만 안되는것 처럼 작동한다.이후에 수업할 내용이다.)<br>위의 내용은 변수 호이스팅의 내용이고,함수 호이스팅이 따로 존재한다.<br>**이런식으로 코드를 짜지 말아야하는 예시가 될 수있다.-&gt;최소한 선언을 하고 참조해라.</p>
<p><strong>왜 호이스팅이 발생하는가?-&gt;</strong>선언문은 실행될때 가장먼저 골라져서 실행되기대문에 발생한다.<br>console.log(result);// undefined을 출력한다.<br>var result=100;(var result;<br>                                 result=100;)으로 해석될수있다.</p>
<p>선언문과 할당 ,선언문이전에 참조를 하지 말아라.</p>
<p>console.log(result);//undefined.<br>var result=100;<br>console.log(result)//100출력</p>
<hr>
<p><strong><em>값의 할당-</em></strong>변수 선언은 소스 코드가 순차적으로 실행되기 이전, 즉 런타임 이전에 먼저 실행되지만 값의 할당은 소스 코드가 순차적으로 실행되는 시점인 런타임에 실행된다.**</p>
<p><strong>값의 재할당-</strong>이미 할당되어있는 면수에 새로운 값을 또ㄱ디시 할당하는 것을 말한다.<br>var 키워드로 선언한 변수는 값을 재할당할 수 있따.</p>
<p>원시값(6가지 타입:undefined,null,불리언,문자열,숫자,symbol,)은 값을 변경할 수 없다.리뮤터블(한번 값을 설정하면 바꿀수없다.)</p>
<p><strong>언매니지드/ 매니지드</strong><br><strong>가비지 컬렉터</strong>는 지우는 역할이 아니라 값이 할당될때 다른 값이 들어가지 못하도록 블락한것을 풀어주어 다른 값이 들어갈 수 있도록하는 역할을 한다고 생각하면 쉽다.</p>
<p><strong>힌트는 :변수를 하나를 더만들어서 사용하라.</strong></p>
<p>var x=1;<br>var y=2;</p>
<hr>
<p>var z=y;</p>
<p>x=z;<br>y=x;<br>console.log(x,y);// 2,1로 출력되도록 값을 바꾸어라.</p>
]]></content>
      <tags>
        <tag>메모리,참조,키워드,변수,선언,할당,재할당,호이스팅,</tag>
      </tags>
  </entry>
  <entry>
    <title>반응형웹 수업내용 간단한 정리</title>
    <url>/2019/09/22/%EB%B0%98%EC%9D%91%ED%98%95%EC%9B%B9%EC%88%98%EC%97%85%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/</url>
    <content><![CDATA[<p>반응형 웹 디자인(responsive Web design) 모바일디바이스와 타블렛 같은 다양한 디바이스들이 등장하게 되었고, 그에 환경에 따른 별도의 대응이 필요하게 되었다.</p>
<p> RWD vs AWD(적응형):view port에 따라 증가하다가 특정 크기에서 고정형(데스크탑 +모바일)<br>반응형 웹의 100(width를  특정한 너비를 설정하지 않는다.)</p>
<p>컨텐츠는 물과 같다.용기는 다르더라도 내용물은 물은 그대로다.</p>
<p>미디어 쿼리 배치중요하다. 추천하는 방법은 모바일 환경에 대한 선형 디자인을 처음으로 고려하고 brekpoint를 추가하면서 너비나 상황 변하였을때의 값을 설정해주는 것이 좋은 방법이 된다.(모바일에서 데스크탑으로)<br> mobile first:컨텐츠 전략 선택 선형적인 기본작업을 모바일에서 만들고 그것을 데스크탑 컨텐츠로 순서로 최적화를 한다.</p>
<p>max-width:너비를 자신의 이상으로 안하겠다.너비가 줄수도 있지만 증가하진않는다.<br>height:auto:높이를 너비가 변호하는 것에 따에 자동으로 맞춘다.</p>
<p><picture>&lt;source min-width:40em srcset:big-jpg 1x:big -jpg 2x&gt;최소의 너비에서 다음으로 srcset의 값을 보여주겠다. 배율이 1일때와 2배율일때 각각 상황에 맞게 사용하겠다.<picture>은 재사용과 수정에 용이하다.<br></picture><br></picture></p>
<p>10vh(view height)화면 view port의 1/10을 높이로 정하겠다. 앞에서 이야기했듯이 모바일 first 선형화</p>
<p>display:flex 의 order속성은 기본 값이 :0 기본 값보다 작으면 -1이면 기본 보다 먼저 값은 값이 있으면 순서대로 정의 한다.</p>
<p>flex-flow:row wrap은 축은 바꾸지 않고 wrap 을 사용함으로서 줄을 바꿈.</p>
<p>breakpoint는 쉽게 생각하면 추가될때 바뀌는 구간이라고 생각하면 된다.<br>@media screen and (min-width:801px)::801이 되면서 내용을 덮어씌우겠다.</p>
]]></content>
      <tags>
        <tag>반응형 웹 수업내용</tag>
      </tags>
  </entry>
  <entry>
    <title>데이터 타입 연산자</title>
    <url>/2019/10/08/%EB%B3%80%EC%88%98%EB%8D%B0%EC%9D%B4%ED%84%B0%ED%83%80%EC%9E%85%20%EC%97%B0%EC%82%B0%EC%9E%90/</url>
    <content><![CDATA[<p>var person,$elem,_name,first_name,val1;</p>
<p>,쉼표는 연산자다.<br>자바스크립트는 대소문자를 구분한다.</p>
<p>var FRISTNAME:식별자의 이름을 대문자로 쓰면 개발자들사이에서 ‘상수’라는 것을 암묵적으로 약속한다.</p>
<p>변수는 값의 이름을 나타낼수 있는 의미가 중요하다.<br>주석은 가급적 많이 사용하지 않는것이 좋다-오히려 주석이 이해를 방해/그만큼 네이밍이 중요하다.</p>
<p>카멜케이스- var fristName변수,함수 기본적으로 사용<br>파스칼케이스-var FirstName생성자함수,클래스<br>스테이크케이스-var first_name;<br>헝가리언 케이스-var strFirstName;<br>var $elem=$(‘.myClass’);</p>
<p>var a=10+20; 10.+,20은 각각이 토큰이다.</p>
<p>+는 산술 연산자,<br>식(표현식:10+20)=&gt; 값(value)으로 30;<br>식이 값이 되려면 자바스크립트 엔진이 식을 평가(evaluation)한다.<br>var a=10+20;(전체를 문:statement)</p>
<hr>

<p><strong>데이터 타입</strong>(7가지-숫자,문자열,불리언,undefined,null,symbol,객체 혹은 참조)</p>
<p>-데이터 타입이 필요하다-&gt;할당할때 변수에 확보해야하는 메모리 공간을 확보할 수있다.</p>
<p>1.타입을 알아야-메모리 공간을 확보한다.<br>2.몇 바이트 공간이 필요한가<br>3.가져온 값을 어떻게 해석해야하는가?</p>
<p>숫자값 저장(8byte 사용) 타입마다 확보해야하는 메모리 공간 제각각이다. 타입을 모르면 확보해야할 메모리를 모른다.</p>
<p>score을 선두에 접근한다. 8byte만큼 가져옴-&gt;가져온 데이터 2진수(문자/숫자/불리언 등으로 어떻게 알것이냐?)<br>-&gt;따라서 식별자는 타입을 알아야한다.</p>
<hr>

<p><strong>값</strong>:현재 메모리에 들어있는 데이터<br><strong>값의 특징:</strong>타입을 가지고 있다(7가지 타입중하나)<br><strong>값이란?</strong> 더이산 평가 할 수 없는 하나의 표현식이다.<br>ex)30-리터럴/리터럴 표기법(10진수)/값을 만들어낸느 가장 시초<br><strong>평가란?</strong>식을 하나의 값으로 계산한다.ex)10+20평가의 대상 -평가의 결과물은 <strong>값</strong>이다.<br>표현식은 평가가 되어 값이 되는 것이다.<br>10(피연산자,리터럴)+(산술 연산자)20(피연산자,리터럴)</p>
<p>값을 표기하는 방법 크게 두가지다</p>
<p>1.<strong>리터럴</strong>(ex)30.<br><strong>2.표현식</strong>(ex)10+20-&gt;하나 이상의 리터럴,하나 이상의 표현식 연산자로 만들어진 ‘문(statement)’이다.</p>
<p>10+20:표현식-&gt; 자바스크립트엔진에서 평가-&gt;값 30을 만듦/리터럴 표기법를 평가해야 값을 만들어낸다.(평가 전에는 값이 만들어지지않는다.)</p>
<p>숫자 리터럴/문자열 리터럴/불리언 리터럴/null리터럴/undefined리터럴/객체 리터럴/배열 리터럴/함수 리터럴/정규표현식 리터럴</p>
<p>리터럴은 사람이 이해하기 편하게 하기 위해서 만들었다.</p>
<p><strong>데이터 타입</strong><br><strong>원시타입</strong>(숫자/문자열/불리언/undefined/null/symbol)</p>
<p><strong>객체 타입</strong>(object/reference type):객체,함수,배열</p>
<p>정수/실수-모든숫자를 실수 타입으로 처리를 한다.</p>
<ul>
<li>Infinity : 양의 무한대</li>
<li>-Infinity : 음의 무한대</li>
<li>NaN : 산술 연산 불가(not-a-number)</li>
</ul>
<p>표현식은 평가 되어져서 하나의 값을 만든다.<br>식별자는 결국 표현식이다.<br>(ex)var a=10;var a=b;b=a+10;표현식은 하나의 값으로 표현할 수있다.</p>
<p><strong>문자열</strong><br>작은 따옴표,큰 따옴표-개행하기 위해서는 이스케이프 시퀀스를 사용한다.(개행:\n);</p>
<p>백틱문자는 엔터나 띄어쓰기 같은 것,’’,””을 모두 동시에 사용할 수 있다는 장점이 있다.</p>
<p>console.log(‘My name is’+frist+’’+second+’!’);</p>
<p>+은 문자열 연산자-좌우항에 하나라도 문자열이 있다면 + 연산자로 결합하여 문자열이 된다.<br><code>${문자열}</code> ex)console.log(<code>1+1=${1+1}</code>);</p>
<p>‘2’는 문자열이다. 이는 암묵적인 타입변환이 일어났단는 것을 알수있다. 이러한 암묵적인 변환은 에러의 온상이 된다.</p>
<p><strong>불리언 타입</strong><br>논리적인 참,거짓을 나타내는 true 와 false를 가진다.</p>
<p><strong>undefined타입</strong><br>undefined타입 값은 undefined가 유일 하다.선언 이후에 명시적으로 값을 할당하지 은 변수는 자바스크립트 엔진의 암묵적 초기화에 의해서 undefined값을 가진다. 따라서 선언은 되었지만 아직 값을 할당하지 낳은 변수에 접근하면 undefined가 반환된다.</p>
<p><strong>선언</strong>:변수는 선언이라고 부를 것이다.<br><strong>정의</strong> :무언가를 할당해서 그 변수에 어떤 값을 가지고있는지 명확히 나타냄<br>함수,클래스는 ‘정의’로 부르겠다. 선언과 동시에 객체가 생성됨</p>
<p><strong>null타입</strong></p>
<p>변수에는 값이 없다는 것을 명확히 나타냄.<br>ex)var foo=’lee’; foo=null(가비지 컬렉터가 로 ‘lee ‘를 해제해 주세요)</p>
<p><strong>동적 타이핑(타입이 동적이다.)</strong><br>동적타입언어(자바스크립트)-변수의 타입이 없다(값에 타입이 있다.)-편하지만 신뢰성이 떨어진다(변수의 타입이 암묵적으로 변환이 된다.).</p>
<p>값에 의해서 변수의 타입이 결정이 된다.변수는 선언이 아닌 할당에 의해 타입이 결정된다. 재할당에 의해 변수의 타입은 언제든지 동적으로 바뀔 수 있다.-&gt;하나의 변수에 여러가지 값을 마구마구 집어널을 수있다.</p>
<p><strong>정적타입의 언어</strong>(자바,c)-변수자체가 타입이 있다=엄격하다(정해진타입의 값만이 들어갈수있기 때문에 )그래서 안정성이 있다.</p>
<p>언제나 변수의 타입의 값을 확정할 수있다.</p>
<p>Typescript -&gt;자바스크립트 에 정적 타입을 도입한것.</p>
<p>동적 타입언어는 편리함,but위험이 도사리고 있다.</p>
<p>동적으로 변화하는 데이터타입을 추측하기 어려운데 ,안정적인 프로그램을 만들기 위해서<br>1.변수를 최소화 한다.<br>2.전역변수(라이프 주기가 길다)사용x<br>변수의 생명주기를 짧게 만든다.<br>3.변수보다 상수를 사용해서 값의 변경을 억제 하자.<br>4.변수의 이름을 존재를 파악할 수있도록 명명한다.</p>
<hr>
<p><strong>표현식과 연산자</strong></p>
<p><strong>표현식</strong> :하나의 값을 표현할 수있는 문<br>표현식에 리터럴,식별자,연산자를 사용할 수있다.</p>
<p><strong>리터럴</strong>-사람이 이해할 수있는 값으로 나타냄<br>리럴은 표현식을 만드는 요소중에 하나이다.리터럴은 표현식이 될수있지만, 표현식은 리터럴 일수도 아닐 수도 있다.</p>
<p><strong>문</strong>-표현식일수도 아닐수도 있다.(문&gt;표현식)</p>
<p><strong>표현식인 문</strong>-값으로 표현(변수에 할당)<br><strong>표현식이 아닌 문</strong>-값으로 표현 (변수에 할당x)<br> 표현식인 문과 표현식이 아닌 문을 확인하는 가장 쉬운 방법은 변수에 할당해보는 방법이다.</p>
<p><strong>변수선언문</strong>-표현식이 아닌 문<br><strong>할당문**</strong>-(ex)x=5; 어떤 변수에 할당할 수있다.</p>
<p>문은 세미콜론으로 끝나야한다. 그러나 단 코드 블록 뒤에는 붙이지 않는다. 자동 삽입 기능이있지만 붙이는 것이 권고 된다.</p>
<p><strong>연산자</strong>:표현식을 만드는 연산자.피연산자에는 식이 올수도 있다.</p>
<p><strong>이항 연산자</strong>는 부수효과가 없다.<br>그러나 단항 연산자++,–부수효과가 있다.</p>
<p>+’10’숫자로 암묵적으로 변한이 일어남</p>
<p><strong>비교연산자</strong><br>===타입이 다르면 false이다.==타입이 달라도 같은 결과라고 나오는 경우가 있기에 ===을 사용해야함.<br>!==와 !==도 마찬가지</p>
<p>NaN===NaN은 false을 반황하는대   NaNdㅡㄴ 자신과 일치하지 않은 유일한 값이다. 따라서 NaN인지를 조사하려면 빌트인 함수를 isNaN을 사용해여한다.</p>
<p><strong>대소 연산자</strong>도 true와 false값을 받는다.</p>
<p><strong>3항 조건 연산자</strong><br>조건식? 조건식 이 true일때 반환하는 값 :조건식이 false일때 반환하는 값<br>var x=2;</p>
<p>var result=x%2? ‘홀수’:’짝수’;</p>
<p>console.log(result);</p>
<p>var x=2,result;</p>
<p>if(x%2){<br>result=’홀수’;</p>
<p>}else{</p>
<p>result=’짝수’</p>
<p>}console.log(result);</p>
<p><strong>논리연산자</strong></p>
<p>or(논리합:||)and(논리곱:&amp;&amp;) not(!)</p>
<p><strong>드모르간의 법칙</strong> !(x || y)===(!x &amp;&amp; !y)</p>
<p><strong>단축평가</strong>-피연산자가 불리언이 아닐수도 있다 어느 한쪽을 선택함</p>
<table>
<thead>
<tr>
<th>단축 평가 표현식</th>
<th>평가 결과</th>
</tr>
</thead>
<tbody><tr>
<td>true||anything</td>
<td>true</td>
</tr>
<tr>
<td>false||anything</td>
<td>anything</td>
</tr>
<tr>
<td>true&amp;&amp;anything</td>
<td>anything</td>
</tr>
<tr>
<td>false&amp;&amp;anything</td>
<td>false</td>
</tr>
</tbody></table>
<p><strong>typeof연산자</strong> </p>
<p>typeof funciton(){}-함수 리터럴-&gt;function을 받는다<br>생성자 함수=new 객체와 새로운 함수를 만든다.<br>typeof null은 object를 반환한다.</p>
<p><strong>지수연산자</strong></p>
<p>5 ** 2-&gt;25;</p>
<p>var num=5;<br>num ** =2-&gt;25</p>
<p>1.연산자 ++/–변수 ㄱ밧을 고친 다 부수효과가 존재한다.<br>2.동등연산자의 차이(===/==);<br>3.삼항조건연산자,if문 대신 사용할 수 있다.</p>
]]></content>
      <tags>
        <tag>변수 뒷부분 + 1.데이터타입 2.연산자</tag>
      </tags>
  </entry>
  <entry>
    <title>스코프</title>
    <url>/2020/05/03/%EC%8A%A4%EC%BD%94%ED%94%84/</url>
    <content><![CDATA[<p><strong>스코프</strong></p>
<p>식별자(변수)가 유효한 범위,식별자와 깊은 관련,함수와 관련<br>어떨때 유효하고 어떨때 유효하지 않은가?<br>함수는 스코프를 만든다.(var키워드로 선언한 경우)</p>
<p>var 키워드는 함수의 코드블록만을 코드 블록으로 인정하는 함수레벨 스코프를 따른다. var 키워드는 함수가 스코프를 만든다.</p>
<p>중첩함수-스코프도 중첩이 된다.(어떤 우선순위를 가지는 가?을 아는 것이 중요)<br>스코프는 간단하게 말하면 자바스크립트엔진이 식별자를 찾는 규칙이다. </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//선언하고 할당할때 a라는 식별자를 찾는다.</span></span><br></pre></td></tr></table></figure>

<p>즉 스코프는 식별자에 존재한다. 프로퍼티는 prototype체인에 존재한다.</p>
<p>스코프의 생명주기<br>함수에 매개변수가 업ㄱ다면 외부와 단절이 된다. 하지만 매개변수는 없는 것이 가장 좋다.-&gt;외부에 의존하기 때문에</p>
<p>함수는 재사용을 한다. 변수를 왜쓰는가?-어떤 상태를 유지해야할때 사용한다.<br>변수를 공용으로 쓸때는(전역변수와 관련하여)? 고정되어 변하지 않는 값ㅇ르 가지는 경우에 사용한다.<br>상수는 재할당을 금지시킨다. 따라서  전역변수는 상수개념이 아니면 사용하지 않는것이 좋다.</p>
<p>1.순수함수-1언제나 동일 한 반환값(return x+y)<br>x(2,3)=5</p>
<p>2.비순수함수 -외부함수에 영향을 받음</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">increase</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ++num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <strong>스코프 함수</strong></p>
<p>변수가 어디에서 선언이 됐느냐가 즉 선언 위치가 스코프를 만든다.<br>class는 함수이다.<br>자신이 선언된 위치에 의해 다른 식벼자를 참조할 유효범위가 결정된다.</p>
<p>function foo(){}는 식별자가 2개이다. 1.암묵적으로 자바스크립트 엔진이 변수이름으로 만든 식별자.</p>
<p>2.지역함수의 식별자. 그런데 에러를 일으키지않는다. 그리고 foo는 전역 함수이다. 또한 호출하는 foo()에서 foo는 함수이름이 아니고 자바스크립트엔진이 생성한 암묵적인 식별자다.</p>
<p>스코프는 자카스크립트엔진이 식별자는 찾는 규칙이다. 코드와 가장 근접한 곳에있는 스코프를 본다.<br>자바스크립트 코드의 문맥과 환경이있따. 코드를 실행하기 위한 문맥을 기억한다. 자바스크립트는 전역과 지역을 어떻게 구분하는걸까?</p>
<p>식별자는 스코프내에서 유니크하다.<br>전역은 어디근 참조(문맥을 찾는다.)가 가능하다. 코드가 해당하는 스코프부터 식별자를 찾는다. 그후에 상위로 간다.<br>쉐도잉-그림자 처럼 가져려진다.<br>식별자는 자바스크립트엔진에 등록이된다.<br>이때 스코프가 정해진다.<br>식별자는 스코프 체인에서 찾는다. 함수는 변수와 저장되는 매카니즘이 같다. 찾는 매카니즘도 동일하다.</p>
<p><strong>렉시컬 시코프</strong><br>자바스크립트엔진이 함수를 정의할때 어디서 호출될지 알수없다.<br>언제 함수의 상위 스코프가 오는냐? 함수의를 할때 취치에 의해 상위 스코프가정해진다. 어디서 호출되든지 간에 정의위치에 ㄱ따라 사우이스코프가 정해져버린다.<br>동적스코프와 /렉시컬스코프의 차이</p>
<p>매개변수가 값을 할당하는 것은 호출할때, 호출된 직후 매개변수undefined 선언된다. 이후에 할당된다.<br>변수도 어디에서 선언되는지에 따라 스코프가 정해진다.함수도 마찬가지</p>
<p><strong>암묵적 전역변수</strong><br>전역함수에서 선언하지않은 변수는 전역변수가 된다.<br>모듈(자바스크립트 엔진은 파일 스코프를 가지지않는다.)-&gt;한개의 파일로 함ㅍ쳐진다. 같은 이름의 변숙가 있다면 재할다잉 된다.이런 문제 따문에 전역변수를 사용하지않는다.<br>자바스크립트에는 순서가 있다.엄청 여러개의 스크립트파일들을  webpack 번들링 로 하나로 묶고 그 안에서 스코프를 줘서 나눈다.</p>
<p><strong>변수의 생명주기</strong>- 변수 생명주기는 직역변수일때 함수의 생명주기가 짧다.리소스가 빨리 해방이 된다.<br> 반대로 전역변수의 생명주기(스코프가 길다.)는 길기 때문에 재할당 수정등의 여러가지 문제를 야기한다.</p>
<p>짧고 생명주기가 짧은 함수가 가독성이 좋다. 그리고  한가지 일만 을 시킬수있어서 좋다.</p>
<p>전역변수의 생명주기는 스크립트 로드가 되자마자 생성되고 애플리케이션이 종료될때 까지 (브라우저 종료) 전역변수는 리소스 할당이 적다.,암묵적 결함을 하고,네이밍스페이스를 오염시킨다. </p>
<p>모둘패턴 (문법이 아닌 디자인 패턴이다.)<br>즉시실행함수는 코드가 실행되면 바로 실행이 된다. 객체 리터럴이 바로 함수에 할당이 된다. 모듈패턴은 자바스크립트에는 자바에서 public,private,protected같은 접근제한자가 없다. 따라서 이를 상요함으로써 변수에 접근을 하지못하게하는 역할을 하기위해 사용한다.<br>let,const 블록레벨 스코프</p>
<p>var키워드는 전역 변수의 분제점으로 귀결된다. 왜var키워드를 사용할 수없는가?-&gt;함수레벨 스코프,전역변수 문제점,재할당 등의 이유.</p>
<p>변수 호이스팅은 나쁜점이다. 지양해야하는 부분.<br>변수는 선언하고 참조해라</p>
<p>let/const 변수 선언 중복선언애러,변수는 스코프가 분리되있으면 다른 변수이다.</p>
<p>for문()의 소괄호의 부분은 코드블록안에 있다고 생각을 하는 것이 좋다.</p>
<p>const/let은 호이스팅이 안하는 것 처럼 보이지만 한다.-런타임이전에 변수는 선언이 된다. 하지만 런타임에 선언문을 만나야지 값이 할당된다. 그렇기 때문에 선언문이전에 호출을 하면 에러를 발생시킨다. 즉 선언된 것을 자바스크립트엔진이 알지만 이에 접근하지 말라는 의미다.</p>
<p><strong>전역객체</strong></p>
<p>브라우저의 전역객체는 :window이다.<br>node.js의 전역객체는 :gloabal이다.<br>var키워드로 선언한 모든 전역변수는 window객체릐 프로퍼티가 된다.</p>
<p>브라우저의 페이지를 바꾸면 전역객체또한 리셋이 된다.<br>전역객체는 var키워드로 선언한다.<br>function foo(){}와 var foo=funciton(){}모두 window의 객체이다.</p>
<p>let으로 선언한 전역변수는 더이상 읽어들을 전역변수가 없다면 생명주기를 다하고 죽는다.<br>var와 let키워드를 섞어서 사용하지만고 한가지만을 통일해서 사용하자.<br>window객체의프로퍼티는 전역변수와 같게 사용 할 수 있다.</p>
<p><strong>const키워드</strong><br>재할당을 할수없다. 변수 선언과 동시에 값을 할당해 주어야한다.<br>상수도 변수이다. 재할당을 금지시킨다.(스네이크 케이스,대문자로 사용한다.).</p>
<p><strong>const 키워드의 객체</strong><br>재할당을 하는 일은 극히 드물다.<br>대부분 변수 const 사용한다. 변수 재할당 할일 이 없다.<br>객체는 변경가능한 값이다. 객체를 가지는 변수는 let을 사용할 이유가 없다. 객체는 기본적으로 재할당하지 않는다. es6/const ,let을 사용한다. 재할당 필요한 경우에만 let을 사용한다. </p>
<p>전역 코드의 실행이 종료되면 let종료,window는 살아있다. 완료값은 변수에 할당되는 값이 아니다.</p>
]]></content>
      <tags>
        <tag>스코프</tag>
      </tags>
  </entry>
  <entry>
    <title>웹접근성과 WAI-ARIA</title>
    <url>/2019/09/17/%EC%9B%B9%EC%A0%91%EA%B7%BC%EC%84%B1/</url>
    <content><![CDATA[<p> 웹 접근성이란 웹 사이트에서 제공하는 정보를 차별없이 동등하게 이용 할 수 있도록하는 보장하는 것을 말한다. 신제적(고령층 ,장애인,비장애인 ) 환경적 요건(다양한 플랫폼,웹 브라우져,장치)을 모두 포함한다.</p>
<p>WAI ; Web Accessibility InitiativeWAI는 시각·청각 기능 등에 장애를 지닌 사람도 일반인과 동등하게 웹에 접근하여 이용할 수 있도록 관련 지침을 개발하고 웹 접근성 향상을 위한 노력을 기울이는 W3C의 산하 단체를 말한다</p>
<p>ARIA:Accessible Rich Internet Applications’의 약자로 리치 인터넷을 위한 W3C 접근성 명세입니다.</p>
<p>RIA:정적인 HTMl과 단순한 자바스크립트 환경의 웹이 아닌 동적인 자바스크립트와 Ajax와 같은 기술을 사용한 환경에서 수준 높은 UX(User eXperience)를 제공하는 웹 애플리케이션을 의미한다.</p>
<p>WAI-ARIA는 RIA에서 스크린 리더기 및 보조기기 등에서 접근성 및 운용성을 향상시키기 위한 목적으로 탄생했으며 웹 애플리케이션에 역할,속성,상태 정보를 추가하여 이를 개선 할 수 있도록 제공하고 있다.</p>
<p>1)대표적인 역할( role):tablist,button,tab,tooltip,list,</p>
<p>application,abnner,navigation,form,search..</p>
<p>2)Property &amp; State:(상태와 속성):aria-labelledby=”” : 레이블 제공을 위한 aria-속성. 상태 값은 연결시킬 레이블 id를 입력한다.</p>
<p>aria-haspopup=”” : 팝업요소가 하위에 존재하고 있다는걸 인식 시켜주는 aria-속성. 상태 값은 false(default) / true / menu / listbox / tree / gird / dialog</p>
<p>aria-live : 페이지의 어떤 위치에 있든 업데이트된 정보를 사용자에게 알려주는 aria-속성. 상태 값은 assertive / off(default) / polite</p>
<p>aria-labelledby=”” : 레이블 제공을 위한 aria-속성. 상태 값은 연결시킬 레이블 id를 입력한다.</p>
<p>aria-selected=”” : 탭메뉴 선택 유무를 알려준다. 상태 값은 선택되었을 때 true / 선택되지 않았을 때 false 입력</p>
<p>ria-controls=”” : 현재 요소가 제어하는 대상을 명시하는 속성으로 탭메뉴와 본문을 연결시켜준다. 상태 값은 tabpanel의 id명 입력</p>
]]></content>
      <tags>
        <tag>웹 접근성과 WAI-ARIA</tag>
      </tags>
  </entry>
  <entry>
    <title>10월 2일 수업내용정리</title>
    <url>/2019/10/03/10%EC%9B%942%EC%9D%BC%EC%88%98%EC%97%85%EB%82%B4%EC%9A%A9%EC%A0%95%EB%A6%AC/</url>
    <content><![CDATA[<p><strong>자바스크립트의 특징</strong> - 웹브라우저에서 동작하는 유일한 언어/고속으로 동작하는(웹 브라우저로 돌리는 게임) 어플리케이션에선 불리함</p>
<p>기계어 프로그래밍 언어(어셈블리언어)-만국공용어-&gt;어셈블리어 cpu종류마다 실행파일이 다름.그에따라 실질적인 언어 사용</p>
<p>웹 어셈블리어(보통 게임에서 사용) c#,c++뭐로코딩하든 중간으로 떨려서 브라우저를 돌리자.</p>
<p><strong>대부분의 언어 객체지향</strong>-&gt; 클래스로함(<strong>클래스 기반 객체지향언어</strong>)<br><strong>자바스크립트</strong>는-<strong>프로토 타입기반의 객체지향</strong></p>
<p>c(절차지향)/java(객체지향)/<strong>javascript(멀티 패러다임,객체 절차(명령),함수형 언어)</strong></p>
<p><strong>자바스크립트의 함수는 값이다</strong>.(값이란 서로 주고받을 수 있는 특성을 의미한다.why:함수형 프로그래밍을 가능하게 하기 위해)</p>
<p><strong>자바스크립트엔진</strong>-자바스크립트를 실행할 수있는 환경</p>
<p><strong>인터프리터</strong>-컴파일러가 결합해서 처리속도느린것을 해결-but토끼굴 </p>
<p><strong>명령어</strong>-절차지향형,함수,프로토타입기반 객체지향 (프로토 타입기반 객체기반을 중심으로 공부를 한다.)-멀티 프로그래밍/객체기반 언어-클래스기반(c#,java).</p>
<hr>
<p> <strong>web api(web aplication progamming interface)</strong>가 들어있는 환경에서는 웹브라우저에서만 적용한다. node.js에서 실행x</p>
<p>html은 크게 2개의 태그를 가진다.(<head><meta name="generator" content="Hexo 3.9.0">,</head><body>)<br>head-meta date=설정 정보(애플리케이션을 위한 데이터) 기본적으로 시멘틱을 생각했을때 sciprt태그가 head에 들어가야한다고 생각하지만, html은 인터프리터 언어이기때문에 스크립트 태그는 body끝나기 전에 사용한다.이는 DOM을 생성하는 것과 관련이있다. script태그가 앞에나오게 되면 html은 순차적으로 위에서 아래도 일고 해석하는 인터프리터 언어인데 scipt태그에서 DOM과 관련된 내용을 건드리게 되고 아직html의 DOM은 생성되어있는 상태가 아니기 때문에 에러를 발생시킨다.</body></p>
<script>안의 document.querySelecotr와 같은 요소 관련 내용은 html,css와 관련된 web api이다-> 그래서 웹 브라우저에서 실행하고 ,node.js에서는 실행하지 못한다.

 **ECMAScript는 (node/브라우저)모두 포함하는 코어이다.**

### 웹 브라우저는 어떻게 동작하는가?

client(웹브라우저)---server(회사의 서버)
request(client->server)------------response(server->client)

**loading(로딩)**-브라우저가 서버로 부터 다운로드하여 파일을 가져온다. 웹서버는 루트(대문)로 접근하면 index.html(html파일 안에는 javascript와 css등이 링크로 연결이 되어있다.)을 받을 수있다. 

www.naver.com/(index.html주소창에 생략이가능하다).-도메인 주소(서버가 식별 할 수 있는 주소)

------

모든 웹애플리케이션은 **HTTP**(htper text transfer protocol)프로토콜을 규약으로 동작한다.(request/response).서버의 파일은 0,1로 구성되어있는 데이터이다.이를 웹브라우저로  보낼때 서버에있는 정보를 패킷으로 잘게 쪼갠 정보를 보내고 이를 받아서 하나의 파일로 뭉치는 과정을 겪는다.



![3-3](https://poiemaweb.com/assets/fs-images/3-3.png)

load HTML을 한 상태가 (resquest와 response를 해서 index.html을 파일을 받은 상태)---Read(메모리상에 데이터를 올린다.)----Parse(html데이터를 읽어들여서 컴퓨터가 실행할 수있는 형식으로 만든다.)----->(결과물)Dom tree(부자관계 부모와 자식의 구조를 가진다.)

기본 html은 중첩된 구조를 가지고 있다.크게 html의 자식으로 head와 body태그가 있다.(이는 부모와 자식이라는  구조화 할 수있다.)그리고 container라는 div태그를 만들어서 그 안에 자식을 넣고 그 자식의 형제들을 넣는다. 그렇게 하는 것이 부모의 속성을 자식에게 상속시켜서 한번에 무엇인가를 처리하기 좋다. html의 중첩 같이 html의 자료구조를 배열하는것이 DOM tree를 구성하는 것이다. 

**이렇게 트리구조를 만드는 이유는?**-그래야 부모로 올라가고 자식으로 내려가고 왔다 갔다하면서 자료에 접근하기가 용이하다. 조작을 하려면 접근해야하는 메모리상 트리구조에서 조작을 한다. parsing은 rendering engine(html과 css)에서한다. http 1.1. connection은 한번에 자료를 하나씩 가져옴을 의미한다

html의 link에 css가 있으면 다시 서버에 요청을 보내서 그것을 가져와야한다. 그렇게 되면 html에서 parsing되며 만들고있던 Dom만들기를 일시 중단을 한다. css도 Dom tree를 형성하는데 이를 cssom tree라고 한다. 그후 DOM를 생성하는 작업을 계속 수행한다.(pasing 작업) 작업이 진행되면서 내려가다가 자바스크립트 링크를 만나면 다시 parsing를 중단하고  자바스크립트 엔진에서 이를 parsing한다 그러고 javascript DOM(syantax tree)을 만든다. 이런과정을 거치면서 만들어진html Dom 와 CSS DOM를 합쳐서 render tree라고 부른다.

render tree가 만들어지면은 이제 웹 브라우저에 그릴 준비가 끝났다.이후 그림을 그릴때 그림을 그리는것은 부담이 큰작업이기 때문에 변화가 없는 데이터에 대해서는 그리지 말아야한다.

**http특징은 단방향통신이다.**(ex무전기 양쪽에서 동시에 이야기를 할 수 없다.)/양방향통신(휴대전화)
**http특징 단방향 통신이지만 쌍으로 이루어져있다**.(request를 보내면 반드시 response가 있다. 요청을 받아서 그림을 그린다.)
Dom tree와 CSSOM TREE가 합쳐지고 render tree가 생성되는데 javascript의 sytax tree는 render tree의 내용을 지우거나 내용을 갈아낀운다던가 혹은 글자의 속성을 바꾼다 던지의 수행을 한다.



파일로 된 javascript 소스코드
token(더이산 나눌수 없는 원소-으미를 가지고 있는 최소단위인 형태소의 의미를 가진다.)
구문분석=문법들을 추가한다(어셈블리어로 만든다.)
자바스키립트 엔진의 소스코드 실행과정
script태그가 돔 구성보다 먼저 등장해서  cssom tree,dom tree의 돔 트리를 건드리면  DOM이 구성되지 상태이기 때문에 오류를 발생한다. body tag밑으로 와야한다.</script>]]></content>
      <tags>
        <tag>10월 2일 수업내용 정리</tag>
      </tags>
  </entry>
  <entry>
    <title>타입변환과 단축평가</title>
    <url>/2020/05/16/typechange/</url>
    <content><![CDATA[<h1 id="1-타입변환이란"><a href="#1-타입변환이란" class="headerlink" title="1. 타입변환이란?"></a>1. 타입변환이란?</h1><p>자바스크립트의 모든 값은 카입이 있다. 값의 타입은 개발자의 의도에 의해 다른 타입으로 변환될 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입변환 또는 타입캐스팅이라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//명시적 타입변환</span></span><br><span class="line"><span class="comment">//숫자를 문자열로 타입 캐스팅을 한다.</span></span><br><span class="line"><span class="keyword">var</span> str = x.toString();</span><br><span class="line"><span class="built_in">console</span>.log(typeif str,str) <span class="comment">//string 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//변수 x의 값이 변경된 것은 아니다. </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x,x) <span class="comment">//number 10;</span></span><br></pre></td></tr></table></figure>

<p>개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환 또는 타입 강제 변환이라고 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//암묵적 타입 변환</span></span><br><span class="line"><span class="comment">// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로새로운 문자열을 생성한다.</span></span><br><span class="line"><span class="keyword">var</span> str = x+<span class="string">''</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str,str) <span class="comment">//string 10</span></span><br><span class="line"><span class="comment">//x의 타입이 변경되는 것은 아니다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> x,x) <span class="comment">//number 10</span></span><br></pre></td></tr></table></figure>

<p>명시적 타입 변환이나 암묵적 타입변환이 기존 원시값을 직접 변경하는 것은 아니다. 원시값은 변경 불가능한 값이므로 변경 할 숭 없다. 타입 변환이란 기존 원시값을 사용해 다른 타입의 새로운 원시값을 생성하는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//원시값 1이 '1'로 직접 변경되는것은 아니다.</span></span><br><span class="line"><span class="comment">//1을 사용해 타입이 다른 '1'을 새롭게 생성하여 '1'+''을 평가한다.</span></span><br><span class="line"><span class="number">1</span>+ <span class="string">''</span><span class="comment">// -&gt;'1'</span></span><br></pre></td></tr></table></figure>

<p>암묵적 타입 변화은 변수의 값을 재할당해서 변경하는 것이 아니라 자바스크립트 엔진이 표현식을  에러없이 평가하기 위해 피연산자의 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다.<br>위 에제의 경우, 자바스크립트의 엔진은 표현식 x+’’ 을 평가하기위해서 변수 x의 숫자 값을 바탕으로 새로운 문자열 값을 ‘10’을 생성하고 이것으로 표현식 ‘10’+’’를 평가한다. 이때 암묵적으로 생성된 문자열 ‘10’은 변수 x에 할당되지않는다. 따라서 암묵적으로 생성된 문자열 ‘10’은 표현ㅅ기의 평가가 끝나면 아무도 참조하지 ㅇ낳으므로 가비지 컬렉션에 의해 메모리에서 해제된다.</p>
<p>명시적 타입변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 강제 변환은 자바스크립트  엔진에 의해 암묵적으로 , 즉 드러나지 않게 타입이 자동변환 되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러나지 않는다.</p>
<p>따라서 자신이 작성한 코드에서 암묵적 타입변환이 발생하는지, 발생한다면 어떤타입의 어떤 값으로 변환되는지, 그리고 타입 변환된 값으로 표현식은 어떻게 평가될 것인지 에측 가능해야한다. 만약 타입 변환결과를 예측 못하거나 예측이 결과와 일치하지않는다면 오류를 발생할 가능성이 높아진다.</p>
<p>그렇다면 명시벅 타입변환 만을 사용하고 암무거적 타입변환은 발생하지 않도록 코드를 작성하면 어떨까? 좋은 생각이지만 이러한 논리는 옳지 않다. 때로는 명시적 타입변환 보다 암묵적 타입 변환이 가독성 측면에서 더 좋을 수도 있다. 예를 들어 자바스크립트 문법을 잘 이해하고 있는 개발자에게는 (10).toString()보다 10 +’’이 더욱 간결하고 이해하기 쉽다.</p>
<p>중요한 것은 코드를 예측할 수 있어야 한다는 것이다. 동료가 작성한 코드를 정확히 이해할 수 있어야 자신의 코드는 타인에 의해 쉽게 이해 될 수 있어야한다. 이를 위해 타입 변환이 어떻게 동작하는지 정확히 알고 사용하는 것이 중요하다.</p>
<h1 id="2-암묵적-타입-변환"><a href="#2-암묵적-타입-변환" class="headerlink" title="2. 암묵적 타입 변환"></a>2. 암묵적 타입 변환</h1><p>자바스크립트 엔진은 표현식을 평가 할 때 개발자의 의도와는 상관없이 코드의 문맥을 고려하여 암묵적으로 데이터 타입 을강제로 변환(암묵적 타입 변환)할 때가 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//피연산자가 모두 문자열 타입이어야 하는 문맥</span></span><br><span class="line"><span class="string">'10'</span> + <span class="number">2</span> <span class="comment">//'102';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//피연산자가 모두 숫자 타입이어야하는 문맥</span></span><br><span class="line"><span class="number">5</span> * <span class="string">'10'</span> <span class="comment">//50;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//피연산자 또는 표현식이 불리언 타입이어야하는 문맥</span></span><br><span class="line">!<span class="number">0</span> <span class="comment">//true;</span></span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>이처럼 표현식을 평가 할때 코드의 문맥에 부합하지 않는 상황이 발생 할 수 있다. 디때 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다. 암묵적 타입 변환이 발생하면 문자열,숫자,불리언 같은 원시 타입 중 하나로 타입을 자동 변환한다. 타입 별로 암묵적 타입 변환이 어떻게 발생하는 지 살펴보자.</p>
<h2 id="2-1-문자열-타입으로-변환"><a href="#2-1-문자열-타입으로-변환" class="headerlink" title="2.1. 문자열 타입으로 변환"></a>2.1. 문자열 타입으로 변환</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>+<span class="string">'2'</span> <span class="comment">//'12';</span></span><br></pre></td></tr></table></figure>

<p>위에제는 +연산자는 피연산자 중 하나의 이상의 문자열이므로 문자열 연결 연산자로 종작한다. 문자열 연견 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모즌 연산자는 코드의 문맥 상 모두 문자열 타입이어야한다. </p>
<p>자바스크립트의 엔진은 문자열 연산자 표현식을 평가하기 위해서 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적으로 타입 변환한다.<br>연산자 표현식의 피연산자(피연산자도 표현식이다)만이 암묵적 타입변환 의 대상이 되는 것은 아니다. 앞서 언급했듯이 자바스크립트 엔진은 표현식을 평가 할때 코드 문맥에 부합하도록 암묵적 타입 변환을 실행한다.</p>
<p>예를 들어 ES6에서 도입된 템플릿 리터럴의 표현식 삽입은 표현식의 평가 결과를 문자열 타입으로 암묵적으로 변환한다</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`1 + 1 = <span class="subst">$&#123;<span class="number">1</span>+<span class="number">1</span>&#125;</span>`</span> <span class="comment">// ' 1 + 1 = 2'</span></span><br></pre></td></tr></table></figure>

<p>자바스크립트의 엔진은 문자열아닌 갓을 문자열 타입으로 변환을 수행할때 아래와 같이 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//숫자 타입</span></span><br><span class="line"></span><br><span class="line"> <span class="number">0</span> +<span class="string">''</span> <span class="comment">//'0'</span></span><br><span class="line"><span class="number">-0</span>+ <span class="string">''</span> <span class="comment">//'0'</span></span><br><span class="line"><span class="number">1</span>+<span class="string">''</span> <span class="comment">//'1'</span></span><br><span class="line"><span class="number">-1</span>+<span class="string">''</span> <span class="comment">//'-1';</span></span><br><span class="line"><span class="literal">NaN</span> + <span class="string">''</span> <span class="comment">// 'NaN'</span></span><br><span class="line"><span class="literal">Infinity</span>+<span class="string">''</span> <span class="comment">// 'Infinity';</span></span><br><span class="line">-Infinitiy + <span class="string">''</span> <span class="comment">// '-Infinity'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//불리언 타입 </span></span><br><span class="line"><span class="literal">true</span> +<span class="string">''</span> <span class="comment">// 'true';</span></span><br><span class="line"><span class="literal">false</span> +<span class="string">''</span> <span class="comment">// 'false';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//null 타입</span></span><br><span class="line"><span class="literal">null</span> + <span class="string">''</span> <span class="comment">// 'null';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//undefined 타입</span></span><br><span class="line"><span class="literal">undefined</span> + <span class="string">''</span> <span class="comment">// 'undefined';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//심볼 타입</span></span><br><span class="line">(<span class="built_in">Symbol</span>())+ <span class="string">''</span>  <span class="comment">// TypeError :cannont convert a Symbol value to a string;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//객체 타입</span></span><br><span class="line">(&#123;&#125;)+<span class="string">''</span>  <span class="comment">// '[object Object]';</span></span><br><span class="line"><span class="built_in">Math</span> + <span class="string">''</span> <span class="comment">// '[object Math]';</span></span><br><span class="line">[]+<span class="string">''</span> <span class="comment">// ''</span></span><br><span class="line">[<span class="number">10</span>,<span class="number">20</span>]+<span class="string">''</span> <span class="comment">//'10,20';</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)+<span class="string">''</span> <span class="comment">// 'function()&#123;&#125;';</span></span><br><span class="line"><span class="built_in">Array</span> +<span class="string">''</span> <span class="comment">// 'function Array()&#123;[native code]&#125;'</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-숫자-타입으로-변환"><a href="#2-2-숫자-타입으로-변환" class="headerlink" title="2.2 숫자 타입으로 변환"></a>2.2 숫자 타입으로 변환</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> - <span class="string">'1'</span> <span class="comment">//0</span></span><br><span class="line"><span class="number">1</span> * <span class="string">'10'</span> <span class="comment">//10</span></span><br><span class="line"><span class="number">1</span> / <span class="string">'one'</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>위 예제에서 사용한 연산자는 모두 산술 연산자 이다. 산술 연산자의 역할은 숫자 값을 만드는 것이다. 따라서 산술 연산자의 모든 피연자는 코드 문맥 상 모두 숫자 타입이어야한다.</p>
<p>자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서  숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적으로 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환 할 수 없는 경우 산술 연산을 수행 할 수 없으므로 표현식의 평가 결과는 NaN이된다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'1'</span> &gt; <span class="number">0</span> <span class="comment">//true;</span></span><br></pre></td></tr></table></figure>

<p>비교 연산자의 역할은 불리언 값을 만드는것이다. &gt;연산자는 피연자의 크기를 비교하므로 피연산자는 코드의 문맥상 모두 숫자 타입이어야한다. 자바스크립트 엔진은 비교 연산자 표현식을 평가 하기 위해 비교 연산자 중에서 숫자 타입이 아닌 피연산자 숫자타입으로 암묵적 타입변환한다.<br>자바스크립트 엔진은 숫자 타입아닌 갓을 숫자 타입으로 암묵적 타입 변환을 수행 할대 아래와 같이 동작한다. +단한 연사자는 피연산자가 숫자 타입의 값이 아니면 숫자 타입 값으로 암묵적으로 타입변환을 한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 문자열 타입</span></span><br><span class="line">+<span class="string">''</span>       <span class="comment">// -&gt; 0</span></span><br><span class="line">+<span class="string">'0'</span>      <span class="comment">// -&gt; 0</span></span><br><span class="line">+<span class="string">'1'</span>      <span class="comment">// -&gt; 1</span></span><br><span class="line">+<span class="string">'string'</span> <span class="comment">// -&gt; NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 불리언 타입</span></span><br><span class="line">+<span class="literal">true</span>     <span class="comment">// -&gt; 1</span></span><br><span class="line">+<span class="literal">false</span>    <span class="comment">// -&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 타입</span></span><br><span class="line">+<span class="literal">null</span>     <span class="comment">// -&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined 타입</span></span><br><span class="line">+<span class="literal">undefined</span> <span class="comment">// -&gt; NaN</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 심볼 타입</span></span><br><span class="line">+<span class="built_in">Symbol</span>() <span class="comment">// -&gt; ypeError: Cannot convert a Symbol value to a number</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 타입</span></span><br><span class="line">+&#123;&#125;             <span class="comment">// -&gt; NaN</span></span><br><span class="line">+[]             <span class="comment">// -&gt; 0</span></span><br><span class="line">+[<span class="number">10</span>, <span class="number">20</span>]       <span class="comment">// -&gt; NaN</span></span><br><span class="line">+(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;) <span class="comment">// -&gt; NaN</span></span><br></pre></td></tr></table></figure>

<p>빈 문자열,빈 배열,null,false는 0으로 true는 1로 변환된다.  객체와 빈 배열이 아닌 배열 ,undefined는 변환되지 않아 NaN이 된다는 것에 주의 </p>
<h2 id="2-3-불리언-타입으로-변환"><a href="#2-3-불리언-타입으로-변환" class="headerlink" title="2.3. 불리언 타입으로 변환"></a>2.3. 불리언 타입으로 변환</h2><p>if문이나 for문과 같은 제어문 또는 삼항 조건 연산자의 조건식은 불리언 값 즉 , 논리적 참,거짓을 반환해야하는 표현식이다. 자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입로 변환한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">''</span>)    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)  <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span>)     <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">'str'</span>) <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">null</span>)  <span class="built_in">console</span>.log(<span class="string">'5'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 4</span></span><br></pre></td></tr></table></figure>

<p>이 때 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 또는 Falsy값으로 구분한다. 즉 제어문의 조건식과 같이 불리언 값으로 평가 되어야 할 문맥에서 Truthy 값은 true로 , Falsy 값은 false로 암묵적 타입변환을 한다.</p>
<p>아래 값들은 false로 평가되는 Falsy 값이다.</p>
<ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0, -0</li>
<li>NaN</li>
<li>’’ (빈문자열);</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 아래의 조건문은 모두 코드 블록을 실행한다.</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">false</span>)     <span class="built_in">console</span>.log(<span class="literal">false</span> + <span class="string">' is falsy value'</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">undefined</span>) <span class="built_in">console</span>.log(<span class="literal">undefined</span> + <span class="string">' is falsy value'</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">null</span>)      <span class="built_in">console</span>.log(<span class="literal">null</span> + <span class="string">' is falsy value'</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="number">0</span>)         <span class="built_in">console</span>.log(<span class="number">0</span> + <span class="string">' is falsy value'</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="literal">NaN</span>)       <span class="built_in">console</span>.log(<span class="literal">NaN</span> + <span class="string">' is falsy value'</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="string">''</span>)        <span class="built_in">console</span>.log(<span class="string">''</span> + <span class="string">' is falsy value'</span>);</span><br></pre></td></tr></table></figure>

<p>Falsy 값 이외의 모든 값은 모두 true로 평가되는 Truthy 값이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 주어진 값이 falsy값이면 true, Truthy 값이면 false을 반환한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFalsy</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//주어진 인자가 truthy 값이면 true, Falsy깂이면 false을 반환한다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isTruhty</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 모두 true를 반환한다.</span></span><br><span class="line">isFalsy(<span class="literal">false</span>);</span><br><span class="line">isFalsy(<span class="literal">undefined</span>);</span><br><span class="line">isFalsy(<span class="literal">null</span>);</span><br><span class="line">isFalsy(<span class="number">0</span>);</span><br><span class="line">isFalsy(<span class="literal">NaN</span>);</span><br><span class="line">isFalsy(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 모두 true를 반환한다.</span></span><br><span class="line">isTruthy(<span class="literal">true</span>);</span><br><span class="line">isTruthy(<span class="string">'0'</span>); <span class="comment">// 빈 문자열이 아닌 문자열은 Truthy 값이다.</span></span><br><span class="line">isTruthy(&#123;&#125;);</span><br><span class="line">isTruthy([]);</span><br></pre></td></tr></table></figure>

<h1 id="3-명시적-타입-변환"><a href="#3-명시적-타입-변환" class="headerlink" title="3. 명시적 타입 변환"></a>3. 명시적 타입 변환</h1><p>개발자의 의도에 의해 명시적으로 타입을 변환하는 방법은 다양하다. 표준 빌트인 생성자 함수를 new 연산자 호출 없이 호출하는 방법과 빌트인 메소드를 사용하는 방법, 그리고 앞에서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다.</p>
<p>표준빌트인 생성자 함수와 빌트인 메소드<br>표준 빌트인 생성자 함수와 표준 빌트인 메소드는 자바스크립트에서 기본으로 제공하는 함수이다. 표준 빌트인 생성자 함수는 객체를 생성하기 위한 함수이며 new연산자와 함께 호출한다. 표준 빌트인 메소드는 자바스크립트에서 기본 제공하는 빌트인객체릐 메소드이다. </p>
<h2 id="3-1-문자열-타입으로-변환"><a href="#3-1-문자열-타입으로-변환" class="headerlink" title="3.1. 문자열 타입으로 변환"></a>3.1. 문자열 타입으로 변환</h2><p>문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 다음과같다.</p>
<p>1.String 생성자 함수르 new 연산자 없이 호출하는 방법.</p>
<p>2.Object.prototype.toString() 메소드를 사용하느 방법<br>3.문자열 연결 연산자를 사용하는 방법</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. String 생성자 함수를 new호출없이 호출하는 방법</span></span><br><span class="line"><span class="comment">//숫자 타입 =&gt; 문자열</span></span><br><span class="line"><span class="built_in">String</span>(<span class="number">1</span>);        <span class="comment">// -&gt; "1"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">NaN</span>);      <span class="comment">// -&gt; "NaN"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">Infinity</span>); <span class="comment">// -&gt; "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">true</span>);     <span class="comment">// -&gt; "true"</span></span><br><span class="line"><span class="built_in">String</span>(<span class="literal">false</span>);    <span class="comment">// -&gt; "false"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Object.prototype.toString 메소드를 사용하는 방법</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line">(<span class="number">1</span>).toString();        <span class="comment">// -&gt; "1"</span></span><br><span class="line">(<span class="literal">NaN</span>).toString();      <span class="comment">// -&gt; "NaN"</span></span><br><span class="line">(<span class="literal">Infinity</span>).toString(); <span class="comment">// -&gt; "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line">(<span class="literal">true</span>).toString();     <span class="comment">// -&gt; "true"</span></span><br><span class="line">(<span class="literal">false</span>).toString();    <span class="comment">// -&gt; "false"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 문자열 연결 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="number">1</span> + <span class="string">''</span>;        <span class="comment">// -&gt; "1"</span></span><br><span class="line"><span class="literal">NaN</span> + <span class="string">''</span>;      <span class="comment">// -&gt; "NaN"</span></span><br><span class="line"><span class="literal">Infinity</span> + <span class="string">''</span>; <span class="comment">// -&gt; "Infinity"</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 문자열 타입</span></span><br><span class="line"><span class="literal">true</span> + <span class="string">''</span>;     <span class="comment">// -&gt; "true"</span></span><br><span class="line"><span class="literal">false</span> + <span class="string">''</span>;    <span class="comment">// -&gt; "false"</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-숫자-타입으로-변환"><a href="#3-2-숫자-타입으로-변환" class="headerlink" title="3.2  숫자 타입으로 변환"></a>3.2  숫자 타입으로 변환</h2><p>숫자 타입이 아닌 어떤 값을 숫자 타입으로 변환하는 방법은 다음과 같다.</p>
<ol>
<li>Number 생성자 함수르 new 연산자 없이 호출하는 방법</li>
<li>paseInt ,parseFloat 함수를 사용하는 방법(문자열만 숫자 타입로 변환가능);</li>
<li>+단항 산술 연산자를 이용하는 방법</li>
<li>*산술연산자를 사용하는 방법</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'0'</span>);     <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'-1'</span>);    <span class="comment">// -&gt; -1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'10.53'</span>); <span class="comment">// -&gt; 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>);    <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">false</span>);   <span class="comment">// -&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0'</span>);       <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'-1'</span>);      <span class="comment">// -&gt; -1</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'10.53'</span>); <span class="comment">// -&gt; 10.53</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. + 단항 산술 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line">+<span class="string">'0'</span>;     <span class="comment">// -&gt; 0</span></span><br><span class="line">+<span class="string">'-1'</span>;    <span class="comment">// -&gt; -1</span></span><br><span class="line">+<span class="string">'10.53'</span>; <span class="comment">// -&gt; 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line">+<span class="literal">true</span>;    <span class="comment">// -&gt; 1</span></span><br><span class="line">+<span class="literal">false</span>;   <span class="comment">// -&gt; 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. * 산술 연산자를 이용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="string">'0'</span> * <span class="number">1</span>;     <span class="comment">// -&gt; 0</span></span><br><span class="line"><span class="string">'-1'</span> * <span class="number">1</span>;    <span class="comment">// -&gt; -1</span></span><br><span class="line"><span class="string">'10.53'</span> * <span class="number">1</span>; <span class="comment">// -&gt; 10.53</span></span><br><span class="line"><span class="comment">// 불리언 타입 =&gt; 숫자 타입</span></span><br><span class="line"><span class="literal">true</span> * <span class="number">1</span>;    <span class="comment">// -&gt; 1</span></span><br><span class="line"><span class="literal">false</span> * <span class="number">1</span>;   <span class="comment">// -&gt; 0</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-불리언-타입으로-변환"><a href="#3-3-불리언-타입으로-변환" class="headerlink" title="3.3. 불리언 타입으로 변환"></a>3.3. 불리언 타입으로 변환</h2><p>불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법</p>
<ol>
<li>Boolean 생성자 삼수를 new 연산자 없이 호출하는 방법</li>
<li>!부정 논리 연산자를 두번 사용하는 방법</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'x'</span>);       <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">''</span>);        <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="string">'false'</span>);   <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">0</span>);         <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="number">1</span>);         <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">NaN</span>);       <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">Infinity</span>);  <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="comment">// null 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">null</span>);      <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// undefined 타입 =&gt; 불리언 타 입</span></span><br><span class="line"><span class="built_in">Boolean</span>(<span class="literal">undefined</span>); <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// 객체 타입 =&gt; 불리언 타입</span></span><br><span class="line"><span class="built_in">Boolean</span>(&#123;&#125;);        <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="built_in">Boolean</span>([]);        <span class="comment">// -&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. ! 부정 논리 연산자를 두번 사용하는 방법</span></span><br><span class="line"><span class="comment">// 문자열 타입 =&gt; 불리언 타입</span></span><br><span class="line">!!<span class="string">'x'</span>;       <span class="comment">// -&gt; true</span></span><br><span class="line">!!<span class="string">''</span>;        <span class="comment">// -&gt; false</span></span><br><span class="line">!!<span class="string">'false'</span>;   <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="comment">// 숫자 타입 =&gt; 불리언 타입</span></span><br><span class="line">!!<span class="number">0</span>;         <span class="comment">// -&gt; false</span></span><br><span class="line">!!<span class="number">1</span>;         <span class="comment">// -&gt; true</span></span><br><span class="line">!!<span class="literal">NaN</span>;       <span class="comment">// -&gt; false</span></span><br><span class="line">!!<span class="literal">Infinity</span>;  <span class="comment">// -&gt; true</span></span><br><span class="line"><span class="comment">// null 타입 =&gt; 불리언 타입</span></span><br><span class="line">!!<span class="literal">null</span>;      <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// undefined 타입 =&gt; 불리언 타입</span></span><br><span class="line">!!<span class="literal">undefined</span>; <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="comment">// 객체 타입 =&gt; 불리언 타입</span></span><br><span class="line">!!&#123;&#125;;        <span class="comment">// -&gt; true</span></span><br><span class="line">!![];        <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<h1 id="4-단축-평가"><a href="#4-단축-평가" class="headerlink" title="4.  단축 평가"></a>4.  단축 평가</h1><p>논리합(||)  연산자와 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수 도 있다. 논리합 ,논리곱 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된 다는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'Cat'</span> &amp;&amp; <span class="string">'Dog'</span> <span class="comment">// 'Dog'</span></span><br></pre></td></tr></table></figure>

<p>논리곱 연산자는 두개의 피연산자가 모두 true 일때 모두 true 를 반환한다. 논리곱 연산자는 결합 순서가 좌항에서 우항으로 평가가 진행된다.<br>첫번째 피연산자 ‘Cat’은 truty 값이므로 true로 평가 된다. 하지만 이 시점까지는 위 표현식을 평가 할 수없다. 두번째 피연산자까지 평가해 보아야 위 표현식을 평가 할 수 있다. 다시 말해 두번째 피연산자가 위 논리곱 연산자 표현식의 평가 결과를 결정한다.이때 논리곱 연산자 논리 연산의 결과를 결정한 두번재  피연산자 즉 문자열 ‘Dog’를 그대로 반환한다.</p>
<p>논리합 연산자도 논리곱 연산자와 동일하게 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'Cat'</span> || <span class="string">'Dog'</span> <span class="comment">// -&gt; "Cat"</span></span><br></pre></td></tr></table></figure>

<p>논리함 연산자는 두개의 피연산자 중 하나만 true로 평가 되어도 true를 반환한다. 논리합 연산자도 왼쪽에서 오른쪽으로 진행된다. 찻 반째 피연산자 ‘Cat’은  truthy한 값이므로 true로 평가된다. 이 시점에서 두 번째 피연산자까지 평가 해 보지 않아도 위 표현식을 평가 할수있다. 이때 논리 합 연산자는 논리 연산의 결과를 결정한 첫번째 피연산자 즉 ,문자열 ‘Cat’을 그대로 반환한다.<br>논리곱 연산자와 논리합 연산자는 이와 같이 논리 연산의 결과를 결정한 피연산자를 타입 변환 하지 않고 그대로 반환한다. 이를 단축 평가라 부른다. 단축평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우,나머지 평가 과정을 생략한다. 대부분의 프로그래밍 언어는 단축병가를 통해 논리 연산을 수행한다.</p>
<p>단축 평가는 아래의 규칙을 따른다. </p>
<table>
<thead>
<tr>
<th align="left">단축 평가 표현식</th>
<th align="left">평가 결과</th>
</tr>
</thead>
<tbody><tr>
<td align="left">true || anything</td>
<td align="left">true</td>
</tr>
<tr>
<td align="left">false || anything</td>
<td align="left">anything</td>
</tr>
<tr>
<td align="left">true &amp;&amp; anything</td>
<td align="left">anything</td>
</tr>
<tr>
<td align="left">false &amp;&amp; anything</td>
<td align="left">false</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 논리합(||) 연산자</span></span><br><span class="line"><span class="string">'Cat'</span> || <span class="string">'Dog'</span>  <span class="comment">// -&gt; "Cat"</span></span><br><span class="line"><span class="literal">false</span> || <span class="string">'Dog'</span>  <span class="comment">// -&gt; "Dog"</span></span><br><span class="line"><span class="string">'Cat'</span> || <span class="literal">false</span>  <span class="comment">// -&gt; "Cat"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 논리곱(&amp;&amp;) 연산자</span></span><br><span class="line"><span class="string">'Cat'</span> &amp;&amp; <span class="string">'Dog'</span>  <span class="comment">// -&gt; "Dog"</span></span><br><span class="line"><span class="literal">false</span> &amp;&amp; <span class="string">'Dog'</span>  <span class="comment">// -&gt; false</span></span><br><span class="line"><span class="string">'Cat'</span> &amp;&amp; <span class="literal">false</span>  <span class="comment">// -&gt; false</span></span><br></pre></td></tr></table></figure>

<p>단축 평가를 사용하면 if문을 대체 할 수 있다 . 주어진 조건이 truthy값(참으로 평가되는 값)일 때 무언가를 해야한다면 온리곱 연산자 표현식으로 if문을 대체 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">''</span>;</span><br><span class="line"><span class="comment">//주어진 조건이 true일 때 </span></span><br><span class="line"><span class="keyword">if</span>(done)message = <span class="string">'완료'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if문은 단축 평가로 대체 가능하다.</span></span><br><span class="line"><span class="comment">//done에 true라면 message에 '완료'를 할당</span></span><br><span class="line">message = done &amp;&amp; <span class="string">'완료'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(message) <span class="comment">//완료</span></span><br></pre></td></tr></table></figure>

<p>주어진 조건이 truthy값(거짓으로 평가 되는 값) 일 때 무언가를 해야 한다면 논리합 연산자 표현식으로 if문을 대체할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//주어진 조건이 false 일때</span></span><br><span class="line"><span class="keyword">if</span>(!done)mesage = <span class="string">'미완료'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if문은 단축평가로 대체 가능하다.</span></span><br><span class="line"> <span class="comment">//done이 false이면 message에 '미완료'를 할당</span></span><br><span class="line">message = done || <span class="string">'미완료'</span>;</span><br><span class="line">consoel.log(message) <span class="comment">//미완료</span></span><br></pre></td></tr></table></figure>

<p>참고로 삼항 조건 연산자는 if…else문을 대체 할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> done = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//if else문</span></span><br><span class="line"><span class="keyword">if</span>(done)message =<span class="string">'완료'</span>;</span><br><span class="line"><span class="keyword">else</span> message = <span class="string">'미완료'</span>;</span><br><span class="line">consoel.log(message) <span class="comment">// 완료;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//if ...else 문은 삼항 조건 연산자로 대체 가능 하다.</span></span><br><span class="line">message = done ? <span class="string">'완료'</span> :<span class="string">'미완료'</span>;</span><br><span class="line">consoel.log(message) <span class="comment">//  완료</span></span><br></pre></td></tr></table></figure>

<p>객체를 가리키는 변수가  null(또는 undefined)인지 확인하고 프로퍼티를 참조 할 때</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> value = elem.value; <span class="comment">//// TypeError: Cannot read property 'value' of null</span></span><br><span class="line"><span class="keyword">var</span> value = elem &amp;&amp; elem.value <span class="comment">//null</span></span><br></pre></td></tr></table></figure>

<p>객체는 키와 값으로 구성된 프로퍼티들의 집합이다. 만약 객체를 가리키는 변수가 null인 경우 , 객체의 프로퍼티를 참조하면 타입에러가 발생한다. 이때 단축 평가를 사용하면 에러가 발생하지않는다.</p>
<p>ES11(ECMAScript2020)에 도입될 것으로 알려진 옵셔널 체이닝(optional chaining, 2020년 5월 현재, stage 4) 문법을 사용하면 논리곱(&amp;&amp;) 연산자 표현식을 대체할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> elem = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// elem이 null 또는 undefined인 경우, 옵셔널 체이닝 문법은 undefined를 반환한다.</span></span><br><span class="line"><span class="keyword">const</span> value = elem ? .value; <span class="comment">//undefined;</span></span><br><span class="line"><span class="comment">//const value = (elem === null || elem === undefined)? undefined :elem.value;</span></span><br></pre></td></tr></table></figure>

<p>함수 매개 변수에 기본값을 설정 할때</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//단축 평가를 사용한 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  str = str || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStringLength() <span class="comment">// 0;</span></span><br><span class="line">setStringLength(<span class="string">'hi'</span>) <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ES6의 매개변수의 기본값 설정</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStringLength</span>(<span class="params">str = <span class="string">''</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.length;</span><br><span class="line">&#125;</span><br><span class="line">getStringLength(); <span class="comment">//0;</span></span><br><span class="line">getStringLength(<span class="string">'hi'</span>) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>함수를 호출할 때 인수를 전달하지 않으면 매개 변수를 undefined을 갖는다. 이때 단축평가를 사용하여 매개 변수의 기본값을 설정하면 undefined로인해 발생 할 수 있는 에러를 방지할 수 있다.</p>
]]></content>
      <tags>
        <tag>타입변환과 단축평가에 대해</tag>
      </tags>
  </entry>
</search>
